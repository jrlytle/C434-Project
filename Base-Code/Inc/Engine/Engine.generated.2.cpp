// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/EnginePrivate.h"
#include "Engine.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FLinearColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FIntPoint();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FQuat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FGuid();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	INPUTCORE_API class UEnum* Z_Construct_UEnum_InputCore_ETouchIndex();
	INPUTCORE_API class UScriptStruct* Z_Construct_UScriptStruct_FKey();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FStringClassReference();
	INPUTCORE_API class UEnum* Z_Construct_UEnum_InputCore_EControllerHand();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EMouseCursor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FIntVector();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EAxis();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBoxSphereBounds();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveFloat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveQuat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FPackedNormal();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FMatrix();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBox();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FStringAssetReference();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FControllerEvent();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnalogInputEvent();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FKeyEvent();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputEvent();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FPointerEvent();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FDateTime();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTimespan();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRandomStream();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FPlane();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ESearchCase();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ESearchDir();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FButtonStyle();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FCheckBoxStyle();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveVector2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveTwoVectors();
	SLATE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputChord();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatRange();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FCompositeFont();
	SLATECORE_API class UClass* Z_Construct_UClass_UFontProviderInterface_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveLinearColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector4();
	SLATECORE_API class UScriptStruct* Z_Construct_UScriptStruct_FSlateBrush();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EPixelFormat();

	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EViewModeIndex();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDemoPlayFailure();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETravelType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETravelFailure();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENetworkFailure();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETickingGroup();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EInputEvent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FExposureSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FURL();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPrimitiveComponentPostPhysicsTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FActorComponentTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FActorTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTickPrerequisite();
	ENGINE_API class UClass* Z_Construct_UClass_UEngineBaseTypes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEngineBaseTypes();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantizeNormal();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize100();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize10();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFastArraySerializer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFastArraySerializerItem();
	ENGINE_API class UClass* Z_Construct_UClass_UDamageType_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDamageType();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_TimerDynamicDelegate__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESpawnActorCollisionHandlingMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAngularConstraintMotion();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EComponentSocketType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EComponentMobility();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPhysicalSurface();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EWalkableSlopeBehavior();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERotatorQuantization();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVectorQuantization();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEndPlayReason();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAutoPossessAI();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAutoReceiveInput();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENetDormancy();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENetRole();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMeshFeatureImportance();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EShadowMapFlags();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELightMapPaddingType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionEnabled();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETimelineSigType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESleepFamily();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERadialImpulseFalloff();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EInputConsumeOptions();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EFilterInterpolationType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionResponse();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPhysicsSceneType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETraceTypeQuery();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EObjectTypeQuery();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EOverlapFilterOption();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionChannel();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMovementMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETriangleSortAxis();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETriangleSortOption();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELightingBuildQuality();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialSamplerType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialTessellationMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialShadingModel();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleCollisionMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETrailWidthMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETranslucentSortPolicy();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETranslucencyLightingMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESamplerSourceMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBlendMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAttachLocation();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EActorMetricsType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAspectRatioAxisConstraint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCanvasUVTri();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFontRenderInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDepthFieldGlowInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDebugFloatHistory();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRedirector();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDirectoryPath();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFilePath();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FComponentReference();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FConstrainComponentPropName();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FWalkableSlopeOverride();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRepAttachment();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRepMovement();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTimerHandle();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRadialDamageEvent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRadialDamageParams();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPointDamageEvent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDamageEvent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMeshMergingSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMeshProxySettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialSimplificationSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMeshBuildSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMeshReductionSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPOV();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimUpdateRateParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotDesc();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMTDResult();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FOverlapResult();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPrimitiveMaterialRef();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSwarmDebugOptions();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassDebugOptions();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassPrimitiveSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassPointLightSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassLightSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLocalizedSubtitle();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSubtitleCue();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBasedPosition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFractureEffect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollisionImpactData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyContactInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyErrorCorrection();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyState();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollisionResponseContainer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FResponseChannel();
	ENGINE_API class UClass* Z_Construct_UClass_UEngineTypes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEngineTypes();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENodeAdvancedPins();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENodeTitleType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEdGraphPinDirection();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphNode_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphNode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBlueprintPinStyleType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEdGraphPinType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSimpleMemberReference();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphPin_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphPin();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintCore_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintCore();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBlueprintType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBlueprintStatus();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEditedDocumentInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBPInterfaceDescription();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBPVariableDescription();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBPVariableMetaDataEntry();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprint_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMemberReference();
	ENGINE_API class UClass* Z_Construct_UClass_UInterface_AssetUserData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterface_AssetUserData();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EComponentCreationMethod();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_Activate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_AddTickPrerequisiteActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_AddTickPrerequisiteComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_ComponentHasTag();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_Deactivate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_GetOwner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_IsActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_IsBeingDestroyed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_IsComponentTickEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_K2_DestroyComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_OnRep_IsActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_ReceiveBeginPlay();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_ReceiveEndPlay();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_ReceiveTick();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_RemoveTickPrerequisiteActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_RemoveTickPrerequisiteComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_SetActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_SetComponentTickEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_SetIsReplicated();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_SetTickableWhenPaused();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_SetTickGroup();
	ENGINE_API class UFunction* Z_Construct_UFunction_UActorComponent_ToggleActive();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_PhysicsVolumeChanged__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERelativeTransformSpace();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDetailMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FOverlapInfo();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_DetachFromParent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_DoesSocketExist();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetAllSocketNames();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetAttachParent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetChildComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetChildrenComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetComponentVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetForwardVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetNumChildrenComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetParentComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetPhysicsVolume();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetRelativeTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetRightVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetSocketLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetSocketQuaternion();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetSocketRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetSocketTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_GetUpVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_IsAnySimulatingPhysics();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_IsSimulatingPhysics();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_IsVisible();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddLocalOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddLocalRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddLocalTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddRelativeLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddRelativeRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddWorldOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddWorldRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AddWorldTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_AttachTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_GetComponentLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_GetComponentRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_GetComponentScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_GetComponentToWorld();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetRelativeLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetRelativeLocationAndRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetRelativeRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetRelativeTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetWorldLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetWorldLocationAndRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetWorldRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_K2_SetWorldTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_OnRep_Transform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_OnRep_Visibility();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_ResetRelativeTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_SetAbsolute();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_SetHiddenInGame();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_SetRelativeScale3D();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_SetVisibility();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_SetWorldScale3D();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_SnapTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneComponent_ToggleVisibility();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorEndPlaySignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorDestroyedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorEndTouchOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorBeginTouchOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorOnInputTouchEndSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorOnInputTouchBeginSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorOnReleasedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorOnClickedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorEndCursorOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorBeginCursorOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorHitSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorEndOverlapSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorBeginOverlapSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_TakePointDamageSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_TakeAnyDamageSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ActorHasTag();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_AddComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_AddTickPrerequisiteActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_AddTickPrerequisiteComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_DetachRootComponentFromParent();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_DisableInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_EnableInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_FlushNetDormancy();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ForceNetUpdate();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorBounds();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorEnableCollision();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorEyesViewPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorForwardVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorRelativeScale3D();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorRightVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorScale3D();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorTimeDilation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetActorUpVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetComponentByClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetComponentsByClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetComponentsByTag();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetDistanceTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetDotProductTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetHorizontalDistanceTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetHorizontalDotProductTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetInputAxisKeyValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetInputAxisValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetInputVectorAxisValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetInstigator();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetInstigatorController();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetLifeSpan();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetOverlappingActors();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetOverlappingComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetOwner();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetTickableWhenPaused();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_GetVerticalDistanceTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_HasAuthority();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_IsActorBeingDestroyed();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_IsActorTickEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_IsOverlappingActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AddActorLocalOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AddActorLocalRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AddActorLocalTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AddActorWorldOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AddActorWorldRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AddActorWorldTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AttachRootComponentTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_AttachRootComponentToActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_DestroyActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_DestroyComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_GetActorLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_GetActorRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_GetRootComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_OnBecomeViewTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_OnEndViewTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_OnReset();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_SetActorLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_SetActorLocationAndRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_SetActorRelativeLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_SetActorRelativeRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_SetActorRelativeTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_SetActorTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_K2_TeleportTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_MakeMIDForMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_MakeNoise();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_OnRep_AttachmentReplication();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_OnRep_Instigator();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_OnRep_ReplicatedMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_OnRep_ReplicateMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorBeginCursorOver();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorBeginOverlap();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorEndCursorOver();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorEndOverlap();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorOnClicked();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorOnInputTouchBegin();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorOnInputTouchEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorOnInputTouchEnter();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorOnInputTouchLeave();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveActorOnReleased();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveAnyDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveBeginPlay();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveDestroyed();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveEndPlay();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveHit();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceivePointDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveRadialDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_ReceiveTick();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_RemoveTickPrerequisiteActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_RemoveTickPrerequisiteComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetActorEnableCollision();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetActorHiddenInGame();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetActorRelativeScale3D();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetActorRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetActorScale3D();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetActorTickEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetLifeSpan();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetOwner();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetReplicateMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetReplicates();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetTickableWhenPaused();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SetTickGroup();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_SnapRootComponentTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_TearOff();
	ENGINE_API class UFunction* Z_Construct_UFunction_AActor_UserConstructionScript();
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AAmbientSound_AdjustVolume();
	ENGINE_API class UFunction* Z_Construct_UFunction_AAmbientSound_FadeIn();
	ENGINE_API class UFunction* Z_Construct_UFunction_AAmbientSound_FadeOut();
	ENGINE_API class UFunction* Z_Construct_UFunction_AAmbientSound_Play();
	ENGINE_API class UFunction* Z_Construct_UFunction_AAmbientSound_Stop();
	ENGINE_API class UClass* Z_Construct_UClass_AAmbientSound_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AAmbientSound();
	ENGINE_API class UClass* Z_Construct_UClass_UPendingNetGame_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPendingNetGame();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLatentActionManager();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLatentActionInfo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameInstance_DebugCreatePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameInstance_DebugRemovePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameInstance_HandleNetworkError();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameInstance_HandleTravelError();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameInstance_ReceiveInit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameInstance_ReceiveShutdown();
	ENGINE_API class UClass* Z_Construct_UClass_UGameInstance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UGameInstance();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEndClothSimulationFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStartClothSimulationFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEndPhysicsTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStartPhysicsTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLevelViewportInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UWorld_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UWorld();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLevelSimplificationDetails();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDynamicTextureInstance();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStreamableTextureInstance();
	ENGINE_API class UClass* Z_Construct_UClass_ULevel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULevel();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBrushType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECsgOper();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGeomSelection();
	ENGINE_API class UClass* Z_Construct_UClass_ABrush_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ABrush();
	ENGINE_API class UClass* Z_Construct_UClass_ABrushShape_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ABrushShape();
	ENGINE_API class UClass* Z_Construct_UClass_AVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AVolume();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ReverbPreset();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInteriorSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FReverbSettings();
	ENGINE_API class UClass* Z_Construct_UClass_AAudioVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AAudioVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ABlockingVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ABlockingVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ACameraBlockingVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ACameraBlockingVolume();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCullDistanceSizePair();
	ENGINE_API class UClass* Z_Construct_UClass_ACullDistanceVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ACullDistanceVolume();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EStreamingVolumeUsage();
	ENGINE_API class UClass* Z_Construct_UClass_ALevelStreamingVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALevelStreamingVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ALightmassCharacterIndirectDetailVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALightmassCharacterIndirectDetailVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ALightmassImportanceVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALightmassImportanceVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ANavMeshBoundsVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavMeshBoundsVolume();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavigationQueryResult();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavPathEvent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavDataGatheringModeConfig();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavDataGatheringMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavigationOptionFlag();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavDataConfig();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavAgentProperties();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMovementProperties();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavAgentSelector();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationTypes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationTypes();
	ENGINE_API class UClass* Z_Construct_UClass_UNavRelevantInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavRelevantInterface();
	ENGINE_API class UFunction* Z_Construct_UFunction_ANavModifierVolume_SetAreaClass();
	ENGINE_API class UClass* Z_Construct_UClass_ANavModifierVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavModifierVolume();
	ENGINE_API class UClass* Z_Construct_UClass_APhysicsVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APhysicsVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ADefaultPhysicsVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADefaultPhysicsVolume();
	ENGINE_API class UClass* Z_Construct_UClass_AKillZVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AKillZVolume();
	ENGINE_API class UClass* Z_Construct_UClass_APainCausingVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APainCausingVolume();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBlendableLocation();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendableInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendableInterface();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAntiAliasingMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDepthOfFieldMethod();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPostProcessSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FWeightedBlendables();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FWeightedBlendable();
	ENGINE_API class UClass* Z_Construct_UClass_UScene_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UScene();
	ENGINE_API class UClass* Z_Construct_UClass_UInterface_PostProcessVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterface_PostProcessVolume();
	ENGINE_API class UFunction* Z_Construct_UFunction_APostProcessVolume_AddOrUpdateBlendable();
	ENGINE_API class UClass* Z_Construct_UClass_APostProcessVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APostProcessVolume();
	ENGINE_API class UClass* Z_Construct_UClass_APrecomputedVisibilityOverrideVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APrecomputedVisibilityOverrideVolume();
	ENGINE_API class UClass* Z_Construct_UClass_APrecomputedVisibilityVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APrecomputedVisibilityVolume();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerVolume();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACameraActor_GetAutoActivatePlayerIndex();
	ENGINE_API class UClass* Z_Construct_UClass_ACameraActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ACameraActor();
	ENGINE_API class UClass* Z_Construct_UClass_UNavAgentInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavAgentInterface();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_InstigatedAnyDamageSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_CastToPlayerController();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_ClientSetLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_ClientSetRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_GetControlRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_GetDesiredRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_GetViewTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_IsLocalController();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_IsLocalPlayerController();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_K2_GetPawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_LineOfSightTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_OnRep_Pawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_OnRep_PlayerState();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_Possess();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_ReceiveInstigatedAnyDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_SetControlRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_SetInitialLocationAndRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_StopMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_AController_UnPossess();
	ENGINE_API class UClass* Z_Construct_UClass_AController_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AController();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPlayerMuteList();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECameraAnimPlaySpace();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECameraProjectionMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMinimalViewInfo();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EInitialOscillatorOffset();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVOscillator();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FROscillator();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFOscillator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraShake_BlueprintUpdateCameraShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraShake_ReceiveIsFinished();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraShake_ReceivePlayShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraShake_ReceiveStopShake();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraShake_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraShake();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EViewTargetBlendFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FViewTargetTransitionParams();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTViewTarget();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCameraCacheEntry();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_AddCameraLensEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_AddNewCameraModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_BlueprintUpdateCamera();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_ClearCameraLensEffects();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_FindCameraModifierByClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_GetCameraLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_GetCameraRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_GetFOVAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_GetOwningPlayerController();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_PlayCameraAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_PlayCameraShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_RemoveCameraLensEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_RemoveCameraModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_SetManualCameraFade();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StartCameraFade();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopAllCameraAnims();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopAllCameraShakes();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopAllInstancesOfCameraAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopAllInstancesOfCameraShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopCameraAnimInst();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopCameraFade();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerCameraManager_StopCameraShake();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerCameraManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerCameraManager();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_InputGestureHandlerDynamicSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_InputVectorAxisHandlerDynamicSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_InputAxisHandlerDynamicSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_InputTouchHandlerDynamicSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_InputActionHandlerDynamicSignature__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EControllerAnalogStick();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_GetControllerAnalogKeyState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_GetControllerAnalogStickState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_GetControllerKeyTimeDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_GetControllerMouseDelta();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_GetControllerVectorKeyState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_GetTouchState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_IsControllerKeyDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_WasControllerKeyJustPressed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInputComponent_WasControllerKeyJustReleased();
	ENGINE_API class UClass* Z_Construct_UClass_UInputComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERichCurveExtrapolation();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERichCurveTangentWeightMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERichCurveTangentMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERichCurveInterpMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FIntegralCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FIntegralKey();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRichCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRichCurveKey();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNameCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNameCurveKey();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FIndexedCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKeyHandleMap();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCurveBase_GetTimeRange();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCurveBase_GetValueRange();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRuntimeFloatCurve();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCurveFloat_GetFloatValue();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveFloat_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveFloat();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FActiveForceFeedbackEffect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FForceFeedbackChannelDetails();
	ENGINE_API class UClass* Z_Construct_UClass_UForceFeedbackEffect_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UForceFeedbackEffect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FUniqueNetIdRepl();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDynamicForceFeedbackAction();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ActivateTouchInterface();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_AddPitchInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_AddRollInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_AddYawInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_Camera();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClearAudioListenerOverride();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientAddTextureStreamingLoc();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientCancelPendingMapChange();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientCapBandwidth();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientClearCameraLensEffects();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientCommitMapChange();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientEnableNetworkVoice();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientEndOnlineSession();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientFlushLevelStreaming();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientForceGarbageCollection();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientGameEnded();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientGotoState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientIgnoreLookInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientIgnoreMoveInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientMessage();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientMutePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPlayCameraAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPlayCameraShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPlayForceFeedback();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPlaySound();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPlaySoundAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPrepareMapChange();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientPrestreamTextures();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientReceiveLocalizedMessage();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientRepObjRef();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientReset();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientRestart();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientRetryClientRestart();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientReturnToMainMenu();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetBlockOnAsyncLoading();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetCameraFade();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetCameraMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetCinematicMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetForceMipLevelsToBeResident();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetHUD();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetSpectatorWaiting();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSetViewTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientSpawnCameraLensEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientStartOnlineSession();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientStopCameraAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientStopCameraShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientStopForceFeedback();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientTeamMessage();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientTravel();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientTravelInternal();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientUnmutePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientUpdateLevelStreamingStatus();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientVoiceHandshakeComplete();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ClientWasKicked();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ConsoleKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_DeprojectMousePositionToWorld();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_DeprojectScreenPositionToWorld();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_EnableCheats();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_FOV();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetFocalLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHitResultUnderCursor();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHitResultUnderCursorByChannel();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHitResultUnderCursorForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHitResultUnderFinger();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHitResultUnderFingerByChannel();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHitResultUnderFingerForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetHUD();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputAnalogKeyState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputAnalogStickState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputKeyTimeDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputMotionState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputMouseDelta();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputTouchState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetInputVectorKeyState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetMousePosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetSpectatorPawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_GetViewportSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_IsInputKeyDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_IsLookInputIgnored();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_IsMoveInputIgnored();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_LocalTravel();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_OnServerStartedVisualLogger();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_Pause();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_PlayDynamicForceFeedback();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_PlayHapticEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ProjectWorldLocationToScreen();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ResetIgnoreInputFlags();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ResetIgnoreLookInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ResetIgnoreMoveInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_RestartLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SendToConsole();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerAcknowledgePossession();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerCamera();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerChangeName();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerCheckClientPossession();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerCheckClientPossessionReliable();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerMutePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerNotifyLoadedWorld();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerPause();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerRestartPlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerSetSpectatorLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerSetSpectatorWaiting();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerShortTimeout();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerToggleAILogging();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerUnmutePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerUpdateCamera();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerUpdateLevelVisibility();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerVerifyViewTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerViewNextPlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerViewPrevPlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ServerViewSelf();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetAudioListenerOverride();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetCinematicMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetHapticsByValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetIgnoreLookInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetIgnoreMoveInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetName();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetViewTargetWithBlend();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SetVirtualJoystickVisibility();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_StartFire();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_StopHapticEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_SwitchLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_ToggleSpeaking();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_WasInputKeyJustPressed();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerController_WasInputKeyJustReleased();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADebugCameraController_ShowDebugSelectedInfo();
	ENGINE_API class UClass* Z_Construct_UClass_ADebugCameraController_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADebugCameraController();
	ENGINE_API class UClass* Z_Construct_UClass_ALogVisualizerCameraController_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALogVisualizerCameraController();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADecalActor_CreateDynamicMaterialInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADecalActor_GetDecalMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADecalActor_SetDecalMaterial();
	ENGINE_API class UClass* Z_Construct_UClass_ADecalActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADecalActor();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ActorFractureSignature__DelegateSignature();
	ENGINE_API class UClass* Z_Construct_UClass_ADestructibleActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADestructibleActor();
	ENGINE_API class UClass* Z_Construct_UClass_ADocumentationActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADocumentationActor();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ParticleCollisionSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ParticleDeathSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ParticleBurstSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ParticleSpawnSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_Activate();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_Deactivate();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_IsActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_OnParticleSystemFinished();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_OnRep_bCurrentlyActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_SetActorParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_SetColorParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_SetFloatParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_SetMaterialParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_SetTemplate();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_SetVectorParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_AEmitter_ToggleActive();
	ENGINE_API class UClass* Z_Construct_UClass_AEmitter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AEmitter();
	ENGINE_API class UClass* Z_Construct_UClass_AEmitterCameraLensEffectBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AEmitterCameraLensEffectBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDebugTextInfo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_AddDebugText();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_AddHitBox();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_Deproject();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawLine();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawMaterialSimple();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawMaterialTriangle();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawRect();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawText();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawTexture();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_DrawTextureSimple();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_GetActorsInSelectionRectangle();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_GetOwningPawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_GetOwningPlayerController();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_GetTextSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_Project();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ReceiveDrawHUD();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ReceiveHitBoxBeginCursorOver();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ReceiveHitBoxClick();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ReceiveHitBoxEndCursorOver();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ReceiveHitBoxRelease();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_RemoveAllDebugStrings();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_RemoveDebugText();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ShowDebug();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ShowDebugForReticleTargetToggle();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ShowDebugToggleSubCategory();
	ENGINE_API class UFunction* Z_Construct_UFunction_AHUD_ShowHUD();
	ENGINE_API class UClass* Z_Construct_UClass_AHUD_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AHUD();
	ENGINE_API class UClass* Z_Construct_UClass_ADebugCameraHUD_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADebugCameraHUD();
	ENGINE_API class UClass* Z_Construct_UClass_ALogVisualizerHUD_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALogVisualizerHUD();
	ENGINE_API class UClass* Z_Construct_UClass_AInfo_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AInfo();
	ENGINE_API class UClass* Z_Construct_UClass_AAtmosphericFog_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AAtmosphericFog();
	ENGINE_API class UFunction* Z_Construct_UFunction_AExponentialHeightFog_OnRep_bEnabled();
	ENGINE_API class UClass* Z_Construct_UClass_AExponentialHeightFog_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AExponentialHeightFog();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationObjectBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationObjectBase();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerStart_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerStart();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGameClassShortName();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_AbortMatch();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_CanSpectate();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ChangeName();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ChoosePlayerStart();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_EndMatch();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_FindPlayerStart();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_GetDefaultPawnClassForController();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_GetMatchState();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_GetNumPlayers();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_HasMatchEnded();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_HasMatchStarted();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_InitStartSpot();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_IsMatchInProgress();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_FindPlayerStart();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_OnChangeName();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_OnLogout();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_OnRestartPlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_OnSetMatchState();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_OnSwapPlayerControllers();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_K2_PostLogin();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_MustSpectate();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_PlayerCanRestart();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ReadyToEndMatch();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ReadyToStartMatch();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ResetLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_RestartGame();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ReturnToMainMenuHost();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_SetBandwidthLimit();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_ShouldReset();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_SpawnDefaultPawnFor();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_StartMatch();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameMode_StartPlay();
	ENGINE_API class UClass* Z_Construct_UClass_AGameMode_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AGameMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EStandbyType();
	ENGINE_API class UClass* Z_Construct_UClass_AGameNetworkManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AGameNetworkManager();
	ENGINE_API class UClass* Z_Construct_UClass_AGameSession_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AGameSession();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameState_GetServerWorldTimeSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameState_OnRep_ElapsedTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameState_OnRep_GameModeClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameState_OnRep_MatchState();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameState_OnRep_ReplicatedWorldTimeSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_AGameState_OnRep_SpectatorClass();
	ENGINE_API class UClass* Z_Construct_UClass_AGameState_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AGameState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerState_OnRep_bIsInactive();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerState_OnRep_PlayerName();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerState_OnRep_Score();
	ENGINE_API class UFunction* Z_Construct_UFunction_APlayerState_OnRep_UniqueId();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerState_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerState();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASkyLight_OnRep_bEnabled();
	ENGINE_API class UClass* Z_Construct_UClass_ASkyLight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASkyLight();
	ENGINE_API class UClass* Z_Construct_UClass_AWindDirectionalSource_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AWindDirectionalSource();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVisibilityAggressiveness();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHierarchicalSimplification();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNetViewer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassWorldInfoSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGameModePrefix();
	ENGINE_API class UFunction* Z_Construct_UFunction_AWorldSettings_OnRep_WorldGravityZ();
	ENGINE_API class UClass* Z_Construct_UClass_AWorldSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AWorldSettings();
	ENGINE_API class UClass* Z_Construct_UClass_ALevelBounds_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALevelBounds();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALevelScriptActor_LevelReset();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALevelScriptActor_RemoteEvent();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALevelScriptActor_SetCinematicMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALevelScriptActor_WorldOriginLocationChanged();
	ENGINE_API class UClass* Z_Construct_UClass_ALevelScriptActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALevelScriptActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponentBase_GetLightColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponentBase_SetCastShadows();
	ENGINE_API class UClass* Z_Construct_UClass_ULightComponentBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULightComponentBase();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetAffectDynamicIndirectLighting();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetAffectTranslucentLighting();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetBloomScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetBloomThreshold();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetBloomTint();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetEnableLightShaftBloom();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetIESTexture();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetIndirectLightingIntensity();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetIntensity();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetLightColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetLightFunctionDisabledBrightness();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetLightFunctionFadeDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetLightFunctionMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetLightFunctionScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULightComponent_SetTemperature();
	ENGINE_API class UClass* Z_Construct_UClass_ULightComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULightComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_GetBrightness();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_GetLightColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_IsEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_OnRep_bEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetAffectTranslucentLighting();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetBrightness();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetCastShadows();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetLightColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetLightFunctionFadeDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetLightFunctionMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_SetLightFunctionScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_ALight_ToggleEnabled();
	ENGINE_API class UClass* Z_Construct_UClass_ALight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALight();
	ENGINE_API class UClass* Z_Construct_UClass_ADirectionalLight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADirectionalLight();
	ENGINE_API class UFunction* Z_Construct_UFunction_APointLight_SetLightFalloffExponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_APointLight_SetRadius();
	ENGINE_API class UClass* Z_Construct_UClass_APointLight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APointLight();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASpotLight_SetInnerConeAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASpotLight_SetOuterConeAngle();
	ENGINE_API class UClass* Z_Construct_UClass_ASpotLight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASpotLight();
	ENGINE_API class UClass* Z_Construct_UClass_AGeneratedMeshAreaLight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AGeneratedMeshAreaLight();
	ENGINE_API class UClass* Z_Construct_UClass_ALODActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ALODActor();
	ENGINE_API class UClass* Z_Construct_UClass_AMaterialInstanceActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AMaterialInstanceActor();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnMatineeEvent__DelegateSignature();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpGroupActorInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCameraCutInfo();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_ChangePlaybackDirection();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_Pause();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_Play();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_Reverse();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_SetLoopingState();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_SetPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_AMatineeActor_Stop();
	ENGINE_API class UClass* Z_Construct_UClass_AMatineeActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AMatineeActor();
	ENGINE_API class UClass* Z_Construct_UClass_AMatineeActorCameraAnim_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AMatineeActorCameraAnim();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavigationFilterFlags();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavigationFilterArea();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationQueryFilter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationQueryFilter();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERuntimeGenerationType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSupportedAreaData();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationData();
	ENGINE_API class UClass* Z_Construct_UClass_AAbstractNavData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AAbstractNavData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavGraphNode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavGraphEdge();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationGraph_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationGraph();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERecastPartitioning();
	ENGINE_API class UClass* Z_Construct_UClass_ARecastNavMesh_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ARecastNavMesh();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationGraphNode_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationGraphNode();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerStartPIE_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerStartPIE();
	ENGINE_API class UClass* Z_Construct_UClass_UNavPathObserverInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavPathObserverInterface();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavCostDisplay();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationTestingActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavigationTestingActor();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENavLinkDirection();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavigationSegmentLink();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavigationLink();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavigationLinkBase();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkDefinition_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkDefinition();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkHostInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkHostInterface();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_SmartLinkReachedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_ANavLinkProxy_HasMovingAgents();
	ENGINE_API class UFunction* Z_Construct_UFunction_ANavLinkProxy_IsSmartLinkEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_ANavLinkProxy_ReceiveSmartLinkReached();
	ENGINE_API class UFunction* Z_Construct_UFunction_ANavLinkProxy_ResumePathFollowing();
	ENGINE_API class UFunction* Z_Construct_UFunction_ANavLinkProxy_SetSmartLinkEnabled();
	ENGINE_API class UClass* Z_Construct_UClass_ANavLinkProxy_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANavLinkProxy();
	ENGINE_API class UClass* Z_Construct_UClass_ANote_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ANote();
	ENGINE_API class UClass* Z_Construct_UClass_AParticleEventManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AParticleEventManager();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_AddControllerPitchInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_AddControllerRollInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_AddControllerYawInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_AddMovementInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_ConsumeMovementInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_DetachFromControllerPendingDestroy();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetBaseAimRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetController();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetControlRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetLastMovementInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetMovementBaseActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetMovementComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetNavAgentLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_GetPendingMovementInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_IsControlled();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_IsLocallyControlled();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_IsMoveInputIgnored();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_K2_GetMovementInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_LaunchPawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_OnRep_Controller();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_OnRep_PlayerState();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_PawnMakeNoise();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_ReceivePossessed();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_ReceiveUnpossessed();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_SetCanAffectNavigationGeneration();
	ENGINE_API class UFunction* Z_Construct_UFunction_APawn_SpawnDefaultController();
	ENGINE_API class UClass* Z_Construct_UClass_APawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APawn();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPreviewAssetAttachContainer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPreviewAttachedObjectPair();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSmartNameContainer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSmartNameMapping();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBoneTranslationRetargetingMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotGroup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRigConfiguration();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNameMapping();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoneReductionSetting();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FReferencePose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoneNode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSkeletonToMeshLinkup();
	ENGINE_API class UClass* Z_Construct_UClass_USkeleton_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USkeleton();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTriMeshCollisionData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTriIndices();
	ENGINE_API class UClass* Z_Construct_UClass_UInterface_CollisionDataProvider_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterface_CollisionDataProvider();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_SkeletalMeshOptimizationType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMaterial();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FClothingAssetData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FClothPhysicsProperties();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMorphTargetMap();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMeshLODInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoneReference();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTriangleSortSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoneMirrorExport();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoneMirrorInfo();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMesh_FindSocket();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMesh_IsSectionUsingCloth();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMesh_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMesh();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAnimGroupRole();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERootMotionMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERootMotionRootLock();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationGroupReference();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRootMotionMovementParams();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimGroupInstance();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimTickRecord();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimExtractContext();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlendFilter();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlendSampleData();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimationAsset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimationAsset();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_CharacterReachedApexSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_CharacterMovementUpdatedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_MovementModeChangedSignature__DelegateSignature();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBasedMovementInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSimulatedRootMotionReplicatedMove();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRepRootMotionMontage();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_CanJump();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_CanJumpInternal();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_ClientCheatFly();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_ClientCheatGhost();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_ClientCheatWalk();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_Crouch();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_GetCurrentMontage();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_IsJumpProvidingForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_IsPlayingNetworkedRootMotionMontage();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_IsPlayingRootMotion();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_Jump();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_K2_OnEndCrouch();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_K2_OnMovementModeChanged();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_K2_OnStartCrouch();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_K2_UpdateCustomMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_LaunchCharacter();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnJumped();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnLanded();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnLaunched();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnRep_IsCrouched();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnRep_ReplicatedBasedMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnRep_RootMotion();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_OnWalkingOffLedge();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_PlayAnimMontage();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_SetReplicateMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_StopAnimMontage();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_StopJumping();
	ENGINE_API class UFunction* Z_Construct_UFunction_ACharacter_UnCrouch();
	ENGINE_API class UClass* Z_Construct_UClass_ACharacter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ACharacter();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_LookUp();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_LookUpAtRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_MoveForward();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_MoveRight();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_MoveUp_World();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_Turn();
	ENGINE_API class UFunction* Z_Construct_UFunction_ADefaultPawn_TurnAtRate();
	ENGINE_API class UClass* Z_Construct_UClass_ADefaultPawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ADefaultPawn();
	ENGINE_API class UClass* Z_Construct_UClass_ASpectatorPawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASpectatorPawn();
	ENGINE_API class UClass* Z_Construct_UClass_AWheeledVehicle_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AWheeledVehicle();
	ENGINE_API class UClass* Z_Construct_UClass_AReflectionCapture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AReflectionCapture();
	ENGINE_API class UClass* Z_Construct_UClass_ABoxReflectionCapture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ABoxReflectionCapture();
	ENGINE_API class UClass* Z_Construct_UClass_APlaneReflectionCapture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlaneReflectionCapture();
	ENGINE_API class UClass* Z_Construct_UClass_ASphereReflectionCapture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASphereReflectionCapture();
	ENGINE_API class UClass* Z_Construct_UClass_ARigidBodyBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ARigidBodyBase();
	ENGINE_API class UClass* Z_Construct_UClass_APhysicsConstraintActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APhysicsConstraintActor();
	ENGINE_API class UClass* Z_Construct_UClass_APhysicsThruster_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APhysicsThruster();
	ENGINE_API class UFunction* Z_Construct_UFunction_ARadialForceActor_DisableForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_ARadialForceActor_EnableForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_ARadialForceActor_FireImpulse();
	ENGINE_API class UFunction* Z_Construct_UFunction_ARadialForceActor_ToggleForce();
	ENGINE_API class UClass* Z_Construct_UClass_ARadialForceActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ARadialForceActor();
	ENGINE_API class UClass* Z_Construct_UClass_ASceneCapture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASceneCapture();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASceneCapture2D_OnInterpToggle();
	ENGINE_API class UClass* Z_Construct_UClass_ASceneCapture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASceneCapture2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASceneCaptureCube_OnInterpToggle();
	ENGINE_API class UClass* Z_Construct_UClass_ASceneCaptureCube_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASceneCaptureCube();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDOFMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBodyInstance();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollisionResponse();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentEndTouchOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentBeginTouchOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnInputTouchEndSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnInputTouchBeginSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnReleasedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnClickedSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentEndCursorOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentBeginCursorOverSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentSleepSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentWakeSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentEndOverlapSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentBeginOverlapSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentHitSignature__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECanBeCharacterBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSpriteCategoryInfo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddAngularImpulse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddForceAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddImpulse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddImpulseAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddRadialForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddRadialImpulse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddTorque();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_CanCharacterStepUp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_ClearMoveIgnoreActors();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_CopyArrayOfMoveIgnoreActors();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_CreateDynamicMaterialInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetAngularDamping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCenterOfMass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetClosestPointOnCollision();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCollisionObjectType();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCollisionProfileName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCollisionResponseToChannel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetInertiaTensor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetLinearDamping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetMass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetMassScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetNumMaterials();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetOverlapInfos();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingActors();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsAngularVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetWalkableSlopeOverride();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_IgnoreActorWhenMoving();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_IsGravityEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_K2_LineTraceComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_PutRigidBodyToSleep();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_ScaleByMomentOfInertia();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetAllMassScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetAllPhysicsLinearVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetAngularDamping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCastShadow();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCenterOfMass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionObjectType();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionProfileName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToAllChannels();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToChannel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetConstraintMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCullDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCustomDepthStencilValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetEnableGravity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetLinearDamping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetLockedAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetMassOverrideInKg();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetMassScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetNotifyRigidBodyCollision();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetOnlyOwnerSee();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetOwnerNoSee();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsAngularVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsLinearVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsMaxAngularVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysMaterialOverride();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetRenderCustomDepth();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetRenderInMainPass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetSimulatePhysics();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetTranslucentSortPriority();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetWalkableSlopeOverride();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_WakeAllRigidBodies();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPrimitiveComponent_WakeRigidBody();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMeshComponent_GetMaterials();
	ENGINE_API class UClass* Z_Construct_UClass_UMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMeshComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBoneSpaces();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMeshComponentUpdateFlag();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPhysBodyOp();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBoneVisibilityStatus();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSkelMeshComponentLODInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FActiveVertexAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_BoneIsChildOf();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetBoneIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetBoneName();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetParentBone();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetSocketBoneName();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_HideBoneByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_IsBoneHiddenByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_SetMasterPoseComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_SetPhysicsAsset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_SetSkeletalMesh();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_TransformFromBoneSpace();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_TransformToBoneSpace();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkinnedMeshComponent_UnHideBoneByName();
	ENGINE_API class UClass* Z_Construct_UClass_USkinnedMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USkinnedMeshComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAngularDriveMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EConstraintFrame();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELinearConstraintMotion();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FConstraintInstance();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ConstraintBrokenSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_BreakConstraint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetConstraintForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing1();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing2();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentTwist();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularDriveParams();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationDrive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing1Limit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing2Limit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularTwistLimit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityDrive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstrainedComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceFrame();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceOrientation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferencePosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetDisableCollision();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearDriveParams();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionDrive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityDrive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearXLimit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearYLimit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearZLimit();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsConstraintComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsConstraintComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAnimLinkMethod();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimLinkableElement();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECurveBlendOption();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAdditiveAnimationType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENotifyFilterType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMontageNotifyTickType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNotifyTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNotifyEvent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRawCurveTracks();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTransformCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVectorCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimCurveBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAnimationMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EKinematicBonesUpdateToPhysics();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMeshComponentPreClothTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSingleAnimationPlayData();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_BindClothToMasterPoseComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ClearMorphTargets();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleport();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetAnimationMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetAnimInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetClothMaxDistanceScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetMorphTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetPlayRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_IsPlaying();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_Play();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_PlayAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ResetAllBodiesSimulatePhysics();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ResetClothTeleportMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesSimulatePhysics();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularDriveParams();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularPositionDrive();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAnimationMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAnimInstanceClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetClothMaxDistanceScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetEnablePhysicsBlending();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetMorphTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetPhysicsBlendWeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetPlayRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_Stop();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshComponent_UnbindClothFromMasterPoseComponent();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMeshComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UMatineeAnimInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMatineeAnimInterface();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial0();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial1();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMesh();
	ENGINE_API class UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedPhysAsset();
	ENGINE_API class UClass* Z_Construct_UClass_ASkeletalMeshActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASkeletalMeshActor();
	ENGINE_API class UClass* Z_Construct_UClass_ASplineMeshActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ASplineMeshActor();
	ENGINE_API class UClass* Z_Construct_UClass_AStaticMeshActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AStaticMeshActor();
	ENGINE_API class UClass* Z_Construct_UClass_ATargetPoint_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATargetPoint();
	ENGINE_API class UClass* Z_Construct_UClass_ATextRenderActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATextRenderActor();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerBase();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerBox_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerBox();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerCapsule_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerCapsule();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerSphere_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ATriggerSphere();
	ENGINE_API class UClass* Z_Construct_UClass_AVectorFieldVolume_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AVectorFieldVolume();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature();
	ENGINE_API class UClass* Z_Construct_UClass_UApplicationLifecycleComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UApplicationLifecycleComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_ConstrainDirectionToPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_ConstrainLocationToPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_ConstrainNormalToPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_GetGravityZ();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_GetMaxSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_GetPhysicsVolume();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintAxisSetting();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintNormal();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintOrigin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_IsExceedingMaxSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_K2_GetMaxSpeedModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_K2_GetModifiedMaxSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_K2_MoveUpdatedComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_PhysicsVolumeChanged();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintAxisSetting();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintFromVectors();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintNormal();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintOrigin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SetUpdatedComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_SnapUpdatedComponentToPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMovementComponent_StopMovementImmediately();
	ENGINE_API class UClass* Z_Construct_UClass_UMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMovementComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESplineCoordinateSpace();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESplinePointType();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_AddSplineLocalPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_AddSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_AddSplineWorldPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_ClearSplinePoints();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetDefaultUpVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetDirectionAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetDirectionAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetDirectionAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetDistanceAlongSplineAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetInputKeyAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetLocalLocationAndTangentAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAndTangentAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetNumberOfSplinePoints();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetQuaternionAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetQuaternionAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetQuaternionAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRightVectorAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRightVectorAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRightVectorAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRollAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRollAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRollAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRotationAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRotationAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetRotationAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetScaleAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetScaleAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetScaleAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetSplineLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetSplinePointType();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetTangentAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetTangentAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetTangentAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetTransformAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetTransformAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetTransformAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetUpVectorAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetUpVectorAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetUpVectorAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldLocationAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldLocationAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldLocationAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldRotationAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldRotationAtTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_GetWorldTangentAtDistanceAlongSpline();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_IsClosedLoop();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetClosedLoop();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetDefaultUpVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetLocationAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetSelectedSplineSegmentColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetSplineLocalPoints();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetSplinePoints();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetSplinePointType();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetSplineWorldPoints();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetTangentAtSplinePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetUnselectedSplineSegmentColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineComponent_SetWorldLocationAtSplinePoint();
	ENGINE_API class UClass* Z_Construct_UClass_USplineComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USplineComponent();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EInterpToBehaviourType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpControlPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInterpToMovementComponent_StopSimulating();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpToMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpToMovementComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintFunctionLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintFunctionLibrary();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnNavDataGenerigEvent__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_FNavigationSystemRunMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_FindPathToActorSynchronously();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_FindPathToLocationSynchronously();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetNavigationSystem();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetPathCost();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetPathLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomPointInNavigableRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomPointInRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomReachablePointInRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_IsNavigationBeingBuilt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_NavigationRaycast();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_OnNavigationBoundsUpdated();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_ProjectPointToNavigation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_RegisterNavigationInvoker();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_ResetMaxSimultaneousTileGenerationJobsCount();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_SetGeometryGatheringMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_SetMaxSimultaneousTileGenerationJobsCount();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_SimpleMoveToActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_SimpleMoveToLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationSystem_UnregisterNavigationInvoker();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationSystem_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationSystem();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_IsCrouching();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_IsFalling();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_IsFlying();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_IsMovingOnGround();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_IsSwimming();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_StopActiveMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavMovementComponent_StopMovementKeepPathing();
	ENGINE_API class UClass* Z_Construct_UClass_UNavMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavMovementComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_AddInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_ConsumeInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_GetLastInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_GetPawnOwner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_GetPendingInputVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_IsMoveInputIgnored();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnMovementComponent_K2_GetInputVector();
	ENGINE_API class UClass* Z_Construct_UClass_UPawnMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPawnMovementComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavAvoidanceMask();
	ENGINE_API class UClass* Z_Construct_UClass_URVOAvoidanceInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URVOAvoidanceInterface();
	ENGINE_API class UClass* Z_Construct_UClass_UNetworkPredictionInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNetworkPredictionInterface();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCharacterMovementComponentPreClothTickFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFindFloorResult();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_AddForce();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_AddImpulse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_CalcVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_CapsuleTouched();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientAckGoodMove();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustRootMotionPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientVeryShortAdjustPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_DisableMovement();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetAnalogInputModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetCharacterOwner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetCurrentAcceleration();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetImpartedMovementBaseVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetMaxAcceleration();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetMaxJumpHeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetMovementBase();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetPerchRadiusThreshold();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetValidPerchRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_IsWalkable();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_IsWalking();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_K2_GetModifiedMaxAcceleration();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorZ();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMove();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDual();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDualHybridRootMotion();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveOld();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceGroup();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToAvoid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToIgnore();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetMovementMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorZ();
	ENGINE_API class UClass* Z_Construct_UClass_UCharacterMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCharacterMovementComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UFloatingPawnMovement_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UFloatingPawnMovement();
	ENGINE_API class UClass* Z_Construct_UClass_USpectatorPawnMovement_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USpectatorPawnMovement();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVehicleInputRate();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FReplicatedVehicleState();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FWheelSetup();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetCurrentGear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineMaxRotationSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineRotationSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetForwardSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetTargetGear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetUseAutoGears();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_ServerUpdateState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceGroup();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearUp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToAvoid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToIgnore();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetHandbrakeInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetSteeringInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetTargetGear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetThrottleInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetUseAutoGears();
	ENGINE_API class UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVehicleDifferential4W();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVehicleTransmissionData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVehicleGearData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVehicleEngineData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVehicleDifferential4WData();
	ENGINE_API class UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent4W_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent4W();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UProjectileMovementComponent_LimitVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UProjectileMovementComponent_SetVelocityInLocalSpace();
	ENGINE_API class UFunction* Z_Construct_UFunction_UProjectileMovementComponent_StopSimulating();
	ENGINE_API class UClass* Z_Construct_UClass_UProjectileMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UProjectileMovementComponent();
	ENGINE_API class UClass* Z_Construct_UClass_URotatingMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URotatingMovementComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationInvokerComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationInvokerComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavRelevantComponent_SetNavigationRelevancy();
	ENGINE_API class UClass* Z_Construct_UClass_UNavRelevantComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavRelevantComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkCustomInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkCustomInterface();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkCustomComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkCustomComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavModifierComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavModifierComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPawnNoiseEmitterComponent_MakeNoise();
	ENGINE_API class UClass* Z_Construct_UClass_UPawnNoiseEmitterComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPawnNoiseEmitterComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_GetTargetLocationAndRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_GrabComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_ReleaseComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularDamping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularStiffness();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetInterpolationSpeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearDamping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearStiffness();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocationAndRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetRotation();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsHandleComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsHandleComponent();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlatformEventsComponent_IsInLaptopMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlatformEventsComponent_IsInTabletMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlatformEventsComponent_SupportsConvertibleLaptops();
	ENGINE_API class UClass* Z_Construct_UClass_UPlatformEventsComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPlatformEventsComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAtmospherePrecomputeParameters();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_DisableGroundScattering();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_DisableSunDisk();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetAltitudeScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultBrightness();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultLightColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityMultiplier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetFogMultiplier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetPrecomputeParams();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetStartDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetSunMultiplier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_StartPrecompute();
	ENGINE_API class UClass* Z_Construct_UClass_UAtmosphericFogComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAtmosphericFogComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESoundSpatializationAlgorithm();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAttenuationShape();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESoundDistanceCalc();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESoundDistanceModel();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAttenuationSettings();
	ENGINE_API class UClass* Z_Construct_UClass_USoundAttenuation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundAttenuation();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnQueueSubtitles__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnAudioFinished__DelegateSignature();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAudioComponentParam();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_AdjustAttenuation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_AdjustVolume();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_BP_GetAttenuationSettingsToApply();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_FadeIn();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_FadeOut();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_IsPlaying();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_Play();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetBoolParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetFloatParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetIntParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetPitchMultiplier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetSound();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetUISound();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetVolumeMultiplier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_SetWaveParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAudioComponent_Stop();
	ENGINE_API class UClass* Z_Construct_UClass_UAudioComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAudioComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraComponent_AddOrUpdateBlendable();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraComponent_GetCameraView();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UChildActorComponent_SetChildActorClass();
	ENGINE_API class UClass* Z_Construct_UClass_UChildActorComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UChildActorComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDecalComponent_CreateDynamicMaterialInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDecalComponent_GetDecalMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDecalComponent_SetDecalMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDecalComponent_SetSortOrder();
	ENGINE_API class UClass* Z_Construct_UClass_UDecalComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDecalComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringExponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogDensity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogHeightFalloff();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogInscatteringColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogMaxOpacity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetStartDistance();
	ENGINE_API class UClass* Z_Construct_UClass_UExponentialHeightFogComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UExponentialHeightFogComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeDistributionExponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeTransitionFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowCascades();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetEnableLightShaftOcclusion();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetLightShaftOverrideDirection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetOcclusionMaskDarkness();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetShadowDistanceFadeoutFraction();
	ENGINE_API class UClass* Z_Construct_UClass_UDirectionalLightComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDirectionalLightComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPointLightComponent_SetAttenuationRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPointLightComponent_SetLightFalloffExponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPointLightComponent_SetSourceLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPointLightComponent_SetSourceRadius();
	ENGINE_API class UClass* Z_Construct_UClass_UPointLightComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPointLightComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USpotLightComponent_SetInnerConeAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_USpotLightComponent_SetOuterConeAngle();
	ENGINE_API class UClass* Z_Construct_UClass_USpotLightComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USpotLightComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESkyLightSourceType();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_RecaptureSky();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetCubemap();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetCubemapBlend();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetIndirectLightingIntensity();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetIntensity();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetLightColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetMinOcclusion();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkyLightComponent_SetOcclusionTint();
	ENGINE_API class UClass* Z_Construct_UClass_USkyLightComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USkyLightComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationGraphNodeComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationGraphNodeComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetNormalizedCompressionScalar();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringCurrentEndPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringDirection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringRestingPoint();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsSpringComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsSpringComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsThrusterComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsThrusterComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPostProcessComponent_AddOrUpdateBlendable();
	ENGINE_API class UClass* Z_Construct_UClass_UPostProcessComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPostProcessComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UArrowComponent_SetArrowColor_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UArrowComponent_SetArrowColor_New();
	ENGINE_API class UClass* Z_Construct_UClass_UArrowComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UArrowComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBillboardComponent_SetSprite();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBillboardComponent_SetSpriteAndUV();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBillboardComponent_SetUV();
	ENGINE_API class UClass* Z_Construct_UClass_UBillboardComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBillboardComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UBrushComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBrushComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UDrawFrustumComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDrawFrustumComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBatchedPoint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBatchedLine();
	ENGINE_API class UClass* Z_Construct_UClass_ULineBatchComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULineBatchComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialSpriteElement();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialBillboardComponent_AddElement();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialBillboardComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialBillboardComponent();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_ComponentFractureSignature__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDestructibleComponent_ApplyDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDestructibleComponent_ApplyRadiusDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDestructibleComponent_GetDestructibleMesh();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDestructibleComponent_SetDestructibleMesh();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneLocationByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneRotationByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneScaleByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneTransformByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_ResetBoneTransformByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneLocationByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneRotationByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneScaleByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneTransformByName();
	ENGINE_API class UClass* Z_Construct_UClass_UPoseableMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPoseableMeshComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStaticMeshComponentLODInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPaintedVertex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UStaticMeshComponent_GetLocalBounds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UStaticMeshComponent_OnRep_StaticMesh();
	ENGINE_API class UFunction* Z_Construct_UFunction_UStaticMeshComponent_SetForcedLodModel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UStaticMeshComponent_SetStaticMesh();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInstancedStaticMeshMappingInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInstancedStaticMeshInstanceData();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstanceWorldSpace();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_ClearInstances();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceCount();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstancesOverlappingSphere();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_RemoveInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_SetCullDistances();
	ENGINE_API class UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_UpdateInstanceTransform();
	ENGINE_API class UClass* Z_Construct_UClass_UInstancedStaticMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInstancedStaticMeshComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FClusterNode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHierarchicalInstancedStaticMeshComponent_RemoveInstances();
	ENGINE_API class UClass* Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESplineMeshAxis();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSplineMeshParams();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMax();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMin();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndRoll();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndTangent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetForwardAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetSplineUpDir();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartRoll();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartTangent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMax();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMin();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndRoll();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndTangent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetForwardAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetSplineUpDir();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartAndEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartOffset();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartRoll();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartTangent();
	ENGINE_API class UClass* Z_Construct_UClass_USplineMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USplineMeshComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UModelComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UModelComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkRenderingComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkRenderingComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavMeshRenderingComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavMeshRenderingComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavTestRenderingComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavTestRenderingComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialUsage();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLightmassMaterialInterfaceSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialRelevance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInterface_GetBaseMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInterface_GetPhysicalMaterial();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInterface();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleSystemOcclusionBoundsMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ParticleSystemLODMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleSystemUpdateMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNamedEmitterMaterial();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLODSoloTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleSystemLOD();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystem_ContainsEmitterType();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSystem_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSystem();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnSystemFinished__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleEventType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ParticleReplayState();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleSysParamType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleSysParam();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_BeginTrails();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_CreateNamedDynamicMaterialInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_EndTrails();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_GenerateParticleEvent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_GetNamedMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_GetNumActiveParticles();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetActorParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamEndPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourcePoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceStrength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceTangent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetStrength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetTangent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetColorParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetEmitterEnable();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetFloatParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetMaterialParameter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetTemplate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetTrailSourceData();
	ENGINE_API class UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetVectorParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSystemComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSystemComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UShapeComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UShapeComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBoxComponent_GetScaledBoxExtent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBoxComponent_GetUnscaledBoxExtent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBoxComponent_SetBoxExtent();
	ENGINE_API class UClass* Z_Construct_UClass_UBoxComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBoxComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleHalfHeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetShapeScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleHalfHeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_SetCapsuleHalfHeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_SetCapsuleRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCapsuleComponent_SetCapsuleSize();
	ENGINE_API class UClass* Z_Construct_UClass_UCapsuleComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCapsuleComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_USphereComponent_GetScaledSphereRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_USphereComponent_GetShapeScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_USphereComponent_GetUnscaledSphereRadius();
	ENGINE_API class UFunction* Z_Construct_UFunction_USphereComponent_SetSphereRadius();
	ENGINE_API class UClass* Z_Construct_UClass_USphereComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USphereComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UDrawSphereComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDrawSphereComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVerticalTextAligment();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EHorizTextAligment();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_GetTextLocalSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_GetTextWorldSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_K2_SetText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetFont();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetHorizontalAlignment();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetHorizSpacingAdjust();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetTextMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetTextRenderColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetWorldSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetXScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTextRenderComponent_SetYScale();
	ENGINE_API class UClass* Z_Construct_UClass_UTextRenderComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextRenderComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVectorFieldComponent_SetIntensity();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorFieldComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorFieldComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_URadialForceComponent_AddObjectTypeToAffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_URadialForceComponent_FireImpulse();
	ENGINE_API class UFunction* Z_Construct_UFunction_URadialForceComponent_RemoveObjectTypeToAffect();
	ENGINE_API class UClass* Z_Construct_UClass_URadialForceComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URadialForceComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UReflectionCaptureComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UReflectionCaptureComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UBoxReflectionCaptureComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBoxReflectionCaptureComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UPlaneReflectionCaptureComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPlaneReflectionCaptureComponent();
	ENGINE_API class UClass* Z_Construct_UClass_USphereReflectionCaptureComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USphereReflectionCaptureComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEngineShowFlagsSetting();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneCaptureComponent_HideActorComponents();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneCaptureComponent_HideComponent();
	ENGINE_API class UClass* Z_Construct_UClass_USceneCaptureComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USceneCaptureComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESceneCaptureSource();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneCaptureComponent2D_AddOrUpdateBlendable();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneCaptureComponent2D_UpdateContent();
	ENGINE_API class UClass* Z_Construct_UClass_USceneCaptureComponent2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USceneCaptureComponent2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_USceneCaptureComponentCube_UpdateContent();
	ENGINE_API class UClass* Z_Construct_UClass_USceneCaptureComponentCube_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USceneCaptureComponentCube();
	ENGINE_API class UClass* Z_Construct_UClass_USpringArmComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USpringArmComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UWindDirectionalSourceComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UWindDirectionalSourceComponent();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineLinearColor__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineVector__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineFloat__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineEvent__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETimelineDirection();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETimelineLengthMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTimeline();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTimelineLinearColorTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTimelineFloatTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTimelineVectorTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTimelineEventEntry();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_GetPlaybackPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_GetPlayRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_GetTimelineLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_IsLooping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_IsPlaying();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_IsReversing();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_OnRep_Timeline();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_Play();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_PlayFromStart();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_Reverse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_ReverseFromEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_SetLooping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_SetNewTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_SetPlaybackPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_SetPlayRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_SetTimelineLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_SetTimelineLengthMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTimelineComponent_Stop();
	ENGINE_API class UClass* Z_Construct_UClass_UTimelineComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTimelineComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UAISystemBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAISystemBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETypeAdvanceAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSequenceBase_GetPlayLength();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSequenceBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSequenceBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimSegment();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRootMotionExtractionStep();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompositeBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompositeBase();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimComposite_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimComposite();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAlphaBlendOption();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAlphaBlend();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETransitionLogicType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETransitionBlendMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBakedAnimationStateMachine();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBakedAnimationState();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBakedStateExitTransition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationTransitionBetweenStates();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationState();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationStateBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationTransitionRule();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimStateMachineTypes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimStateMachineTypes();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnMontageBlendingOutStartedMCDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnMontageEndedMCDelegate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnMontageStartedMCDelegate__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBoneRotationSource();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBoneControlSpace();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSlotEvaluationPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPerBoneBlendWeights();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPerBoneBlendWeight();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FA2CSPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FA2Pose();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_AnimNotify_Sound();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_BlueprintInitializeAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_BlueprintPostEvaluateAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_BlueprintUpdateAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_CalculateDirection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_ClearMorphTargets();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetAnimAssetPlayerLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetAnimAssetPlayerTimeFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetAnimAssetPlayerTimeFromEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetAnimAssetPlayerTimeFromEndFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetCurrentStateElapsedTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetCurrentStateName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetCurveValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceAssetPlayerLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceAssetPlayerTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceAssetPlayerTimeFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceAssetPlayerTimeFromEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceAssetPlayerTimeFromEndFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceCurrentStateElapsedTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceStateWeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceTransitionCrossfadeDuration();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceTransitionTimeElapsed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetInstanceTransitionTimeElapsedFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetOwningActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetOwningComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetRelevantAnimLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetRelevantAnimTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetRelevantAnimTimeFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetRelevantAnimTimeRemaining();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetRelevantAnimTimeRemainingFraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_GetStateWeight();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_IsPlayingSlotAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_LockAIResources();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_GetCurrentSection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_IsActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_IsPlaying();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_JumpToSection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_JumpToSectionsEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_Pause();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_Play();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_SetNextSection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_SetPlayRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_Montage_Stop();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_PlaySlotAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_PlaySlotAnimationAsDynamicMontage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_SetMorphTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_StopSlotAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_TryGetPawnOwner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimInstance_UnlockAIResources();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimInstance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimInstance();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAnimNotifyEventType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimMontageInstance();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBranchingPointMarker();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBranchingPoint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSlotAnimationTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCompositeSection();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimMontage_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimMontage();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAdditiveBasePoseType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_AnimationKeyFormat();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_AnimationCompressionFormat();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCompressedOffsetData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCompressedTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCurveTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FScaleTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRotationTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTranslationTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTrackToSkeletonMap();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimSequenceTrackContainer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRawAnimSequenceTrack();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSequence_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSequence();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENotifyTriggerMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBlendSpaceAxis();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPerBoneInterpolation();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGridBlendSample();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEditorElement();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlendSample();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlendParameter();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpolationParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendSpaceBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendSpaceBase();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendSpace_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendSpace();
	ENGINE_API class UClass* Z_Construct_UClass_UAimOffsetBlendSpace_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAimOffsetBlendSpace();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendSpace1D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlendSpace1D();
	ENGINE_API class UClass* Z_Construct_UClass_UAimOffsetBlendSpace1D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAimOffsetBlendSpace1D();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_Automatic_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_Automatic();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_BitwiseCompressOnly_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_BitwiseCompressOnly();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_LeastDestructive_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_LeastDestructive();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_RemoveEverySecondKey_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_RemoveEverySecondKey();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_RemoveLinearKeys_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_RemoveLinearKeys();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_PerTrackCompression_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_PerTrackCompression();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_RemoveTrivialKeys_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimCompress_RemoveTrivialKeys();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_PostEvaluateAnimEvent__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_GetLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_PlayAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetAnimationAsset();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetBlendSpaceInput();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetLooping();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetPlaying();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetPlayRate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetReverse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_SetVertexAnimation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimSingleNodeInstance_StopAnim();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSingleNodeInstance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSingleNodeInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVehicleAnimInstance_GetVehicle();
	ENGINE_API class UClass* Z_Construct_UClass_UVehicleAnimInstance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVehicleAnimInstance();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimMetaData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimMetaData();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotify_GetNotifyName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotify_Received_Notify();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotify_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotify();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotifyState_GetNotifyName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotifyState_Received_NotifyBegin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotifyState_Received_NotifyEnd();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotifyState_Received_NotifyTick();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState_TimedParticleEffect_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState_TimedParticleEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAnimNotifyState_Trail_OverridePSTemplate();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState_Trail_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState_Trail();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimSetMeshLinkup();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSet_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimSet();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAssetImportInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UAssetImportData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAssetImportData();
	ENGINE_API class UClass* Z_Construct_UClass_UAssetUserData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAssetUserData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLaunchOnTestSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEditorMapPerformanceTestDefinition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBuildPromotionTestSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleEditorPromotionSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialEditorPromotionSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBuildPromotionNewProjectSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBuildPromotionBlueprintSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBuildPromotionOpenAssetSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBuildPromotionImportWorkflowSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEditorImportWorkflowDefinition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEditorImportExportTestDefinition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FImportFactorySettingValues();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FExternalToolDefinition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FOpenTestAsset();
	ENGINE_API class UClass* Z_Construct_UClass_UAutomationTestSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAutomationTestSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavAvoidanceData();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAvoidanceManager_GetAvoidanceVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAvoidanceManager_GetAvoidanceVelocityForComponent();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAvoidanceManager_GetAvoidanceVelocityIgnoringUID();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAvoidanceManager_GetNewAvoidanceUID();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAvoidanceManager_GetObjectCount();
	ENGINE_API class UFunction* Z_Construct_UFunction_UAvoidanceManager_RegisterMovementComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UAvoidanceManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAvoidanceManager();
	ENGINE_API class UFunction* Z_Construct_UFunction_UBlueprintAsyncActionBase_Activate();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintAsyncActionBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintAsyncActionBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimParentNodeAssetOverride();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimGroupInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimBlueprint_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimBlueprint();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelScriptBlueprint_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelScriptBlueprint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDataTableCategoryHandle();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDataTableRowHandle();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTableRowBase();
	ENGINE_API class UClass* Z_Construct_UClass_UDataTable_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDataTable();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEvaluateCurveTableResult();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDataTableFunctionLibrary_EvaluateCurveTableRow();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDataTableFunctionLibrary_GetDataTableRowFromName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UDataTableFunctionLibrary_GetDataTableRowNames();
	ENGINE_API class UClass* Z_Construct_UClass_UDataTableFunctionLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDataTableFunctionLibrary();
	ENGINE_API class UClass* Z_Construct_UClass_UDebugDrawService_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDebugDrawService();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EGrammaticalNumber();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EGrammaticalGender();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDialogueWaveParameter();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDialogueContext();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueTypes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueTypes();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESuggestProjVelocityTraceOption();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ActivateReverbEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ApplyDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ApplyPointDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ApplyRadialDamage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ApplyRadialDamageWithFalloff();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_AreAnyListenersWithinRange();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_BeginDeferredActorSpawnFromClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_BeginSpawningActorFromBlueprint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_BeginSpawningActorFromClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_BlueprintSuggestProjectileVelocity();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_BreakHitResult();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_CancelAsyncLoading();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ClearSoundMixModifiers();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_CreatePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_CreateSaveGameObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_CreateSaveGameObjectFromBlueprint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_DeactivateReverbEffect();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_DeleteGameInSlot();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_DeprojectScreenToWorld();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_DoesSaveGameExist();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_EnableLiveStreaming();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_FinishSpawningActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_FlushLevelStreaming();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetAccurateRealTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetActorArrayAverageLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetActorArrayBounds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetAllActorsOfClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetAllActorsWithInterface();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetAudioTimeSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetCurrentLevelName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetGameInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetGameMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetGameState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetGlobalTimeDilation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetIntOption();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetKeyValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetObjectClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetPlatformName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetPlayerCameraManager();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetPlayerCharacter();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetPlayerController();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetPlayerPawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetRealTimeSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetStreamingLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetSurfaceType();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetWorldDeltaSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GetWorldOriginLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_GrassOverlappingSphereCount();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_HasOption();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_IsGamePaused();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_LoadGameFromSlot();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_LoadStreamLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_OpenLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ParseOption();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PlayDialogue2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PlayDialogueAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PlaySound2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PlaySoundAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PlayWorldCameraShake();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PopSoundMixModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_ProjectWorldToScreen();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_PushSoundMixModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_RemovePlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SaveGameToSlot();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SetBaseSoundMix();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SetGamePaused();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SetGlobalTimeDilation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SetWorldOriginLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnDecalAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnDecalAttached();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnDialogue2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnDialogueAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnDialogueAttached();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnEmitterAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnEmitterAttached();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnSound2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnSoundAtLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_SpawnSoundAttached();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameplayStatics_UnloadStreamLevel();
	ENGINE_API class UClass* Z_Construct_UClass_UGameplayStatics_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UGameplayStatics();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EOrientPositionSelector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_EnableHMD();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_EnableLowPersistenceMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_GetOrientationAndPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_GetPositionalTrackingCameraParameters();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_GetScreenPercentage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_GetWorldToMetersScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_HasValidTrackingPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_IsHeadMountedDisplayEnabled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_IsInLowPersistenceMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_ResetOrientationAndPosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_SetClippingPlanes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UHeadMountedDisplayFunctionLibrary_SetWorldToMetersScale();
	ENGINE_API class UClass* Z_Construct_UClass_UHeadMountedDisplayFunctionLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UHeadMountedDisplayFunctionLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Add();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_AddUnique();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Append();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Clear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Contains();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Find();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Get();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Insert();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_LastIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Length();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Remove();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_RemoveItem();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Resize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Set();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_Array_Shuffle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_FilterArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetArrayLibrary_SetArrayPropertyByName();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetArrayLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetArrayLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_Conv_GuidToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_EqualEqual_GuidGuid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_Invalidate_Guid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_IsValid_Guid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_NewGuid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_NotEqual_GuidGuid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetGuidLibrary_Parse_StringToGuid();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetGuidLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetGuidLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_CalibrateTilt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_ControllerEvent_GetAnalogValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_ControllerEvent_GetEffectingButton();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_ControllerEvent_GetUserIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_EqualEqual_KeyKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_GetAnalogValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_GetKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_GetUserIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsAltDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsCommandDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsControlDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsLeftAltDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsLeftCommandDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsLeftControlDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsLeftShiftDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsRepeat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsRightAltDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsRightCommandDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsRightControlDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsRightShiftDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_InputEvent_IsShiftDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_GetDisplayName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_IsFloatAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_IsGamepadKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_IsKeyboardKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_IsModifierKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_IsMouseButton();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_Key_IsVectorAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetCursorDelta();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetEffectingButton();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetGestureDelta();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetLastScreenSpacePosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetPointerIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetScreenSpacePosition();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetTouchpadIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetUserIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_GetWheelDelta();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_IsMouseButtonDown();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetInputLibrary_PointerEvent_IsTouchEvent();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetInputLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetInputLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMaterialLibrary_CreateDynamicMaterialInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMaterialLibrary_GetScalarParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMaterialLibrary_GetVectorParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMaterialLibrary_SetScalarParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMaterialLibrary_SetVectorParameterValue();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetMaterialLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetMaterialLibrary();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEasingFunc();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Abs();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Abs_Int();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Acos();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_DateTimeTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_Vector2DFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_Vector2DVector2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_VectorFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_VectorInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Add_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_And_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Asin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Atan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Atan2();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BooleanAND();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BooleanNAND();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BooleanNOR();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BooleanOR();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BooleanXOR();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakRandomStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakRotIntoAxes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_BreakVector2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_CInterpTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Clamp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ClampAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ClampAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ClampVectorSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ClassIsChildOf();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ComposeRotators();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ComposeTransforms();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_BoolToByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_BoolToFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_BoolToInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_ByteToFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_ByteToInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_ColorToLinearColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_FloatToLinearColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_FloatToVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_IntToBool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_IntToByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_IntToFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_LinearColorToColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_LinearColorToVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_RotatorToVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_Vector2DToVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_VectorToLinearColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_VectorToRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_VectorToTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Conv_VectorToVector2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ConvertTransformToRelative();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Cos();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_CreateVectorFromYawPitch();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Cross_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_CrossProduct2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DateTimeFromIsoString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DateTimeFromString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DateTimeMaxValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DateTimeMinValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DaysInMonth();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DaysInYear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegAcos();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegAsin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegAtan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegAtan2();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegCos();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegreesToRadians();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegSin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DegTan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_Vector2DFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_VectorFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_VectorInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Divide_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Dot_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_DotProduct2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Ease();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_BoolBool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_ClassClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_NameName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_ObjectObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_RotatorRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_TransformTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_EqualEqual_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Exp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FCeil();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FClamp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FFloor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FindLookAtRotation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FInterpEaseInOut();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FInterpTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FInterpTo_Constant();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FixedTurn();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FMax();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FMin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FMod();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Fraction();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FromDays();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FromHours();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FromMilliseconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FromMinutes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FromSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_FTrunc();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetAxes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetDate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetDay();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetDayOfYear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetDays();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetDirectionVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetDuration();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetForwardVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetHour();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetHour12();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetHours();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMaxElement();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMillisecond();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMilliseconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMinElement();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMinute();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMinutes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetMonth();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetPI();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetRightVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetSecond();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetTimeOfDay();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetTotalDays();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetTotalHours();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetTotalMilliseconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetTotalMinutes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetTotalSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetUpVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetVectorArrayAverage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetYawPitchFromVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GetYear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Greater_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Greater_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Greater_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Greater_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Greater_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GreaterEqual_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GreaterEqual_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GreaterEqual_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GreaterEqual_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GreaterEqual_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GreaterGreater_VectorRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_GridSnap_Float();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_HSVToRGB();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_HSVToRGB_Vector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Hypotenuse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_InRange_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_InverseLerp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_InverseTransformDirection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_InverseTransformLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_InvertTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_IsAfternoon();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_IsLeapYear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_IsMorning();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Lerp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Less_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Less_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Less_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Less_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Less_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LessEqual_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LessEqual_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LessEqual_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LessEqual_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LessEqual_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LessLess_VectorRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LinearColorLerp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LinearColorLerpUsingHSV();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LinePlaneIntersection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_LinePlaneIntersection_OriginNormal();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Loge();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakePulsatingValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRandomStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotationFromAxes();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromX();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromXY();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromXZ();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromY();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromYX();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromYZ();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromZ();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromZX();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeRotFromZY();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MakeVector2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MapRangeClamped();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MapRangeUnclamped();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Max();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MaxOfByteArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MaxOfFloatArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MaxOfIntArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Min();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MinimumAreaRectangle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MinOfByteArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MinOfFloatArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MinOfIntArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MirrorVectorByNormal();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_IntFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_LinearColorFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_LinearColorLinearColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_RotatorFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_RotatorInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_TimespanFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_Vector2DFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_VectorFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_VectorInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Multiply_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MultiplyByPi();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_MultiplyMultiply_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NearlyEqual_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NearlyEqual_TransformTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NegateRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NegateVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Normal();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Normal2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NormalizeAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NormalizedDeltaRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NormalizeToRange();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Not_PreBool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_BoolBool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_ClassClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_NameName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_ObjectObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_RotatorRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_NotEqual_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Now();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Or_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Percent_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Percent_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Percent_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_PointsAreCoplanar();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ProjectPointOnToPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ProjectVectorOnToPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ProjectVectorOnToVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RadiansToDegrees();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomBool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomBoolFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomFloatFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomFloatInRange();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomFloatInRangeFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomInteger();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomIntegerFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomIntegerInRange();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomIntegerInRangeFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomPointInBoundingBox();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomRotatorFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomUnitVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomUnitVectorFromStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomUnitVectorInCone();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RandomUnitVectorInConeWithYawAndPitch();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_REase();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_ResetRandomStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RGBToHSV();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RGBToHSV_Vector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RInterpTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RInterpTo_Constant();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RLerp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RotateAngleAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_RotatorFromAxisAndAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Round();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SeedRandomStream();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectRotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SelectVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SetRandomStreamSeed();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SignOfFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_SignOfInteger();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Sin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Sqrt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Square();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_ByteByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_DateTimeDateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_DateTimeTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_FloatFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_IntInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_TimespanTimespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_Vector2DFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_Vector2DVector2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_VectorFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_VectorInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Subtract_VectorVector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Tan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TEase();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TimespanFromString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TimespanMaxValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TimespanMinValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TimespanRatio();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TimespanZeroValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TInterpTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TLerp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Today();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TransformDirection();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_TransformLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_UtcNow();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VEase();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Vector2DInterpTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Vector2DInterpTo_Constant();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VInterpTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VInterpTo_Constant();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VLerp();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VSize2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VSize2DSquared();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_VSizeSquared();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetMathLibrary_Xor_IntInt();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetMathLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetMathLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_BitIsMarked();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_ClearAllBits();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_ClearBit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_GetEnumeratorName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_GetEnumeratorUserFriendlyName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_GetFirstUnmarkedBit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_GetRandomUnmarkedBit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_GetUnmarkedBit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_GetValidIndex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_HasMarkedBit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_HasUnmarkedBit();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetNodeHelperLibrary_MarkBit();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetNodeHelperLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetNodeHelperLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Bool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Color();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Float();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Int();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Name();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Object();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Rotator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Vector();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_BuildString_Vector2d();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Concat_StrStr();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_BoolToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_ByteToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_ColorToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_FloatToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_IntToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_NameToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_ObjectToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_RotatorToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_StringToFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_StringToInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_StringToName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_TransformToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_Vector2dToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Conv_VectorToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_CullArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_EndsWith();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_EqualEqual_StriStri();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_EqualEqual_StrStr();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_FindSubstring();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_GetCharacterArrayFromString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_GetCharacterAsNumber();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_GetSubstring();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_IsNumeric();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_JoinStringArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Left();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_LeftChop();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_LeftPad();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Len();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_MatchesWildcard();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Mid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_NotEqual_StriStri();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_NotEqual_StrStr();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_ParseIntoArray();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Replace();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_ReplaceInline();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Reverse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Right();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_RightChop();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_RightPad();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Split();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_StartsWith();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_TimeSecondsToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_ToLower();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_ToUpper();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_Trim();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetStringLibrary_TrimTrailing();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetStringLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetStringLibrary();
	ENGINE_API class UClass* Z_Construct_UClass_UDeveloperSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDeveloperSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCustomProfile();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCustomChannelSetup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollisionResponseTemplate();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollisionProfileName();
	ENGINE_API class UClass* Z_Construct_UClass_UCollisionProfile_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCollisionProfile();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UKismetSystemLibrary_OnAssetClassLoaded__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_UKismetSystemLibrary_OnAssetLoaded__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EQuitPreference();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMoveComponentAction();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDrawDebugTrace();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGenericStruct();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_AddFloatHistorySample();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxOverlapActors_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxOverlapActors_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxOverlapComponents_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxOverlapComponents_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxTraceMulti();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxTraceMultiForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxTraceSingle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_BoxTraceSingleForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleOverlapActors_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleOverlapActors_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleOverlapComponents_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleOverlapComponents_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceMulti_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceMulti_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceMultiByObject_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceMultiForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceSingle_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceSingle_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceSingleByObject_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CapsuleTraceSingleForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CollectGarbage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ComponentOverlapActors_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ComponentOverlapActors_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ComponentOverlapComponents_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ComponentOverlapComponents_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ControlScreensaver();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_Conv_AssetClassToClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_Conv_AssetToObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_Conv_InterfaceToObject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_CreateCopyForUndoBuffer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_Delay();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DoesImplementInterface();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugArrow();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugBox();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugCamera();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugCapsule();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugCircle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugCone();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugConeInDegrees();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugCoordinateSystem();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugCylinder();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugFloatHistoryLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugFloatHistoryTransform();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugFrustum();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugLine();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugPlane();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugPoint();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugSphere();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_DrawDebugString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ExecuteConsoleCommand();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_FlushDebugStrings();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_FlushPersistentDebugLines();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ForceCloseAdBanner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetActorBounds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetActorListFromComponentList();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetAdIDCount();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetClassDisplayName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetComponentBounds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetDisplayName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetEngineVersion();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetGameName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetGameTimeInSeconds();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetLocalCurrencyCode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetLocalCurrencySymbol();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetObjectName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetPlatformUserName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetPreferredLanguages();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetRenderingDetailMode();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetRenderingMaterialQualityLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetSupportedFullscreenResolutions();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetUniqueDeviceId();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_GetVolumeButtonsHandledBySystem();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_HideAdBanner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsControllerAssignedToGamepad();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsDedicatedServer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsLoggedIn();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsPackagedForDistribution();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsServer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsValid();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_IsValidClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_ClearTimer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_ClearTimerDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_ClearTimerHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_GetTimerElapsedTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_GetTimerElapsedTimeDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_GetTimerElapsedTimeHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_GetTimerRemainingTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_GetTimerRemainingTimeDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_GetTimerRemainingTimeHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_InvalidateTimerHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsTimerActive();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsTimerActiveDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsTimerActiveHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsTimerPaused();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsTimerPausedDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsTimerPausedHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_IsValidTimerHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_PauseTimer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_PauseTimerDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_PauseTimerHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_SetTimer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_SetTimerDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_TimerExists();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_TimerExistsDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_TimerExistsHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_UnPauseTimer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_UnPauseTimerDelegate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_K2_UnPauseTimerHandle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LaunchURL();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceMulti_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceMulti_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceMultiByObject_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceMultiForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceSingle_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceSingle_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceSingleByObject_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LineTraceSingleForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LoadAsset();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_LoadAssetClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralBool();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralByte();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralFloat();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralInt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MakeLiteralText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_MoveComponentTo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_PrintString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_PrintText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_PrintWarning();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_QuitGame();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_RegisterForRemoteNotifications();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ResetGamepadAssignments();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ResetGamepadAssignmentToController();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_RetriggerableDelay();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetAssetClassPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetAssetPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetBoolPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetBytePropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetClassPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetCollisionProfileNameProperty();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetFloatPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetIntPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetLinearColorPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetNamePropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetObjectPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetRotatorPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetStringPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetStructurePropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetSupressViewportTransitionMessage();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetTextPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetTransformPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetVectorPropertyByName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetVolumeButtonsHandledBySystem();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SetWindowTitle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ShowAdBanner();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ShowPlatformSpecificAchievementsScreen();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereOverlapActors_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereOverlapActors_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereOverlapComponents_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereOverlapComponents_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceMulti_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceMulti_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceMultiByObject_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceMultiForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceSingle_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceSingle_NEW();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceSingleByObject_DEPRECATED();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_SphereTraceSingleForObjects();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetSystemLibrary_StackTrace();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetSystemLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetSystemLibrary();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERoundingMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFormatTextArgument();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsCurrency_Float();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsCurrency_Integer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsDate_DateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsDateTime_DateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsPercent_Float();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsTime_DateTime();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_AsTimespan_Timespan();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_BoolToText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_ByteToText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_FloatToText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_IntToText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_NameToText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_StringToText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Conv_TextToString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_EqualEqual_IgnoreCase_TextText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_EqualEqual_TextText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_FindTextInLocalizationTable();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_Format();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_GetEmptyText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_NotEqual_IgnoreCase_TextText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_NotEqual_TextText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_TextIsCultureInvariant();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_TextIsEmpty();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_TextIsTransient();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_TextTrimPreceding();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_TextTrimPrecedingAndTrailing();
	ENGINE_API class UFunction* Z_Construct_UFunction_UKismetTextLibrary_TextTrimTrailing();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetTextLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UKismetTextLibrary();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVisualLoggerKismetLibrary_LogBox();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVisualLoggerKismetLibrary_LogLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVisualLoggerKismetLibrary_LogText();
	ENGINE_API class UClass* Z_Construct_UClass_UVisualLoggerKismetLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVisualLoggerKismetLibrary();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEventGraphFastCallPair();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintDebugData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPointerToUberGraphFrame();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDebuggingInfoForSingleFunction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNodeToCodeAssociation();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintGeneratedClass_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintGeneratedClass();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimBlueprintDebugData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationFrameSnapshot();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStateMachineDebugData();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimBlueprintGeneratedClass_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimBlueprintGeneratedClass();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKShapeElem();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKConvexElem();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKBoxElem();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKSphereElem();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKSphylElem();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKAggregateGeom();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBodyCollisionResponse();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPhysicsType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionTraceFlag();
	ENGINE_API class UClass* Z_Construct_UClass_UBodySetup_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBodySetup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAggregateGeometry2D();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoxElement2D();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCircleElement2D();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FConvexElement2D();
	ENGINE_API class UClass* Z_Construct_UClass_UBodySetup2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBodySetup2D();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputBlendPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBranchFilter();
	ENGINE_API class UClass* Z_Construct_UClass_UBoneMaskFilter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBoneMaskFilter();
	ENGINE_API class UClass* Z_Construct_UClass_UBookMark_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBookMark();
	ENGINE_API class UClass* Z_Construct_UClass_UBookMark2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBookMark2D();
	ENGINE_API class UClass* Z_Construct_UClass_UBreakpoint_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBreakpoint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBuilderPoly();
	ENGINE_API class UClass* Z_Construct_UClass_UBrushBuilder_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBrushBuilder();
	ENGINE_API class UClass* Z_Construct_UClass_UButtonStyleAsset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UButtonStyleAsset();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraAnim_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraAnim();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraAnimInst_SetDuration();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraAnimInst_SetScale();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraAnimInst_Stop();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraAnimInst_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraAnimInst();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraModifier_BlueprintModifyCamera();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraModifier_BlueprintModifyPostProcess();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraModifier_DisableModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraModifier_EnableModifier();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraModifier_GetViewTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCameraModifier_IsDisabled();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraModifier_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraModifier();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraModifier_CameraShake_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraModifier_CameraShake();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FWrappedStringElement();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTextSizingParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCanvasIcon();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_Deproject();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawBorder();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawBox();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawLine();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawMaterial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawMaterialTriangle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawPolygon();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawText();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawTexture();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_DrawTriangle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_Project();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_StrLen();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvas_K2_TextSize();
	ENGINE_API class UClass* Z_Construct_UClass_UCanvas_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCanvas();
	ENGINE_API class UClass* Z_Construct_UClass_UChannel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UChannel();
	ENGINE_API class UClass* Z_Construct_UClass_UActorChannel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UActorChannel();
	ENGINE_API class UClass* Z_Construct_UClass_UControlChannel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UControlChannel();
	ENGINE_API class UClass* Z_Construct_UClass_UVoiceChannel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVoiceChannel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_BugIt();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_BugItGo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_BugItStringCreator();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ChangeSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DamageTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweep();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweepCapture();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweepChannel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweepClear();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweepComplex();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweepPawn();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DebugCapsuleSweepSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DestroyAll();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DestroyAllPawnsExceptTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DestroyPawns();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DestroyTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DumpOnlineSessionState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DumpPartyState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_DumpVoiceMutingState();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_FlushLog();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_Fly();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_FontAtlasVisualizer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_FreezeFrame();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_Ghost();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_God();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_InvertMouse();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_LogLoc();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_OnlyLoadLevel();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_PlayersOnly();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_RebuildNavigation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ServerToggleAILogging();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_SetMouseSensitivityToDefault();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_SetNavDrawDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_SetWorldOrigin();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_Slomo();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_StreamLevelIn();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_StreamLevelOut();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_Summon();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_Teleport();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_TestCollisionDistance();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_TextureAtlasVisualizer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ToggleAILogging();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ToggleDebugCamera();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ViewActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ViewClass();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ViewPlayer();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_ViewSelf();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_Walk();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCheatManager_WidgetReflector();
	ENGINE_API class UClass* Z_Construct_UClass_UCheatManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCheatManager();
	ENGINE_API class UClass* Z_Construct_UClass_UCheckBoxStyleAsset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCheckBoxStyleAsset();
	ENGINE_API class UClass* Z_Construct_UClass_UCommandlet_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCommandlet();
	ENGINE_API class UClass* Z_Construct_UClass_UPluginCommandlet_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPluginCommandlet();
	ENGINE_API class UClass* Z_Construct_UClass_USmokeTestCommandlet_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USmokeTestCommandlet();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAutoCompleteNode();
	ENGINE_API class UClass* Z_Construct_UClass_UConsole_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UConsole();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRuntimeCurveLinearColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCurveLinearColor_GetLinearColorValue();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveLinearColor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveLinearColor();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCurveVector_GetVectorValue();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveVector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveVector();
	ENGINE_API class UClass* Z_Construct_UClass_UDEPRECATED_CurveEdPresetCurve_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDEPRECATED_CurveEdPresetCurve();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCurveTableRowHandle();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveTable_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCurveTable();
	ENGINE_API class UClass* Z_Construct_UClass_UDataAsset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDataAsset();
	ENGINE_API class UClass* Z_Construct_UClass_UTireType_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTireType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleChunkParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFractureMaterial();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleFractureSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleFractureSettings();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimationSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimationSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAudioQualitySettings();
	ENGINE_API class UClass* Z_Construct_UClass_UAudioSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UAudioSettings();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EUIScalingRule();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERenderFocusRule();
	ENGINE_API class UClass* Z_Construct_UClass_UUserInterfaceSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UUserInterfaceSettings();
	ENGINE_API class UClass* Z_Construct_UClass_UStreamingSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStreamingSettings();
	ENGINE_API class UClass* Z_Construct_UClass_UGarbageCollectionSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UGarbageCollectionSettings();
	ENGINE_API class UClass* Z_Construct_UClass_UNetworkSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNetworkSettings();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESettingsLockedAxis();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESettingsDOF();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EFrictionCombineMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPhysicalSurfaceName();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsSettings();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAntiAliasingMethodUI();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEarlyZPass();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECustomDepthStencil();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECompositingSampleCount();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EClearSceneOptions();
	ENGINE_API class UClass* Z_Construct_UClass_URendererSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URendererSettings();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETextureSamplerFilter();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETexturePowerOfTwoSetting();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_TextureMipGenSettings();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_TextureGroup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTextureLODGroup();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureLODSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureLODSettings();
	ENGINE_API class UClass* Z_Construct_UClass_UDeviceProfile_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDeviceProfile();
	ENGINE_API class UClass* Z_Construct_UClass_UDeviceProfileManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDeviceProfileManager();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueVoice_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueVoice();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDialogueContextMapping();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueWave_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueWave();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_DistributionParamMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRawDistribution();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDistributionLookupTable();
	ENGINE_API class UClass* Z_Construct_UClass_UDistribution_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistribution();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRawDistributionFloat();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatDistribution();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloat_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloat();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatConstant_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatConstant();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatParameterBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatParameterBase();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatParticleParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatParticleParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatConstantCurve_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatConstantCurve();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatUniform_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatUniform();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatUniformCurve_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionFloatUniformCurve();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDistributionVectorMirrorFlags();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDistributionVectorLockFlags();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRawDistributionVector();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector4Distribution();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVectorDistribution();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVector();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorConstant_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorConstant();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorParameterBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorParameterBase();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorParticleParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorParticleParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorConstantCurve_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorConstantCurve();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorUniform_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorUniform();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorUniformCurve_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDistributionVectorUniformCurve();
	ENGINE_API class UClass* Z_Construct_UClass_UDPICustomScalingRule_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDPICustomScalingRule();
	ENGINE_API class UClass* Z_Construct_UClass_UDynamicBlueprintBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDynamicBlueprintBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintComponentDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UComponentDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UComponentDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintInputDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintInputActionDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputActionDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputActionDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintInputAxisDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputAxisDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputAxisDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintInputAxisKeyDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputAxisKeyDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputAxisKeyDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputVectorAxisDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputVectorAxisDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintInputKeyDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputKeyDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputKeyDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBlueprintInputTouchDelegateBinding();
	ENGINE_API class UClass* Z_Construct_UClass_UInputTouchDelegateBinding_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputTouchDelegateBinding();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGraphReference();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraph_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraph();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphNode_Documentation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphNode_Documentation();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECanCreateConnectionResponse();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EGraphType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEdGraphSchemaAction_NewNode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEdGraphSchemaAction();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphSchema_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEdGraphSchema();
	ENGINE_API class UClass* Z_Construct_UClass_UImportantToggleSettingInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UImportantToggleSettingInterface();
	ENGINE_API class UClass* Z_Construct_UClass_UEndUserSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEndUserSettings();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EConsoleType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETransitionType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EFullyLoadPackageType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPluginRedirect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStructRedirect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FClassRedirect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGameNameRedirect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FScreenMessageString();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDropNoteInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStatColorMapping();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStatColorMapEntry();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FWorldContext();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNamedNetDriver();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNetDriverDefinition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLevelStreamingStatus();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFullyLoadedPackagesInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UEngine_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEngine();
	ENGINE_API class UClass* Z_Construct_UClass_UGameEngine_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UGameEngine();
	ENGINE_API class UClass* Z_Construct_UClass_UExporter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UExporter();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EFontImportCharacterSet();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFontImportOptionsData();
	ENGINE_API class UClass* Z_Construct_UClass_UFontImportOptions_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UFontImportOptions();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EFontCacheType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFontCharacter();
	ENGINE_API class UClass* Z_Construct_UClass_UFont_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UFont();
	ENGINE_API class UClass* Z_Construct_UClass_UGameUserSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UGameUserSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FActiveHapticFeedbackEffect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHapticFeedbackDetails();
	ENGINE_API class UClass* Z_Construct_UClass_UHapticFeedbackEffect_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UHapticFeedbackEffect();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FComponentOverrideRecord();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FComponentKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInheritableComponentHandler_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInheritableComponentHandler();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputAxisKeyMapping();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputActionKeyMapping();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputAxisConfigEntry();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputAxisProperties();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FKeyBind();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlayerInput_ClearSmoothing();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlayerInput_InvertAxis();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlayerInput_InvertAxisKey();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlayerInput_SetBind();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlayerInput_SetMouseSensitivity();
	ENGINE_API class UClass* Z_Construct_UClass_UPlayerInput_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPlayerInput();
	ENGINE_API class UClass* Z_Construct_UClass_UInputSettings_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInputSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCurveEdTab();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCurveEdEntry();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpCurveEdSetup_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpCurveEdSetup();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpData_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpData();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpFilter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpFilter();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpFilter_Classes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpFilter_Classes();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpFilter_Custom_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpFilter_Custom();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpEdSelKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroup_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCameraPreviewInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupCamera_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupCamera();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupDirector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupDirector();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupInst_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupInst();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupInstCamera_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupInstCamera();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupInstDirector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpGroupInstDirector();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETrackActiveCondition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSubTrackGroup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSupportedSubTrackInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrack_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBoolTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackBoolProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackBoolProp();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDirectorTrackCut();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackDirector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackDirector();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEventTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackEvent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackEvent();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimControlTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackAnimControl_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackAnimControl();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFade();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatAnimBPParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatAnimBPParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatMaterialParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatMaterialParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatParticleParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatParticleParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackFloatProp();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EInterpTrackMoveRotMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpLookupTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpLookupPoint();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackMove_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackMove();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EInterpMoveAxis();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackMoveAxis_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackMoveAxis();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackSlomo_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackSlomo();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackLinearColorBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackLinearColorBase();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackLinearColorProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackLinearColorProp();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleReplayTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackParticleReplay_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackParticleReplay();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETrackToggleAction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FToggleTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackToggle_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackToggle();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVectorBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVectorBase();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackAudioMaster_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackAudioMaster();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackColorProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackColorProp();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackColorScale_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackColorScale();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSoundTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackSound_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackSound();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVectorMaterialParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVectorMaterialParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVectorProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVectorProp();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVisibilityTrackCondition();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVisibilityTrackAction();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVisibilityTrackKey();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVisibility_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackVisibility();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInst_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInst();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstAnimControl_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstAnimControl();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstAudioMaster_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstAudioMaster();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstColorScale_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstColorScale();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstDirector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstDirector();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstEvent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstEvent();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFade();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatAnimBPParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatAnimBPParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatMaterialParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatMaterialParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatParticleParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatParticleParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstMove_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstMove();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstParticleReplay_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstParticleReplay();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstProperty_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstProperty();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstBoolProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstBoolProp();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstColorProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstColorProp();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstFloatProp();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstLinearColorProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstLinearColorProp();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstVectorProp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstVectorProp();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstSlomo_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstSlomo();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstSound_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstSound();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstToggle_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstToggle();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstVectorMaterialParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstVectorMaterialParam();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstVisibility_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInterpTrackInstVisibility();
	ENGINE_API class UClass* Z_Construct_UClass_UIntSerialization_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UIntSerialization();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLayerActorStats();
	ENGINE_API class UClass* Z_Construct_UClass_ULayer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULayer();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_LevelStreamingVisibilityStatus__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_LevelStreamingLoadedStatus__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULevelStreaming_CreateInstance();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULevelStreaming_GetLevelScriptActor();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULevelStreaming_IsLevelLoaded();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULevelStreaming_IsLevelVisible();
	ENGINE_API class UFunction* Z_Construct_UFunction_ULevelStreaming_IsStreamingStatePending();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreaming_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreaming();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreamingAlwaysLoaded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreamingAlwaysLoaded();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreamingKismet_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreamingKismet();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreamingPersistent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULevelStreamingPersistent();
	ENGINE_API class UClass* Z_Construct_UClass_ULightmappedSurfaceCollection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULightmappedSurfaceCollection();
	ENGINE_API class UClass* Z_Construct_UClass_ULightmassPrimitiveSettingsObject_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULightmassPrimitiveSettingsObject();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FClientReceiveData();
	ENGINE_API class UClass* Z_Construct_UClass_ULocalMessage_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULocalMessage();
	ENGINE_API class UClass* Z_Construct_UClass_UEngineMessage_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UEngineMessage();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FExpressionOutput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialAttributesInput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FExpressionInput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpression_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpression();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAbs_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAbs();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionActorPositionWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionActorPositionWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAdd_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAdd();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAppendVector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAppendVector();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAtmosphericFogColor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAtmosphericFogColor();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionBlackBody_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionBlackBody();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionBreakMaterialAttributes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionBreakMaterialAttributes();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionBumpOffset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionBumpOffset();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCameraPositionWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCameraPositionWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCameraVectorWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCameraVectorWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCeil_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCeil();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EClampMode();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionClamp_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionClamp();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCollectionParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCollectionParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionComment_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionComment();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionComponentMask_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionComponentMask();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant2Vector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant2Vector();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant3Vector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant3Vector();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant4Vector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstant4Vector();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstantBiasScale_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionConstantBiasScale();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCosine_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCosine();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCrossProduct_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCrossProduct();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECustomMaterialOutputType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCustomInput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCustom_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCustom();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCustomOutput_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionCustomOutput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDDX_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDDX();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDDY_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDDY();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDecalMipmapLevel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDecalMipmapLevel();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDepthFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDepthFade();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDepthOfFieldFunctionValue();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDepthOfFieldFunction_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDepthOfFieldFunction();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDeriveNormalZ_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDeriveNormalZ();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDesaturation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDesaturation();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistance();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistanceCullFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistanceCullFade();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistanceFieldGradient_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistanceFieldGradient();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistanceToNearestSurface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDistanceToNearestSurface();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDivide_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDivide();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDotProduct_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDotProduct();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDynamicParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionDynamicParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionEyeAdaptation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionEyeAdaptation();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFeatureLevelSwitch_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFeatureLevelSwitch();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFloor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFloor();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFmod_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFmod();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFontSample_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFontSample();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFontSampleParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFontSampleParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFrac_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFrac();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFresnel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFresnel();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EFunctionInputType();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFunctionInput_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFunctionInput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFunctionOutput_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionFunctionOutput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionGIReplace_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionGIReplace();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionIf_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionIf();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLightmapUVs_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLightmapUVs();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLightmassReplace_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLightmassReplace();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLightVector_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLightVector();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLinearInterpolate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLinearInterpolate();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLogarithm2_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionLogarithm2();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMakeMaterialAttributes_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMakeMaterialAttributes();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFunctionExpressionOutput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFunctionExpressionInput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMaterialFunctionCall_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMaterialFunctionCall();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMax_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMax();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMin_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMin();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMultiply_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionMultiply();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENoiseFunction();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionNoise_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionNoise();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionNormalize_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionNormalize();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectBounds_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectBounds();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectOrientation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectOrientation();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectPositionWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectPositionWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectRadius_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionObjectRadius();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionOneMinus_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionOneMinus();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPanner_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPanner();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionScalarParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionScalarParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticBoolParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticBoolParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticSwitchParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticSwitchParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticComponentMaskParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticComponentMaskParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionVectorParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionVectorParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleColor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleColor();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleDirection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleDirection();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleMacroUV_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleMacroUV();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleMotionBlurFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleMotionBlurFade();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticlePositionWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticlePositionWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleRadius_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleRadius();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleRelativeTime_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleRelativeTime();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleSize_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleSize();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleSpeed_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleSpeed();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPerInstanceFadeAmount_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPerInstanceFadeAmount();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPerInstanceRandom_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPerInstanceRandom();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPixelDepth_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPixelDepth();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPixelNormalWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPixelNormalWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPower_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPower();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPrecomputedAOMask_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionPrecomputedAOMask();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionQualitySwitch_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionQualitySwitch();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionReflectionVectorWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionReflectionVectorWS();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionRotateAboutAxis_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionRotateAboutAxis();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionRotator_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionRotator();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialSceneAttributeInputMode();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneColor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneColor();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneDepth_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneDepth();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneTexelSize_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneTexelSize();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESceneTextureId();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneTexture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSceneTexture();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionScreenPosition_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionScreenPosition();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSine_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSine();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESpeedTreeLODType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESpeedTreeWindType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESpeedTreeGeometryType();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSpeedTree_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSpeedTree();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSphereMask_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSphereMask();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSphericalParticleOpacity_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSphericalParticleOpacity();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSquareRoot_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSquareRoot();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticBool_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticBool();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticSwitch_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionStaticSwitch();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSubtract_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionSubtract();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureBase();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureObject_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureObject();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETextureMipValueMode();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSample_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSample();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleSubUV_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionParticleSubUV();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureObjectParameter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureObjectParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameter2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameter2D();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETextureColorChannel();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAntialiasedTextureMask_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionAntialiasedTextureMask();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameterSubUV_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameterSubUV();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameterCube_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureSampleParameterCube();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureCoordinate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTextureCoordinate();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTime_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTime();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialVectorCoordTransform();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialVectorCoordTransformSource();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTransform_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTransform();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialPositionTransformSource();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTransformPosition_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTransformPosition();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTwoSidedSign_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionTwoSidedSign();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionVertexColor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionVertexColor();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionVertexNormalWS_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionVertexNormalWS();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialExposedViewProperty();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionViewProperty_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionViewProperty();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionViewSize_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionViewSize();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EWorldPositionIncludedOffsets();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionWorldPosition_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialExpressionWorldPosition();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialFunction_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialFunction();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialDecalResponse();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaterialDomain();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDecalBlendMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialParameterCollectionInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialFunctionInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector2MaterialInput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVectorMaterialInput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FScalarMaterialInput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FColorMaterialInput();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialInput();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterial_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterial();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMaterialInstanceBasePropertyOverrides();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVectorParameterValue();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTextureParameterValue();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FScalarParameterValue();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFontParameterValue();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstance();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstanceConstant_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstanceConstant();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_CopyParameterOverrides();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_K2_CopyMaterialInstanceParameters();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_K2_GetScalarParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_K2_GetTextureParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_K2_GetVectorParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_SetScalarParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_SetTextureParameterValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UMaterialInstanceDynamic_SetVectorParameterValue();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstanceDynamic();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollectionVectorParameter();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollectionScalarParameter();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FCollectionParameterBase();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialParameterCollection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialParameterCollection();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialParameterCollectionInstance_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialParameterCollectionInstance();
	ENGINE_API class UClass* Z_Construct_UClass_UMatineeInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMatineeInterface();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_Default_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_Default();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_LowHeight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_LowHeight();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_Null_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_Null();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_Obstacle_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavArea_Obstacle();
	ENGINE_API class UClass* Z_Construct_UClass_UNavAreaMeta_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavAreaMeta();
	ENGINE_API class UClass* Z_Construct_UClass_UNavAreaMeta_SwitchByAgent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavAreaMeta_SwitchByAgent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavCollisionBox();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNavCollisionCylinder();
	ENGINE_API class UClass* Z_Construct_UClass_UNavCollision_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavCollision();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationDataChunk_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationDataChunk();
	ENGINE_API class UClass* Z_Construct_UClass_URecastNavMeshDataChunk_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URecastNavMeshDataChunk();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnNavigationPathUpdated__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_EnableDebugDrawing();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_EnableRecalculationOnInvalidation();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_GetDebugString();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_GetPathCost();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_GetPathLength();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_IsPartial();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_IsStringPulled();
	ENGINE_API class UFunction* Z_Construct_UFunction_UNavigationPath_IsValid();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationPath_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationPath();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationPathGenerator_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationPathGenerator();
	ENGINE_API class UClass* Z_Construct_UClass_URecastFilter_UseDefaultArea_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URecastFilter_UseDefaultArea();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkTrivial_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavLinkTrivial();
	ENGINE_API class UClass* Z_Construct_UClass_UNavNodeInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNavNodeInterface();
	ENGINE_API class UClass* Z_Construct_UClass_UNetDriver_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNetDriver();
	ENGINE_API class UClass* Z_Construct_UClass_UDemoNetDriver_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDemoNetDriver();
	ENGINE_API class UClass* Z_Construct_UClass_UNiagaraEffectRendererProperties_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNiagaraEffectRendererProperties();
	ENGINE_API class UClass* Z_Construct_UClass_UNiagaraRibbonRendererProperties_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNiagaraRibbonRendererProperties();
	ENGINE_API class UClass* Z_Construct_UClass_UNiagaraSpriteRendererProperties_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNiagaraSpriteRendererProperties();
	ENGINE_API class UClass* Z_Construct_UClass_UObjectLibrary_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UObjectLibrary();
	ENGINE_API class UClass* Z_Construct_UClass_UObjectReferencer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UObjectReferencer();
	ENGINE_API class UClass* Z_Construct_UClass_UOnlineSession_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UOnlineSession();
	ENGINE_API class UClass* Z_Construct_UClass_UPackageMapClient_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPackageMapClient();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEmitterRenderMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleSubUVInterpMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleBurstMethod();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleBurst();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleEmitter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleEmitter();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleScreenAlignment();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSpriteEmitter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSpriteEmitter();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleLODLevel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleLODLevel();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleSourceSelectionMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EModuleType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleRandomSeedInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleCurvePair();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModule_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModule();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAcceleration_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAcceleration();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationConstant_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationConstant();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationDrag_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationDrag();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationDragScaleOverLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationDragScaleOverLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationOverLifetime_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAccelerationOverLifetime();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorLine_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorLine();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAttractorParticleSelectionMethod();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorParticle_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorParticle();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorPoint_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorPoint();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorPointGravity_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleAttractorPointGravity();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_Beam2SourceTargetTangentMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_Beam2SourceTargetMethod();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_BeamModifierType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBeamModifierOptions();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamModifier_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamModifier();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamNoise_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamNoise();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamSource_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamSource();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamTarget_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleBeamTarget();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCameraBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCameraBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleCameraOffsetUpdateMethod();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCameraOffset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCameraOffset();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleCollisionComplete();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCollisionBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCollisionBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCollision_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCollision();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleCollisionResponse();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCollisionGPU_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleCollisionGPU();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColorBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColorBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColor();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColor_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColor_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColorOverLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColorOverLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColorScaleOverLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleColorScaleOverLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleEvent_GenerateInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventGenerator_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventGenerator();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventReceiverBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventReceiverBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventReceiverKillParticles_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventReceiverKillParticles();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventReceiverSpawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventReceiverSpawn();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleKillBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleKillBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleKillBox_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleKillBox();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleKillHeight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleKillHeight();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLifetimeBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLifetimeBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLifetime_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLifetime();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLifetime_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLifetime_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLightBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLightBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLight_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLight();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLight_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLight_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocation();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocation_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocation_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationWorldOffset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationWorldOffset();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationWorldOffset_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationWorldOffset_Seeded();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELocationBoneSocketSelectionMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELocationBoneSocketSource();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FLocationBoneSocketInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationBoneSocket_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationBoneSocket();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationDirect_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationDirect();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELocationEmitterSelectionMethod();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationEmitter_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationEmitter();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationEmitterDirect_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationEmitterDirect();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_CylinderHeightAxis();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveCylinder_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveCylinder();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveCylinder_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveCylinder_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveSphere_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveSphere();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveSphere_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveSphere_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveTriangle_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationPrimitiveTriangle();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELocationSkelVertSurfaceSource();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationSkelVertSurface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleLocationSkelVertSurface();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModulePivotOffset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModulePivotOffset();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSourceMovement_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSourceMovement();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMaterialBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMaterialBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshMaterial_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshMaterial();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrbitBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrbitBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EOrbitChainMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FOrbitOptions();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrbit_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrbit();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrientationBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrientationBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleAxisLock();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrientationAxisLock_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleOrientationAxisLock();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleParameterBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleParameterBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEmitterDynamicParameterValue();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FEmitterDynamicParameter();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleParameterDynamic_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleParameterDynamic();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleParameterDynamic_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleParameterDynamic_Seeded();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEmitterNormalsMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleSortMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EParticleUVFlipMode();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRequired_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRequired();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotation();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotation_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotation_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotation();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotation_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotation_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationOverLifetime_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationOverLifetime();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRateBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRateBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRate();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRate();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRate_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRate_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRateMultiplyLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRateMultiplyLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRateOverLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleMeshRotationRateOverLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRate_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRate_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRateMultiplyLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleRotationRateMultiplyLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSize_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSize();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSize_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSize_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeMultiplyLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeMultiplyLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeScale_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeScale();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeScaleBySpeed_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSizeScaleBySpeed();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSpawnBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSpawnBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSpawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSpawn();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSpawnPerUnit_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSpawnPerUnit();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSubUVBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSubUVBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSubUV_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSubUV();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSubUVMovie_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleSubUVMovie();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTrailBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTrailBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETrail2SourceMethod();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTrailSource_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTrailSource();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataAnimTrail_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataAnimTrail();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBeamTaperMethod();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EBeam2Method();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBeamTargetData();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataBeam2_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataBeam2();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGPUSpriteResourceData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGPUSpriteEmitterInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FGPUSpriteLocalVectorFieldInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataGpu_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataGpu();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMeshCameraFacingOptions();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMeshCameraFacingUpAxis();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMeshScreenAlignment();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataMesh_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataMesh();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETrailsRenderAxisOption();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataRibbon_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleTypeDataRibbon();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldGlobal_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldGlobal();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldLocal_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldLocal();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldRotation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldRotation();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldRotationRate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldRotationRate();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldScale_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldScale();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldScaleOverLife_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVectorFieldScaleOverLife();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityBase();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocity_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocity();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocity_Seeded_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocity_Seeded();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityCone_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityCone();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityInheritParent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityInheritParent();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityOverLifetime_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleVelocityOverLifetime();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventSendToGame_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleModuleEventSendToGame();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleSystemReplayFrame();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FParticleEmitterReplayFrame();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSystemReplay_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UParticleSystemReplay();
	ENGINE_API class UClass* Z_Construct_UClass_UDemoPendingNetGame_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDemoPendingNetGame();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTireFrictionScalePair();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicalMaterial_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicalMaterial();
	ENGINE_API class UClass* Z_Construct_UClass_UDEPRECATED_PhysicalMaterialPropertyBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDEPRECATED_PhysicalMaterialPropertyBase();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsAsset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsAsset();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsCollisionHandler_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsCollisionHandler();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsConstraintTemplate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsConstraintTemplate();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsSerializer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPhysicsSerializer();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_PlatformInterfaceDelegate__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPlatformInterfaceDataType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDelegateArray();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPlatformInterfaceDelegateResult();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPlatformInterfaceData();
	ENGINE_API class UClass* Z_Construct_UClass_UPlatformInterfaceBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPlatformInterfaceBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECloudStorageDelegate();
	ENGINE_API class UClass* Z_Construct_UClass_UCloudStorageBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCloudStorageBase();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnUserClosedAdvertisement__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnUserClickedBanner__DelegateSignature();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAdManagerDelegate();
	ENGINE_API class UClass* Z_Construct_UClass_UInGameAdManager_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UInGameAdManager();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMicroTransactionResult();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMicroTransactionDelegate();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPurchaseInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UMicroTransactionBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMicroTransactionBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETwitterIntegrationDelegate();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETwitterRequestMethod();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_AuthorizeAccounts();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_CanShowTweetUI();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_GetAccountName();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_GetNumAccounts();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_Init();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_ShowTweetUI();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTwitterIntegrationBase_TwitterRequest();
	ENGINE_API class UClass* Z_Construct_UClass_UTwitterIntegrationBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTwitterIntegrationBase();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlatformInterfaceWebResponse_GetHeader();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlatformInterfaceWebResponse_GetHeaderValue();
	ENGINE_API class UFunction* Z_Construct_UFunction_UPlatformInterfaceWebResponse_GetNumHeaders();
	ENGINE_API class UClass* Z_Construct_UClass_UPlatformInterfaceWebResponse_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPlatformInterfaceWebResponse();
	ENGINE_API class UClass* Z_Construct_UClass_UPlayer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPlayer();
	ENGINE_API class UClass* Z_Construct_UClass_ULocalPlayer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULocalPlayer();
	ENGINE_API class UClass* Z_Construct_UClass_UNetConnection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UNetConnection();
	ENGINE_API class UClass* Z_Construct_UClass_UChildConnection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UChildConnection();
	ENGINE_API class UClass* Z_Construct_UClass_UDemoNetConnection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDemoNetConnection();
	ENGINE_API class UClass* Z_Construct_UClass_UPolys_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPolys();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EReporterLineStyle();
	ENGINE_API class UClass* Z_Construct_UClass_UReporterBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UReporterBase();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ELegendPosition();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EGraphDataStyle();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EGraphAxisStyle();
	ENGINE_API class UClass* Z_Construct_UClass_UReporterGraph_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UReporterGraph();
	ENGINE_API class UClass* Z_Construct_UClass_UReverbEffect_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UReverbEffect();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EConstraintTransform();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EControlConstraint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTransformBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTransformBaseConstraint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRigTransformConstraint();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FNode();
	ENGINE_API class UClass* Z_Construct_UClass_URig_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_URig();
	ENGINE_API class UClass* Z_Construct_UClass_USaveGame_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USaveGame();
	ENGINE_API class UClass* Z_Construct_UClass_UScriptViewportClient_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UScriptViewportClient();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDebugDisplayProperty();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameViewportClient_SetConsoleTarget();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameViewportClient_ShowTitleSafeArea();
	ENGINE_API class UFunction* Z_Construct_UFunction_UGameViewportClient_SSSwapControllers();
	ENGINE_API class UClass* Z_Construct_UClass_UGameViewportClient_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UGameViewportClient();
	ENGINE_API class UClass* Z_Construct_UClass_USimpleConstructionScript_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USimpleConstructionScript();
	ENGINE_API class UClass* Z_Construct_UClass_USCS_Node_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USCS_Node();
	ENGINE_API class UClass* Z_Construct_UClass_USelection_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USelection();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EImpactDamageOverride();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleSpecialHierarchyDepths();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleAdvancedParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleDebrisParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleDamageParameters();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleParametersFlag();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDestructibleDepthParameters();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleMesh_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleMesh();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshSocket_GetSocketLocation();
	ENGINE_API class UFunction* Z_Construct_UFunction_USkeletalMeshSocket_InitializeSocketFromLocation();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMeshSocket_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMeshSocket();
	ENGINE_API class UClass* Z_Construct_UClass_USlateBrushAsset_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USlateBrushAsset();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EMaxConcurrentResolutionRule();
	ENGINE_API class UClass* Z_Construct_UClass_USoundBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundBase();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueSoundWaveProxy_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDialogueSoundWaveProxy();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSoundNodeEditorData();
	ENGINE_API class UClass* Z_Construct_UClass_USoundCue_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundCue();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ESoundGroup();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSoundGroup();
	ENGINE_API class UClass* Z_Construct_UClass_USoundGroups_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundGroups();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDecompressionType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStreamedAudioPlatformData();
	ENGINE_API class UClass* Z_Construct_UClass_USoundWave_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundWave();
	ENGINE_API class UClass* Z_Construct_UClass_USoundWaveProcedural_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundWaveProcedural();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EAudioOutputTarget();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPassiveSoundMixModifier();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSoundClassProperties();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSoundClassEditorData();
	ENGINE_API class UClass* Z_Construct_UClass_USoundClass_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundClass();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSoundClassAdjuster();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAudioEQEffect();
	ENGINE_API class UClass* Z_Construct_UClass_USoundMix_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundMix();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNode_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNode();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeAssetReferencer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeAssetReferencer();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeWavePlayer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeWavePlayer();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeAttenuation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeAttenuation();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeBranch_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeBranch();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeConcatenator_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeConcatenator();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDelay_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDelay();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDialoguePlayer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDialoguePlayer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDistanceDatum();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDistanceCrossFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDistanceCrossFade();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeParamCrossFade_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeParamCrossFade();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDoppler_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeDoppler();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeEnveloper_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeEnveloper();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeGroupControl_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeGroupControl();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeLooping_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeLooping();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeMature_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeMature();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeMixer_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeMixer();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeModulator_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeModulator();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ModulationParamMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FModulatorContinuousParams();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeModulatorContinuous_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeModulatorContinuous();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeOscillator_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeOscillator();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeQualityLevel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeQualityLevel();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeRandom_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeRandom();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeSoundClass_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeSoundClass();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeSwitch_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeSwitch();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeWaveParam_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USoundNodeWaveParam();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EOptimizationType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EImportanceLevel();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ENormalMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAssetEditorOrbitCameraPosition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMeshSectionInfoMap();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMeshSectionInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStaticMeshSourceModel();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStaticMeshOptimizationSettings();
	ENGINE_API class UFunction* Z_Construct_UFunction_UStaticMesh_GetBoundingBox();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMesh_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMesh();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshSocket_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshSocket();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FSubsurfaceProfileStruct();
	ENGINE_API class UClass* Z_Construct_UClass_USubsurfaceProfile_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USubsurfaceProfile();
	ENGINE_API class UClass* Z_Construct_UClass_UTextPropertyTestObject_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextPropertyTestObject();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETextureSourceFormat();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETextureSourceArtType();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETextureMipCount();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECompositeTextureMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_TextureAddress();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_TextureFilter();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_TextureCompressionSettings();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTexturePlatformData();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTextureSource();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTexture2D_Blueprint_GetSizeX();
	ENGINE_API class UFunction* Z_Construct_UFunction_UTexture2D_Blueprint_GetSizeY();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D();
	ENGINE_API class UClass* Z_Construct_UClass_ULightMapTexture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_ULightMapTexture2D();
	ENGINE_API class UClass* Z_Construct_UClass_UShadowMapTexture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UShadowMapTexture2D();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureLightProfile_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureLightProfile();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2DDynamic_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2DDynamic();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureCube_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureCube();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureRenderTarget_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureRenderTarget();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureRenderTarget2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureRenderTarget2D();
	ENGINE_API class UFunction* Z_Construct_UDelegateFunction_Engine_OnCanvasRenderTargetUpdate__DelegateSignature();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvasRenderTarget2D_CreateCanvasRenderTarget2D();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvasRenderTarget2D_GetSize();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvasRenderTarget2D_ReceiveUpdate();
	ENGINE_API class UFunction* Z_Construct_UFunction_UCanvasRenderTarget2D_UpdateResource();
	ENGINE_API class UClass* Z_Construct_UClass_UCanvasRenderTarget2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCanvasRenderTarget2D();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureRenderTargetCube_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTextureRenderTargetCube();
	ENGINE_API class UClass* Z_Construct_UClass_UThumbnailInfo_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UThumbnailInfo();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTTLinearColorTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTTVectorTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTTFloatTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTTEventTrack();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTTTrackBase();
	ENGINE_API class UClass* Z_Construct_UClass_UTimelineTemplate_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTimelineTemplate();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FTouchInputControl();
	ENGINE_API class UClass* Z_Construct_UClass_UTouchInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTouchInterface();
	ENGINE_API class UClass* Z_Construct_UClass_UUserDefinedEnum_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UUserDefinedEnum();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EUserDefinedStructureStatus();
	ENGINE_API class UClass* Z_Construct_UClass_UUserDefinedStruct_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UUserDefinedStruct();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorField_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorField();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EVectorFieldConstructionOp();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorFieldAnimated_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorFieldAnimated();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorFieldStatic_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVectorFieldStatic();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVehicleWheel_GetRotationAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVehicleWheel_GetSteerAngle();
	ENGINE_API class UFunction* Z_Construct_UFunction_UVehicleWheel_GetSuspensionOffset();
	ENGINE_API class UClass* Z_Construct_UClass_UVehicleWheel_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVehicleWheel();
	ENGINE_API class UClass* Z_Construct_UClass_UVertexAnimBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVertexAnimBase();
	ENGINE_API class UClass* Z_Construct_UClass_UMorphTarget_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMorphTarget();
	ENGINE_API class UClass* Z_Construct_UClass_UVertexAnimation_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVertexAnimation();
	ENGINE_API class UClass* Z_Construct_UClass_UVisualLoggerAutomationTests_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UVisualLoggerAutomationTests();
	ENGINE_API class UClass* Z_Construct_UClass_UWorldComposition_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UWorldComposition();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPinHidingMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_Base();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FExposedValueHandler();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FComponentSpacePoseLink();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPoseLink();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FPoseLinkBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FInputScaleBias();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_ApplyAdditive();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_AssetPlayerBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_BlendListBase();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_BlendListByBool();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_BlendListByEnum();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_BlendListByInt();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_BlendSpacePlayer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_BlendSpaceEvaluator();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_LayeredBoneBlend();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ERefPoseType();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_MeshSpaceRefPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_RefPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_Root();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_RotateRootBone();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_RotationOffsetBlendSpace();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_SaveCachedPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_SequenceEvaluator();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_SequencePlayer();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_Slot();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_StateMachine();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationPotentialTransition();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationActiveTransitionEntry();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEvaluatorMode();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EEvaluatorDataSource();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_TransitionPoseEvaluator();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_TransitionResult();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimationNode_TwoWayBlend();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_UseCachedPose();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_ConvertLocalToComponentSpace();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FAnimNode_ConvertComponentToLocalSpace();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECameraAlphaBlendMode();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDummySpacerCameraTypes();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FStreamableManager();
	ENGINE_API class UPackage* Z_Construct_UPackage_Engine();
	UFunction* Z_Construct_UFunction_APawn_SpawnDefaultController()
	{
		UObject* Outer=Z_Construct_UClass_APawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SpawnDefaultController"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Pawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Spawn default controller for this Pawn, and get possessed by it."));
#endif
		}
		return ReturnFunction;
	}
	DEFINE_VTABLE_PTR_HELPER_CTOR(APawn);
	UScriptStruct* Z_Construct_UScriptStruct_FPreviewAssetAttachContainer()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FPreviewAssetAttachContainer_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("PreviewAssetAttachContainer"), sizeof(FPreviewAssetAttachContainer), Get_Z_Construct_UScriptStruct_FPreviewAssetAttachContainer_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PreviewAssetAttachContainer"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FPreviewAssetAttachContainer>, EStructFlags(0x00000001));
			UProperty* NewProp_AttachedObjects = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AttachedObjects"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(AttachedObjects, FPreviewAssetAttachContainer), 0x0000000000000000);
			UProperty* NewProp_AttachedObjects_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AttachedObjects, TEXT("AttachedObjects"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FPreviewAttachedObjectPair());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/PreviewAssetAttachComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Component which deals with attaching assets"));
			MetaData->SetValue(NewProp_AttachedObjects, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/PreviewAssetAttachComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPreviewAssetAttachContainer_CRC() { return 2606315324U; }
	UScriptStruct* Z_Construct_UScriptStruct_FPreviewAttachedObjectPair()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FPreviewAttachedObjectPair_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("PreviewAttachedObjectPair"), sizeof(FPreviewAttachedObjectPair), Get_Z_Construct_UScriptStruct_FPreviewAttachedObjectPair_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PreviewAttachedObjectPair"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FPreviewAttachedObjectPair>, EStructFlags(0x00000001));
			UProperty* NewProp_AttachedTo = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AttachedTo"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(AttachedTo, FPreviewAttachedObjectPair), 0x0000000000000000);
			UProperty* NewProp_Object = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Object"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Object_DEPRECATED, FPreviewAttachedObjectPair), 0x0000000020000000, Z_Construct_UClass_UObject_NoRegister());
			UProperty* NewProp_AttachedObject = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AttachedObject"), RF_Public|RF_Transient|RF_Native) UAssetObjectProperty(CPP_PROPERTY_BASE(AttachedObject, FPreviewAttachedObjectPair), 0x0004000000000000, Z_Construct_UClass_UObject_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/PreviewAssetAttachComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Preview items that are attached to the skeleton *"));
			MetaData->SetValue(NewProp_AttachedTo, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/PreviewAssetAttachComponent.h"));
			MetaData->SetValue(NewProp_AttachedTo, TEXT("ToolTip"), TEXT("The name of the attach point of the Object (for example a bone or socket name)"));
			MetaData->SetValue(NewProp_Object, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/PreviewAssetAttachComponent.h"));
			MetaData->SetValue(NewProp_AttachedObject, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/PreviewAssetAttachComponent.h"));
			MetaData->SetValue(NewProp_AttachedObject, TEXT("ToolTip"), TEXT("the object to be attached"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPreviewAttachedObjectPair_CRC() { return 2561134680U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSmartNameContainer()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSmartNameContainer_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SmartNameContainer"), sizeof(FSmartNameContainer), Get_Z_Construct_UScriptStruct_FSmartNameContainer_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SmartNameContainer"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSmartNameContainer>, EStructFlags(0x00000201));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SmartName.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSmartNameContainer_CRC() { return 3246820567U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSmartNameMapping()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSmartNameMapping_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SmartNameMapping"), sizeof(FSmartNameMapping), Get_Z_Construct_UScriptStruct_FSmartNameMapping_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SmartNameMapping"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSmartNameMapping>, EStructFlags(0x00000201));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SmartName.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSmartNameMapping_CRC() { return 4086383871U; }
	UEnum* Z_Construct_UEnum_Engine_EBoneTranslationRetargetingMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EBoneTranslationRetargetingMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EBoneTranslationRetargetingMode"), 0, Get_Z_Construct_UEnum_Engine_EBoneTranslationRetargetingMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBoneTranslationRetargetingMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneTranslationRetargetingMode::Animation")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneTranslationRetargetingMode::Skeleton")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneTranslationRetargetingMode::AnimationScaled")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneTranslationRetargetingMode::AnimationRelative")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneTranslationRetargetingMode::EBoneTranslationRetargetingMode_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("Animation.ToolTip"), TEXT("Use translation from animation data."));
			MetaData->SetValue(ReturnEnum, TEXT("AnimationRelative.ToolTip"), TEXT("Use Translation from animation, but also play the difference from retargeting pose as an additive."));
			MetaData->SetValue(ReturnEnum, TEXT("AnimationScaled.ToolTip"), TEXT("Use Translation from animation, but scale length by Skeleton's proportions."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Skeleton.ToolTip"), TEXT("Use fixed translation from Skeleton."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Bone translation retargeting mode."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EBoneTranslationRetargetingMode_CRC() { return 1800600902U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotGroup()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimSlotGroup_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimSlotGroup"), sizeof(FAnimSlotGroup), Get_Z_Construct_UScriptStruct_FAnimSlotGroup_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimSlotGroup"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimSlotGroup>, EStructFlags(0x00000001));
			UProperty* NewProp_SlotNames = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SlotNames"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SlotNames, FAnimSlotGroup), 0x0000000000000000);
			UProperty* NewProp_SlotNames_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SlotNames, TEXT("SlotNames"), RF_Public|RF_Transient|RF_Native) UNameProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			UProperty* NewProp_GroupName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GroupName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(GroupName, FAnimSlotGroup), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_SlotNames, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_GroupName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimSlotGroup_CRC() { return 1587898838U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRigConfiguration()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FRigConfiguration_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("RigConfiguration"), sizeof(FRigConfiguration), Get_Z_Construct_UScriptStruct_FRigConfiguration_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RigConfiguration"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRigConfiguration>, EStructFlags(0x00000001));
			UProperty* NewProp_BoneMappingTable = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneMappingTable"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(BoneMappingTable, FRigConfiguration), 0x0000000000000000);
			UProperty* NewProp_BoneMappingTable_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BoneMappingTable, TEXT("BoneMappingTable"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FNameMapping());
			UProperty* NewProp_Rig = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rig"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Rig, FRigConfiguration), 0x0000000000000000, Z_Construct_UClass_URig_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_BoneMappingTable, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_BoneMappingTable, TEXT("ToolTip"), TEXT("@todo in the future we can make this to be run-time data"));
			MetaData->SetValue(NewProp_Rig, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRigConfiguration_CRC() { return 820352311U; }
	UScriptStruct* Z_Construct_UScriptStruct_FNameMapping()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FNameMapping_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("NameMapping"), sizeof(FNameMapping), Get_Z_Construct_UScriptStruct_FNameMapping_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NameMapping"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FNameMapping>, EStructFlags(0x00000001));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, FNameMapping), 0x0000000000000000);
			UProperty* NewProp_NodeName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NodeName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(NodeName, FNameMapping), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_NodeName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FNameMapping_CRC() { return 525217463U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBoneReductionSetting()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBoneReductionSetting_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BoneReductionSetting"), sizeof(FBoneReductionSetting), Get_Z_Construct_UScriptStruct_FBoneReductionSetting_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoneReductionSetting"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBoneReductionSetting>, EStructFlags(0x00000001));
			UProperty* NewProp_BonesToRemove = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BonesToRemove"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(BonesToRemove, FBoneReductionSetting), 0x0000000000000000);
			UProperty* NewProp_BonesToRemove_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BonesToRemove, TEXT("BonesToRemove"), RF_Public|RF_Transient|RF_Native) UNameProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_BonesToRemove, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBoneReductionSetting_CRC() { return 1363743925U; }
	UScriptStruct* Z_Construct_UScriptStruct_FReferencePose()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FReferencePose_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ReferencePose"), sizeof(FReferencePose), Get_Z_Construct_UScriptStruct_FReferencePose_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReferencePose"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FReferencePose>, EStructFlags(0x00000001));
#if WITH_EDITORONLY_DATA
			UProperty* NewProp_ReferenceMesh = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ReferenceMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReferenceMesh, FReferencePose), 0x0000000800000000, Z_Construct_UClass_USkeletalMesh_NoRegister());
#endif // WITH_EDITORONLY_DATA
			UProperty* NewProp_ReferencePose = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ReferencePose"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReferencePose, FReferencePose), 0x0000000000000000);
			UProperty* NewProp_ReferencePose_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReferencePose, TEXT("ReferencePose"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_PoseName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PoseName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(PoseName, FReferencePose), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("This is a mapping table between bone in a particular skeletal mesh and bone of this skeleton set."));
			MetaData->SetValue(NewProp_ReferenceMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_ReferencePose, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_PoseName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FReferencePose_CRC() { return 2469936027U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBoneNode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBoneNode_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BoneNode"), sizeof(FBoneNode), Get_Z_Construct_UScriptStruct_FBoneNode_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoneNode"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBoneNode>, EStructFlags(0x00000001));
			UProperty* NewProp_TranslationRetargetingMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TranslationRetargetingMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(TranslationRetargetingMode, FBoneNode), 0x0000000000000001, Z_Construct_UEnum_Engine_EBoneTranslationRetargetingMode());
			UProperty* NewProp_ParentIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ParentIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ParentIndex_DEPRECATED, FBoneNode), 0x0000000020000000);
			UProperty* NewProp_Name = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Name"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(Name_DEPRECATED, FBoneNode), 0x0000000020000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Each Bone node in BoneTree"));
			MetaData->SetValue(NewProp_TranslationRetargetingMode, TEXT("Category"), TEXT("BoneNode"));
			MetaData->SetValue(NewProp_TranslationRetargetingMode, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_TranslationRetargetingMode, TEXT("ToolTip"), TEXT("Retargeting Mode for Translation Component."));
			MetaData->SetValue(NewProp_ParentIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_ParentIndex, TEXT("ToolTip"), TEXT("Parent Index. -1 if not used. The root has 0 as its parent. Do not delete the element but set this to -1. If it is revived by other reason, fix up this link."));
			MetaData->SetValue(NewProp_Name, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_Name, TEXT("ToolTip"), TEXT("Name of bone, this is the search criteria to match with mesh bone. This will be NAME_None if deleted."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBoneNode_CRC() { return 742028408U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSkeletonToMeshLinkup()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSkeletonToMeshLinkup_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SkeletonToMeshLinkup"), sizeof(FSkeletonToMeshLinkup), Get_Z_Construct_UScriptStruct_FSkeletonToMeshLinkup_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletonToMeshLinkup"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSkeletonToMeshLinkup>, EStructFlags(0x00000001));
			UProperty* NewProp_MeshToSkeletonTable = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MeshToSkeletonTable"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(MeshToSkeletonTable, FSkeletonToMeshLinkup), 0x0000000000000000);
			UProperty* NewProp_MeshToSkeletonTable_Inner = new(EC_InternalUseOnlyConstructor, NewProp_MeshToSkeletonTable, TEXT("MeshToSkeletonTable"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			UProperty* NewProp_SkeletonToMeshTable = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SkeletonToMeshTable"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SkeletonToMeshTable, FSkeletonToMeshLinkup), 0x0000000000000000);
			UProperty* NewProp_SkeletonToMeshTable_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SkeletonToMeshTable, TEXT("SkeletonToMeshTable"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("This is a mapping table between bone in a particular skeletal mesh and bone of this skeleton set."));
			MetaData->SetValue(NewProp_MeshToSkeletonTable, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_MeshToSkeletonTable, TEXT("ToolTip"), TEXT("Mapping table. Size must be same as size of ref pose (not bone tree).\nNo index should be more than the number of bones in this skeletalmesh\n-1 indicates no match for this bone - will be ignored."));
			MetaData->SetValue(NewProp_SkeletonToMeshTable, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
			MetaData->SetValue(NewProp_SkeletonToMeshTable, TEXT("ToolTip"), TEXT("Mapping table. Size must be same as size of bone tree (not Mesh Ref Pose).\nNo index should be more than the number of bones in this skeleton\n-1 indicates no match for this bone - will be ignored."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSkeletonToMeshLinkup_CRC() { return 2480506166U; }
	UClass* Z_Construct_UClass_USkeleton_NoRegister()
	{
		return USkeleton::StaticClass();
	}
	UClass* Z_Construct_UClass_USkeleton()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = USkeleton::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20080080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_BoneReductionSettingsForLODs = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoneReductionSettingsForLODs"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(BoneReductionSettingsForLODs, USkeleton), 0x0000000800000000);
				UProperty* NewProp_BoneReductionSettingsForLODs_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BoneReductionSettingsForLODs, TEXT("BoneReductionSettingsForLODs"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000, Z_Construct_UScriptStruct_FBoneReductionSetting());
				UProperty* NewProp_PreviewAttachedAssetContainer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewAttachedAssetContainer"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviewAttachedAssetContainer, USkeleton), 0x0000000800000000, Z_Construct_UScriptStruct_FPreviewAssetAttachContainer());
				UProperty* NewProp_AnimationNotifies = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimationNotifies"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(AnimationNotifies, USkeleton), 0x0000000800000000);
				UProperty* NewProp_AnimationNotifies_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AnimationNotifies, TEXT("AnimationNotifies"), RF_Public|RF_Transient|RF_Native) UNameProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000);
				UProperty* NewProp_RigConfig = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RigConfig"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RigConfig, USkeleton), 0x0000000800000000, Z_Construct_UScriptStruct_FRigConfiguration());
				UProperty* NewProp_PreviewSkeletalMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewSkeletalMesh"), RF_Public|RF_Transient|RF_Native) UAssetObjectProperty(CPP_PROPERTY_BASE(PreviewSkeletalMesh, USkeleton), 0x0004010800200000, Z_Construct_UClass_USkeletalMesh_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_SlotGroups = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SlotGroups"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SlotGroups, USkeleton), 0x0000000000000000);
				UProperty* NewProp_SlotGroups_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SlotGroups, TEXT("SlotGroups"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAnimSlotGroup());
				UProperty* NewProp_SmartNames = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SmartNames"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SmartNames, USkeleton), 0x0000000000000000, Z_Construct_UScriptStruct_FSmartNameContainer());
				UProperty* NewProp_Sockets = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Sockets"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Sockets, USkeleton), 0x0000000000000000);
				UProperty* NewProp_Sockets_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Sockets, TEXT("Sockets"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_USkeletalMeshSocket_NoRegister());
				UProperty* NewProp_LinkupCache = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LinkupCache"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LinkupCache, USkeleton), 0x0000000000002000);
				UProperty* NewProp_LinkupCache_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LinkupCache, TEXT("LinkupCache"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FSkeletonToMeshLinkup());
				UProperty* NewProp_RefLocalPoses = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RefLocalPoses"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(RefLocalPoses_DEPRECATED, USkeleton), 0x0000000020000000);
				UProperty* NewProp_RefLocalPoses_Inner = new(EC_InternalUseOnlyConstructor, NewProp_RefLocalPoses, TEXT("RefLocalPoses"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000020000000, Z_Construct_UScriptStruct_FTransform());
				UProperty* NewProp_BoneTree = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoneTree"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(BoneTree, USkeleton), 0x0000000000020001);
				UProperty* NewProp_BoneTree_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BoneTree, TEXT("BoneTree"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000020000, Z_Construct_UScriptStruct_FBoneNode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Animation/Skeleton.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("USkeleton : that links between mesh and animation\n        - Bone hierarchy for animations\n        - Bone/track linkup between mesh and animation\n        - Retargetting related\n        - Mirror table"));
				MetaData->SetValue(NewProp_BoneReductionSettingsForLODs, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_PreviewAttachedAssetContainer, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_PreviewAttachedAssetContainer, TEXT("ToolTip"), TEXT("Attached assets component for this skeleton"));
				MetaData->SetValue(NewProp_AnimationNotifies, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_AnimationNotifies, TEXT("ToolTip"), TEXT("AnimNotifiers that has been created. Right now there is no delete step for this, but in the future we'll supply delete*"));
				MetaData->SetValue(NewProp_RigConfig, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_PreviewSkeletalMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_PreviewSkeletalMesh, TEXT("ToolTip"), TEXT("The default skeletal mesh to use when previewing this skeleton"));
				MetaData->SetValue(NewProp_SlotGroups, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_SlotGroups, TEXT("ToolTip"), TEXT("serialized slot groups and slot names."));
				MetaData->SetValue(NewProp_SmartNames, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_SmartNames, TEXT("ToolTip"), TEXT("Container for smart name mappings"));
				MetaData->SetValue(NewProp_Sockets, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_Sockets, TEXT("ToolTip"), TEXT("Array of named socket locations, set up in editor and used as a shortcut instead of specifying\neverything explicitly to AttachComponent in the SkeletalMeshComponent."));
				MetaData->SetValue(NewProp_LinkupCache, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_LinkupCache, TEXT("ToolTip"), TEXT("Non-serialised cache of linkups between different skeletal meshes and this Skeleton."));
				MetaData->SetValue(NewProp_RefLocalPoses, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_RefLocalPoses, TEXT("ToolTip"), TEXT("Reference skeleton poses in local space"));
				MetaData->SetValue(NewProp_BoneTree, TEXT("Category"), TEXT("Skeleton"));
				MetaData->SetValue(NewProp_BoneTree, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/Skeleton.h"));
				MetaData->SetValue(NewProp_BoneTree, TEXT("ToolTip"), TEXT("Skeleton bone tree - each contains name and parent index*"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkeleton(Z_Construct_UClass_USkeleton, TEXT("USkeleton"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkeleton);
	UScriptStruct* Z_Construct_UScriptStruct_FTriMeshCollisionData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTriMeshCollisionData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TriMeshCollisionData"), sizeof(FTriMeshCollisionData), Get_Z_Construct_UScriptStruct_FTriMeshCollisionData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TriMeshCollisionData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTriMeshCollisionData>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFlipNormals, FTriMeshCollisionData, uint8);
			UProperty* NewProp_bFlipNormals = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bFlipNormals"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFlipNormals, FTriMeshCollisionData), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bFlipNormals, FTriMeshCollisionData), sizeof(uint8), false);
			UProperty* NewProp_Indices = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Indices"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Indices, FTriMeshCollisionData), 0x0000000000002000);
			UProperty* NewProp_Indices_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Indices, TEXT("Indices"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FTriIndices());
			UProperty* NewProp_Vertices = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Vertices"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Vertices, FTriMeshCollisionData), 0x0000000000002000);
			UProperty* NewProp_Vertices_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Vertices, TEXT("Vertices"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Description of triangle mesh collision data necessary for cooking physics data"));
			MetaData->SetValue(NewProp_bFlipNormals, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(NewProp_bFlipNormals, TEXT("ToolTip"), TEXT("Does the mesh require its normals flipped (see PxMeshFlag)"));
			MetaData->SetValue(NewProp_Indices, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(NewProp_Indices, TEXT("ToolTip"), TEXT("Array of indices defining the ordering of triangles in the mesh"));
			MetaData->SetValue(NewProp_Vertices, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(NewProp_Vertices, TEXT("ToolTip"), TEXT("Array of vertices included in the triangle mesh"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTriMeshCollisionData_CRC() { return 3363117491U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTriIndices()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTriIndices_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TriIndices"), sizeof(FTriIndices), Get_Z_Construct_UScriptStruct_FTriIndices_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TriIndices"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTriIndices>, EStructFlags(0x00000001));
			UProperty* NewProp_v2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("v2"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(v2, FTriIndices), 0x0000000000000000);
			UProperty* NewProp_v1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("v1"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(v1, FTriIndices), 0x0000000000000000);
			UProperty* NewProp_v0 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("v0"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(v0, FTriIndices), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Vertex indices necessary to describe the vertices listed in TriMeshCollisionData"));
			MetaData->SetValue(NewProp_v2, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(NewProp_v1, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
			MetaData->SetValue(NewProp_v0, TEXT("ModuleRelativePath"), TEXT("Classes/Interfaces/Interface_CollisionDataProvider.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTriIndices_CRC() { return 947208303U; }
	UClass* Z_Construct_UClass_UInterface_CollisionDataProvider_NoRegister()
	{
		return UInterface_CollisionDataProvider::StaticClass();
	}
	UClass* Z_Construct_UClass_UInterface_CollisionDataProvider()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Engine();
			OuterClass = UInterface_CollisionDataProvider::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20004081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("CannotImplementInterfaceInBlueprint"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UInterface_CollisionDataProvider(Z_Construct_UClass_UInterface_CollisionDataProvider, TEXT("UInterface_CollisionDataProvider"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UInterface_CollisionDataProvider);
	UEnum* Z_Construct_UEnum_Engine_SkeletalMeshOptimizationType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_SkeletalMeshOptimizationType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("SkeletalMeshOptimizationType"), 0, Get_Z_Construct_UEnum_Engine_SkeletalMeshOptimizationType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletalMeshOptimizationType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOT_NumOfTriangles")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOT_MaxDeviation")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOT_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enum specifying the reduction type to use when simplifying skeletal meshes."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_SkeletalMeshOptimizationType_CRC() { return 3975416824U; }
	UEnum* Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("SkeletalMeshOptimizationImportance"), 0, Get_Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletalMeshOptimizationImportance"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_Off")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_Lowest")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_Low")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_Normal")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_High")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_Highest")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SMOI_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enum specifying the importance of properties when simplifying skeletal meshes."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance_CRC() { return 2856837012U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMaterial()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSkeletalMaterial_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SkeletalMaterial"), sizeof(FSkeletalMaterial), Get_Z_Construct_UScriptStruct_FSkeletalMaterial_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletalMaterial"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSkeletalMaterial>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableShadowCasting, FSkeletalMaterial, bool);
			UProperty* NewProp_bEnableShadowCasting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEnableShadowCasting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableShadowCasting, FSkeletalMaterial), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bEnableShadowCasting, FSkeletalMaterial), sizeof(bool), true);
			UProperty* NewProp_MaterialInterface = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaterialInterface"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MaterialInterface, FSkeletalMaterial), 0x0000000000002015, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Material interface for USkeletalMesh - contains a material and a shadow casting flag"));
			MetaData->SetValue(NewProp_bEnableShadowCasting, TEXT("Category"), TEXT("SkeletalMesh"));
			MetaData->SetValue(NewProp_bEnableShadowCasting, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_MaterialInterface, TEXT("Category"), TEXT("SkeletalMesh"));
			MetaData->SetValue(NewProp_MaterialInterface, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSkeletalMaterial_CRC() { return 3115939335U; }
	UScriptStruct* Z_Construct_UScriptStruct_FClothingAssetData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FClothingAssetData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ClothingAssetData"), sizeof(FClothingAssetData), Get_Z_Construct_UScriptStruct_FClothingAssetData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClothingAssetData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FClothingAssetData>, EStructFlags(0x00000001));
			UProperty* NewProp_PhysicsProperties = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PhysicsProperties"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PhysicsProperties, FClothingAssetData), 0x0000000000002001, Z_Construct_UScriptStruct_FClothPhysicsProperties());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClothPropertiesChanged, FClothingAssetData, bool);
			UProperty* NewProp_bClothPropertiesChanged = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bClothPropertiesChanged"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClothPropertiesChanged, FClothingAssetData), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bClothPropertiesChanged, FClothingAssetData), sizeof(bool), true);
			UProperty* NewProp_ApexFileName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ApexFileName"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(ApexFileName, FClothingAssetData), 0x0000000000000001);
			UProperty* NewProp_AssetName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AssetName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(AssetName, FClothingAssetData), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_PhysicsProperties, TEXT("Category"), TEXT("ClothingAssetData"));
			MetaData->SetValue(NewProp_PhysicsProperties, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_bClothPropertiesChanged, TEXT("Category"), TEXT("ClothingAssetData"));
			MetaData->SetValue(NewProp_bClothPropertiesChanged, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_bClothPropertiesChanged, TEXT("ToolTip"), TEXT("the flag whether cloth physics properties are changed from UE4 editor or not"));
			MetaData->SetValue(NewProp_ApexFileName, TEXT("Category"), TEXT("ClothingAssetData"));
			MetaData->SetValue(NewProp_ApexFileName, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_AssetName, TEXT("Category"), TEXT("ClothingAssetData"));
			MetaData->SetValue(NewProp_AssetName, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_AssetName, TEXT("ToolTip"), TEXT("User-defined asset name"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FClothingAssetData_CRC() { return 1991922048U; }
	UScriptStruct* Z_Construct_UScriptStruct_FClothPhysicsProperties()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FClothPhysicsProperties_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ClothPhysicsProperties"), sizeof(FClothPhysicsProperties), Get_Z_Construct_UScriptStruct_FClothPhysicsProperties_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClothPhysicsProperties"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FClothPhysicsProperties>, EStructFlags(0x00000001));
			UProperty* NewProp_SelfCollisionThickness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SelfCollisionThickness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SelfCollisionThickness, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_InertiaBlend = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InertiaBlend"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InertiaBlend, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_GravityScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GravityScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GravityScale, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_Drag = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Drag"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Drag, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_Damping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Damping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Damping, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_Friction = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Friction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Friction, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_StretchLimit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StretchLimit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StretchLimit, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_ShearResistance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ShearResistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ShearResistance, FClothPhysicsProperties), 0x0000000000000001);
			UProperty* NewProp_BendResistance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BendResistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BendResistance, FClothPhysicsProperties), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("now exposed a part of properties based on 3DS Max plug-in\nproperty names are also changed into 3DS Max plug-in's one"));
			MetaData->SetValue(NewProp_SelfCollisionThickness, TEXT("Category"), TEXT("SelfCollision"));
			MetaData->SetValue(NewProp_SelfCollisionThickness, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_SelfCollisionThickness, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_SelfCollisionThickness, TEXT("ToolTip"), TEXT("Minimal amount of distance particles will keep of each other."));
			MetaData->SetValue(NewProp_SelfCollisionThickness, TEXT("UIMax"), TEXT("5.0"));
			MetaData->SetValue(NewProp_SelfCollisionThickness, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_InertiaBlend, TEXT("Category"), TEXT("Scale"));
			MetaData->SetValue(NewProp_InertiaBlend, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_InertiaBlend, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_InertiaBlend, TEXT("ToolTip"), TEXT("Amount of inertia that is kept when using local space simulation. Internal name is inertia scale"));
			MetaData->SetValue(NewProp_InertiaBlend, TEXT("UIMax"), TEXT("5.0"));
			MetaData->SetValue(NewProp_InertiaBlend, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_GravityScale, TEXT("Category"), TEXT("Scale"));
			MetaData->SetValue(NewProp_GravityScale, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_GravityScale, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_GravityScale, TEXT("ToolTip"), TEXT("Amount of gravity that is applied to the cloth."));
			MetaData->SetValue(NewProp_GravityScale, TEXT("UIMax"), TEXT("5.0"));
			MetaData->SetValue(NewProp_GravityScale, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Drag, TEXT("Category"), TEXT("Stiffness"));
			MetaData->SetValue(NewProp_Drag, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_Drag, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Drag, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_Drag, TEXT("ToolTip"), TEXT("Drag coefficient n the range [0, 1]"));
			MetaData->SetValue(NewProp_Drag, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_Drag, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Damping, TEXT("Category"), TEXT("Stiffness"));
			MetaData->SetValue(NewProp_Damping, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_Damping, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Damping, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_Damping, TEXT("ToolTip"), TEXT("Spring damping of the cloth in the range[0, 1]"));
			MetaData->SetValue(NewProp_Damping, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_Damping, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Friction, TEXT("Category"), TEXT("Stiffness"));
			MetaData->SetValue(NewProp_Friction, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_Friction, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Friction, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_Friction, TEXT("ToolTip"), TEXT("Friction coefficient in the range[0, 1]"));
			MetaData->SetValue(NewProp_Friction, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_Friction, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_StretchLimit, TEXT("Category"), TEXT("Stiffness"));
			MetaData->SetValue(NewProp_StretchLimit, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_StretchLimit, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_StretchLimit, TEXT("ToolTip"), TEXT("Make cloth simulation less stretchy. A value smaller than 1 will turn it off."));
			MetaData->SetValue(NewProp_StretchLimit, TEXT("UIMax"), TEXT("4.0"));
			MetaData->SetValue(NewProp_StretchLimit, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("Category"), TEXT("Stiffness"));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("ToolTip"), TEXT("Shearing stiffness of the cloth in the range [0, 1]."));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_ShearResistance, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_BendResistance, TEXT("Category"), TEXT("Stiffness"));
			MetaData->SetValue(NewProp_BendResistance, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_BendResistance, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_BendResistance, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BendResistance, TEXT("ToolTip"), TEXT("Bending stiffness of the cloth in the range [0, 1]."));
			MetaData->SetValue(NewProp_BendResistance, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_BendResistance, TEXT("UIMin"), TEXT("0.0"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FClothPhysicsProperties_CRC() { return 2866505674U; }
	UScriptStruct* Z_Construct_UScriptStruct_FMorphTargetMap()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FMorphTargetMap_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("MorphTargetMap"), sizeof(FMorphTargetMap), Get_Z_Construct_UScriptStruct_FMorphTargetMap_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MorphTargetMap"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FMorphTargetMap>, EStructFlags(0x00000001));
			UProperty* NewProp_MorphTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MorphTarget"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MorphTarget, FMorphTargetMap), 0x0000000000000001, Z_Construct_UClass_UMorphTarget_NoRegister());
			UProperty* NewProp_Name = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Name"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(Name, FMorphTargetMap), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_MorphTarget, TEXT("Category"), TEXT("MorphTargetMap"));
			MetaData->SetValue(NewProp_MorphTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_MorphTarget, TEXT("ToolTip"), TEXT("Axis the bone is mirrored across."));
			MetaData->SetValue(NewProp_Name, TEXT("Category"), TEXT("MorphTargetMap"));
			MetaData->SetValue(NewProp_Name, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_Name, TEXT("ToolTip"), TEXT("The bone to mirror."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMorphTargetMap_CRC() { return 2408008188U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMeshLODInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSkeletalMeshLODInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SkeletalMeshLODInfo"), sizeof(FSkeletalMeshLODInfo), Get_Z_Construct_UScriptStruct_FSkeletalMeshLODInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletalMeshLODInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSkeletalMeshLODInfo>, EStructFlags(0x00000001));
			UProperty* NewProp_ReductionSettings = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ReductionSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReductionSettings, FSkeletalMeshLODInfo), 0x0000000000000001, Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasBeenSimplified, FSkeletalMeshLODInfo, uint8);
			UProperty* NewProp_bHasBeenSimplified = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bHasBeenSimplified"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasBeenSimplified, FSkeletalMeshLODInfo), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasBeenSimplified, FSkeletalMeshLODInfo), sizeof(uint8), false);
			UProperty* NewProp_TriangleSortSettings = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TriangleSortSettings"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(TriangleSortSettings, FSkeletalMeshLODInfo), 0x0000000000000041);
			UProperty* NewProp_TriangleSortSettings_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TriangleSortSettings, TEXT("TriangleSortSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FTriangleSortSettings());
			UProperty* NewProp_bEnableShadowCasting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEnableShadowCasting"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(bEnableShadowCasting_DEPRECATED, FSkeletalMeshLODInfo), 0x0000000020000000);
			UProperty* NewProp_bEnableShadowCasting_Inner = new(EC_InternalUseOnlyConstructor, NewProp_bEnableShadowCasting, TEXT("bEnableShadowCasting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000020000000, 0, sizeof(bool), true);
			UProperty* NewProp_LODMaterialMap = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LODMaterialMap"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LODMaterialMap, FSkeletalMeshLODInfo), 0x0000000000000041);
			UProperty* NewProp_LODMaterialMap_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LODMaterialMap, TEXT("LODMaterialMap"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			UProperty* NewProp_LODHysteresis = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LODHysteresis"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LODHysteresis, FSkeletalMeshLODInfo), 0x0000000000000001);
			UProperty* NewProp_ScreenSize = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ScreenSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScreenSize, FSkeletalMeshLODInfo), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct containing information for a particular LOD level, such as materials and info for when to use it."));
			MetaData->SetValue(NewProp_ReductionSettings, TEXT("Category"), TEXT("ReductionSettings"));
			MetaData->SetValue(NewProp_ReductionSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_ReductionSettings, TEXT("ToolTip"), TEXT("Reduction settings to apply when building render data."));
			MetaData->SetValue(NewProp_bHasBeenSimplified, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_bHasBeenSimplified, TEXT("ToolTip"), TEXT("Whether to disable morph targets for this LOD."));
			MetaData->SetValue(NewProp_TriangleSortSettings, TEXT("Category"), TEXT("SkeletalMeshLODInfo"));
			MetaData->SetValue(NewProp_TriangleSortSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_bEnableShadowCasting, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_bEnableShadowCasting, TEXT("ToolTip"), TEXT("Per-section control over whether to enable shadow casting."));
			MetaData->SetValue(NewProp_LODMaterialMap, TEXT("Category"), TEXT("SkeletalMeshLODInfo"));
			MetaData->SetValue(NewProp_LODMaterialMap, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_LODMaterialMap, TEXT("ToolTip"), TEXT("Mapping table from this LOD's materials to the USkeletalMesh materials array."));
			MetaData->SetValue(NewProp_LODHysteresis, TEXT("Category"), TEXT("SkeletalMeshLODInfo"));
			MetaData->SetValue(NewProp_LODHysteresis, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_LODHysteresis, TEXT("ToolTip"), TEXT("Used to avoid 'flickering' when on LOD boundary. Only taken into account when moving from complex->simple."));
			MetaData->SetValue(NewProp_ScreenSize, TEXT("Category"), TEXT("SkeletalMeshLODInfo"));
			MetaData->SetValue(NewProp_ScreenSize, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_ScreenSize, TEXT("ToolTip"), TEXT("Indicates when to use this LOD. A smaller number means use this LOD when further away."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSkeletalMeshLODInfo_CRC() { return 634578390U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SkeletalMeshOptimizationSettings"), sizeof(FSkeletalMeshOptimizationSettings), Get_Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletalMeshOptimizationSettings"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSkeletalMeshOptimizationSettings>, EStructFlags(0x00000001));
			UProperty* NewProp_BonesToRemove = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BonesToRemove"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(BonesToRemove, FSkeletalMeshOptimizationSettings), 0x0000000000000001);
			UProperty* NewProp_BonesToRemove_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BonesToRemove, TEXT("BonesToRemove"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FBoneReference());
			UProperty* NewProp_MaxBonesPerVertex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxBonesPerVertex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxBonesPerVertex, FSkeletalMeshOptimizationSettings), 0x0000000000000000);
			UProperty* NewProp_BoneReductionRatio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneReductionRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BoneReductionRatio, FSkeletalMeshOptimizationSettings), 0x0000000000000000);
			UProperty* NewProp_SkinningImportance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SkinningImportance"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SkinningImportance, FSkeletalMeshOptimizationSettings), 0x0000000000000000, Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance());
			UProperty* NewProp_ShadingImportance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ShadingImportance"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ShadingImportance, FSkeletalMeshOptimizationSettings), 0x0000000000000000, Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance());
			UProperty* NewProp_TextureImportance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TextureImportance"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(TextureImportance, FSkeletalMeshOptimizationSettings), 0x0000000000000000, Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance());
			UProperty* NewProp_SilhouetteImportance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SilhouetteImportance"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SilhouetteImportance, FSkeletalMeshOptimizationSettings), 0x0000000000000000, Z_Construct_UEnum_Engine_SkeletalMeshOptimizationImportance());
			UProperty* NewProp_NormalsThreshold = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NormalsThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NormalsThreshold, FSkeletalMeshOptimizationSettings), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRecalcNormals, FSkeletalMeshOptimizationSettings, bool);
			UProperty* NewProp_bRecalcNormals = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bRecalcNormals"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRecalcNormals, FSkeletalMeshOptimizationSettings), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bRecalcNormals, FSkeletalMeshOptimizationSettings), sizeof(bool), true);
			UProperty* NewProp_WeldingThreshold = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("WeldingThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WeldingThreshold, FSkeletalMeshOptimizationSettings), 0x0000000000000000);
			UProperty* NewProp_MaxDeviationPercentage = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxDeviationPercentage"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxDeviationPercentage, FSkeletalMeshOptimizationSettings), 0x0000000000000000);
			UProperty* NewProp_NumOfTrianglesPercentage = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NumOfTrianglesPercentage"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NumOfTrianglesPercentage, FSkeletalMeshOptimizationSettings), 0x0000000000000000);
			UProperty* NewProp_ReductionMethod = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ReductionMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReductionMethod, FSkeletalMeshOptimizationSettings), 0x0000000000000000, Z_Construct_UEnum_Engine_SkeletalMeshOptimizationType());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("FSkeletalMeshOptimizationSettings - The settings used to optimize a skeletal mesh LOD."));
			MetaData->SetValue(NewProp_BonesToRemove, TEXT("Category"), TEXT("ReductionSettings"));
			MetaData->SetValue(NewProp_BonesToRemove, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_MaxBonesPerVertex, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_MaxBonesPerVertex, TEXT("ToolTip"), TEXT("Maximum number of bones that can be assigned to each vertex."));
			MetaData->SetValue(NewProp_BoneReductionRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BoneReductionRatio, TEXT("ToolTip"), TEXT("The ratio of bones that will be removed from the mesh"));
			MetaData->SetValue(NewProp_SkinningImportance, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_SkinningImportance, TEXT("ToolTip"), TEXT("How important skinning quality is."));
			MetaData->SetValue(NewProp_ShadingImportance, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_ShadingImportance, TEXT("ToolTip"), TEXT("How important shading quality is."));
			MetaData->SetValue(NewProp_TextureImportance, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_TextureImportance, TEXT("ToolTip"), TEXT("How important texture density is."));
			MetaData->SetValue(NewProp_SilhouetteImportance, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_SilhouetteImportance, TEXT("ToolTip"), TEXT("How important the shape of the geometry is."));
			MetaData->SetValue(NewProp_NormalsThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_NormalsThreshold, TEXT("ToolTip"), TEXT("If the angle between two triangles are above this value, the normals will not be\n      smooth over the edge between those two triangles. Set in degrees. This is only used when PreserveNormals is set to false"));
			MetaData->SetValue(NewProp_bRecalcNormals, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_bRecalcNormals, TEXT("ToolTip"), TEXT("Whether Normal smoothing groups should be preserved. If false then NormalsThreshold is used *"));
			MetaData->SetValue(NewProp_WeldingThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_WeldingThreshold, TEXT("ToolTip"), TEXT("The welding threshold distance. Vertices under this distance will be welded."));
			MetaData->SetValue(NewProp_MaxDeviationPercentage, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_MaxDeviationPercentage, TEXT("ToolTip"), TEXT("If ReductionMethod equals SMOT_MaxDeviation this value is the maximum deviation from the base mesh as a percentage of the bounding sphere."));
			MetaData->SetValue(NewProp_NumOfTrianglesPercentage, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_NumOfTrianglesPercentage, TEXT("ToolTip"), TEXT("If ReductionMethod equals SMOT_NumOfTriangles this value is the ratio of triangles [0-1] to remove from the mesh"));
			MetaData->SetValue(NewProp_ReductionMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_ReductionMethod, TEXT("ToolTip"), TEXT("The method to use when optimizing the skeletal mesh LOD"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings_CRC() { return 1710064967U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBoneReference()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBoneReference_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BoneReference"), sizeof(FBoneReference), Get_Z_Construct_UScriptStruct_FBoneReference_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoneReference"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBoneReference>, EStructFlags(0x00000001));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, FBoneReference), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("Category"), TEXT("BoneReference"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ToolTip"), TEXT("Name of bone to control. This is the main bone chain to modify from. *"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBoneReference_CRC() { return 1381228762U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTriangleSortSettings()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTriangleSortSettings_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TriangleSortSettings"), sizeof(FTriangleSortSettings), Get_Z_Construct_UScriptStruct_FTriangleSortSettings_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TriangleSortSettings"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTriangleSortSettings>, EStructFlags(0x00000001));
			UProperty* NewProp_CustomLeftRightBoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomLeftRightBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(CustomLeftRightBoneName, FTriangleSortSettings), 0x0000000000000001);
			UProperty* NewProp_CustomLeftRightAxis = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomLeftRightAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CustomLeftRightAxis, FTriangleSortSettings), 0x0000000000000001, Z_Construct_UEnum_Engine_ETriangleSortAxis());
			UProperty* NewProp_TriangleSorting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TriangleSorting"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(TriangleSorting, FTriangleSortSettings), 0x0000000000000001, Z_Construct_UEnum_Engine_ETriangleSortOption());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct containing triangle sort settings for a particular section"));
			MetaData->SetValue(NewProp_CustomLeftRightBoneName, TEXT("Category"), TEXT("TriangleSortSettings"));
			MetaData->SetValue(NewProp_CustomLeftRightBoneName, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_CustomLeftRightAxis, TEXT("Category"), TEXT("TriangleSortSettings"));
			MetaData->SetValue(NewProp_CustomLeftRightAxis, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_TriangleSorting, TEXT("Category"), TEXT("TriangleSortSettings"));
			MetaData->SetValue(NewProp_TriangleSorting, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTriangleSortSettings_CRC() { return 271986168U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBoneMirrorExport()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBoneMirrorExport_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BoneMirrorExport"), sizeof(FBoneMirrorExport), Get_Z_Construct_UScriptStruct_FBoneMirrorExport_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoneMirrorExport"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBoneMirrorExport>, EStructFlags(0x00000001));
			UProperty* NewProp_BoneFlipAxis = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneFlipAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneFlipAxis, FBoneMirrorExport), 0x0000000000000001, Z_Construct_UEnum_CoreUObject_EAxis());
			UProperty* NewProp_SourceBoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SourceBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(SourceBoneName, FBoneMirrorExport), 0x0000000000000001);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, FBoneMirrorExport), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Structure to export/import bone mirroring information"));
			MetaData->SetValue(NewProp_BoneFlipAxis, TEXT("Category"), TEXT("BoneMirrorExport"));
			MetaData->SetValue(NewProp_BoneFlipAxis, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_SourceBoneName, TEXT("Category"), TEXT("BoneMirrorExport"));
			MetaData->SetValue(NewProp_SourceBoneName, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("Category"), TEXT("BoneMirrorExport"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBoneMirrorExport_CRC() { return 1087997659U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBoneMirrorInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBoneMirrorInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BoneMirrorInfo"), sizeof(FBoneMirrorInfo), Get_Z_Construct_UScriptStruct_FBoneMirrorInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoneMirrorInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBoneMirrorInfo>, EStructFlags(0x00000001));
			UProperty* NewProp_BoneFlipAxis = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneFlipAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneFlipAxis, FBoneMirrorInfo), 0x0000000000000001, Z_Construct_UEnum_CoreUObject_EAxis());
			UProperty* NewProp_SourceIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SourceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SourceIndex, FBoneMirrorInfo), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BoneFlipAxis, TEXT("Category"), TEXT("BoneMirrorInfo"));
			MetaData->SetValue(NewProp_BoneFlipAxis, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_BoneFlipAxis, TEXT("ToolTip"), TEXT("Axis the bone is mirrored across."));
			MetaData->SetValue(NewProp_SourceIndex, TEXT("ArrayClamp"), TEXT("RefSkeleton"));
			MetaData->SetValue(NewProp_SourceIndex, TEXT("Category"), TEXT("BoneMirrorInfo"));
			MetaData->SetValue(NewProp_SourceIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(NewProp_SourceIndex, TEXT("ToolTip"), TEXT("The bone to mirror."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBoneMirrorInfo_CRC() { return 2305811897U; }
	UFunction* Z_Construct_UFunction_USkeletalMesh_FindSocket()
	{
		struct SkeletalMesh_eventFindSocket_Parms
		{
			FName InSocketName;
			USkeletalMeshSocket* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMesh();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FindSocket"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(SkeletalMesh_eventFindSocket_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMesh_eventFindSocket_Parms), 0x0000000000000580, Z_Construct_UClass_USkeletalMeshSocket_NoRegister());
			UProperty* NewProp_InSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSocketName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InSocketName, SkeletalMesh_eventFindSocket_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Find a socket object in this SkeletalMesh by name.\nEntering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMesh_IsSectionUsingCloth()
	{
		struct SkeletalMesh_eventIsSectionUsingCloth_Parms
		{
			int32 InSectionIndex;
			bool bCheckCorrespondingSections;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMesh();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsSectionUsingCloth"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(SkeletalMesh_eventIsSectionUsingCloth_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, SkeletalMesh_eventIsSectionUsingCloth_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, SkeletalMesh_eventIsSectionUsingCloth_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, SkeletalMesh_eventIsSectionUsingCloth_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCheckCorrespondingSections, SkeletalMesh_eventIsSectionUsingCloth_Parms, bool);
			UProperty* NewProp_bCheckCorrespondingSections = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bCheckCorrespondingSections"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCheckCorrespondingSections, SkeletalMesh_eventIsSectionUsingCloth_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bCheckCorrespondingSections, SkeletalMesh_eventIsSectionUsingCloth_Parms), sizeof(bool), true);
			UProperty* NewProp_InSectionIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSectionIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InSectionIndex, SkeletalMesh_eventIsSectionUsingCloth_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Cloth"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bCheckCorrespondingSections"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Checks whether the provided section is using APEX cloth. if bCheckCorrespondingSections is true\ndisabled sections will defer to correspond sections to see if they use cloth (non-cloth sections\nare disabled and another section added when cloth is enabled, using this flag allows for a check\non the original section to succeed)\n@param InSectionIndex Index to check\n@param bCheckCorrespondingSections Whether to check corresponding sections for disabled sections"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkeletalMesh_NoRegister()
	{
		return USkeletalMesh::StaticClass();
	}
	UClass* Z_Construct_UClass_USkeletalMesh()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = USkeletalMesh::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;

				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMesh_FindSocket());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMesh_IsSectionUsingCloth());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Sockets = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Sockets"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Sockets, USkeletalMesh), 0x0000000000000000);
				UProperty* NewProp_Sockets_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Sockets, TEXT("Sockets"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_USkeletalMeshSocket_NoRegister());
				UProperty* NewProp_AssetUserData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AssetUserData"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(AssetUserData, USkeletalMesh), 0x00000c8000000009);
				UProperty* NewProp_AssetUserData_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AssetUserData, TEXT("AssetUserData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UAssetUserData_NoRegister());
				UProperty* NewProp_ClothingAssets = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClothingAssets"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ClothingAssets, USkeletalMesh), 0x0000000000000055);
				UProperty* NewProp_ClothingAssets_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ClothingAssets, TEXT("ClothingAssets"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FClothingAssetData());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_RetargetBasePose = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RetargetBasePose"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(RetargetBasePose, USkeletalMesh), 0x0000000800000000);
				UProperty* NewProp_RetargetBasePose_Inner = new(EC_InternalUseOnlyConstructor, NewProp_RetargetBasePose, TEXT("RetargetBasePose"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000, Z_Construct_UScriptStruct_FTransform());
				UProperty* NewProp_FloorOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FloorOffset, USkeletalMesh), 0x0000000800000000);
				UProperty* NewProp_SelectedClothingSection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SelectedClothingSection"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SelectedClothingSection, USkeletalMesh), 0x0000000800002000);
				UProperty* NewProp_SelectedEditorSection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SelectedEditorSection"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SelectedEditorSection, USkeletalMesh), 0x0000000800002000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_MorphTargets = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MorphTargets"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(MorphTargets, USkeletalMesh), 0x0000000000000004);
				UProperty* NewProp_MorphTargets_Inner = new(EC_InternalUseOnlyConstructor, NewProp_MorphTargets, TEXT("MorphTargets"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UMorphTarget_NoRegister());
				UProperty* NewProp_StreamingDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StreamingDistanceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StreamingDistanceMultiplier, USkeletalMesh), 0x0000000000000015);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_PreviewAttachedAssetContainer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewAttachedAssetContainer"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviewAttachedAssetContainer, USkeletalMesh), 0x0000000800000000, Z_Construct_UScriptStruct_FPreviewAssetAttachContainer());
				UProperty* NewProp_OptimizationSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OptimizationSettings"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OptimizationSettings, USkeletalMesh), 0x0000000800000000);
				UProperty* NewProp_OptimizationSettings_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OptimizationSettings, TEXT("OptimizationSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000, Z_Construct_UScriptStruct_FSkeletalMeshOptimizationSettings());
				UProperty* NewProp_ThumbnailInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailInfo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ThumbnailInfo, USkeletalMesh), 0x00020008000a0009, Z_Construct_UClass_UThumbnailInfo_NoRegister());
				UProperty* NewProp_SourceFileTimestamp = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SourceFileTimestamp"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(SourceFileTimestamp_DEPRECATED, USkeletalMesh), 0x0000000820000000);
				UProperty* NewProp_SourceFilePath = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SourceFilePath"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(SourceFilePath_DEPRECATED, USkeletalMesh), 0x0000000820000000);
				UProperty* NewProp_AssetImportData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AssetImportData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AssetImportData, USkeletalMesh), 0x00020008000a0009, Z_Construct_UClass_UAssetImportData_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_PhysicsAsset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PhysicsAsset"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PhysicsAsset, USkeletalMesh), 0x0000010000000015, Z_Construct_UClass_UPhysicsAsset_NoRegister());
				UProperty* NewProp_BodySetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BodySetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(BodySetup, USkeletalMesh), 0x0000000000002000, Z_Construct_UClass_UBodySetup_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnablePerPolyCollision, USkeletalMesh, uint8);
				UProperty* NewProp_bEnablePerPolyCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnablePerPolyCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnablePerPolyCollision, USkeletalMesh), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bEnablePerPolyCollision, USkeletalMesh), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasVertexColors, USkeletalMesh, uint8);
				UProperty* NewProp_bHasVertexColors = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasVertexColors"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasVertexColors, USkeletalMesh), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasVertexColors, USkeletalMesh), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasBeenSimplified, USkeletalMesh, uint8);
				UProperty* NewProp_bHasBeenSimplified = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasBeenSimplified"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasBeenSimplified, USkeletalMesh), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasBeenSimplified, USkeletalMesh), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseFullPrecisionUVs, USkeletalMesh, uint8);
				UProperty* NewProp_bUseFullPrecisionUVs = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseFullPrecisionUVs"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseFullPrecisionUVs, USkeletalMesh), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bUseFullPrecisionUVs, USkeletalMesh), sizeof(uint8), false);
				UProperty* NewProp_LODInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODInfo"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LODInfo, USkeletalMesh), 0x0000000000000041);
				UProperty* NewProp_LODInfo_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LODInfo, TEXT("LODInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FSkeletalMeshLODInfo());
				UProperty* NewProp_SkelMirrorFlipAxis = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkelMirrorFlipAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SkelMirrorFlipAxis, USkeletalMesh), 0x0000000000000001, Z_Construct_UEnum_CoreUObject_EAxis());
				UProperty* NewProp_SkelMirrorAxis = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkelMirrorAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SkelMirrorAxis, USkeletalMesh), 0x0000000000000001, Z_Construct_UEnum_CoreUObject_EAxis());
				UProperty* NewProp_SkelMirrorTable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkelMirrorTable"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SkelMirrorTable, USkeletalMesh), 0x0000000000000041);
				UProperty* NewProp_SkelMirrorTable_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SkelMirrorTable, TEXT("SkelMirrorTable"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FBoneMirrorInfo());
				UProperty* NewProp_Materials = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Materials"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Materials, USkeletalMesh), 0x0000000000202015);
				UProperty* NewProp_Materials_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Materials, TEXT("Materials"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FSkeletalMaterial());
				UProperty* NewProp_Bounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Bounds"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Bounds, USkeletalMesh), 0x0000000000202000, Z_Construct_UScriptStruct_FBoxSphereBounds());
				UProperty* NewProp_Skeleton = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Skeleton"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Skeleton, USkeletalMesh), 0x0000010000020015, Z_Construct_UClass_USkeleton_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMesh_FindSocket()); // 4040728970
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMesh_IsSectionUsingCloth()); // 3745708871
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UInterface_CollisionDataProvider_NoRegister(), VTABLE_OFFSET(USkeletalMesh, IInterface_CollisionDataProvider), false ));
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UInterface_AssetUserData_NoRegister(), VTABLE_OFFSET(USkeletalMesh, IInterface_AssetUserData), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/SkeletalMesh.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("SkeletalMesh is geometry bound to a hierarchical skeleton of bones which can be animated for the purpose of deforming the mesh.\nSkeletal Meshes are built up of two parts; a set of polygons composed to make up the surface of the mesh, and a hierarchical skeleton which can be used to animate the polygons.\nThe 3D models, rigging, and animations are created in an external modeling and animation application (3DSMax, Maya, Softimage, etc).\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/"));
				MetaData->SetValue(NewProp_Sockets, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_Sockets, TEXT("ToolTip"), TEXT("Array of named socket locations, set up in editor and used as a shortcut instead of specifying\neverything explicitly to AttachComponent in the SkeletalMeshComponent."));
				MetaData->SetValue(NewProp_AssetUserData, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_AssetUserData, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_AssetUserData, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_AssetUserData, TEXT("ToolTip"), TEXT("Array of user data stored with the asset"));
				MetaData->SetValue(NewProp_AssetUserData_Inner, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_AssetUserData_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_AssetUserData_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_AssetUserData_Inner, TEXT("ToolTip"), TEXT("Array of user data stored with the asset"));
				MetaData->SetValue(NewProp_ClothingAssets, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_ClothingAssets, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_ClothingAssets, TEXT("ToolTip"), TEXT("Clothing asset data"));
				MetaData->SetValue(NewProp_RetargetBasePose, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_RetargetBasePose, TEXT("ToolTip"), TEXT("This is buffer that saves pose that is used by retargeting"));
				MetaData->SetValue(NewProp_FloorOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_FloorOffset, TEXT("ToolTip"), TEXT("Height offset for the floor mesh in the editor"));
				MetaData->SetValue(NewProp_SelectedClothingSection, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SelectedClothingSection, TEXT("ToolTip"), TEXT("The section currently selected for clothing. need to remember this index for reimporting cloth"));
				MetaData->SetValue(NewProp_SelectedEditorSection, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SelectedEditorSection, TEXT("ToolTip"), TEXT("The section currently selected in the Editor."));
				MetaData->SetValue(NewProp_MorphTargets, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_MorphTargets, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("Category"), TEXT("TextureStreaming"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ToolTip"), TEXT("Allows artists to adjust the distance where textures using UV 0 are streamed in/out.\n1.0 is the default, whereas a higher value increases the streamed-in resolution.\nValue can be < 0 (from legcay content, or code changes)"));
				MetaData->SetValue(NewProp_PreviewAttachedAssetContainer, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_PreviewAttachedAssetContainer, TEXT("ToolTip"), TEXT("Attached assets component for this mesh"));
				MetaData->SetValue(NewProp_OptimizationSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_OptimizationSettings, TEXT("ToolTip"), TEXT("Optimization settings used to simplify LODs of this mesh."));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("Category"), TEXT("Thumbnail"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("ToolTip"), TEXT("Information for thumbnail rendering"));
				MetaData->SetValue(NewProp_SourceFileTimestamp, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SourceFileTimestamp, TEXT("ToolTip"), TEXT("Date/Time-stamp of the file from the last import"));
				MetaData->SetValue(NewProp_SourceFilePath, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SourceFilePath, TEXT("ToolTip"), TEXT("Path to the resource used to construct this skeletal mesh"));
				MetaData->SetValue(NewProp_AssetImportData, TEXT("Category"), TEXT("ImportSettings"));
				MetaData->SetValue(NewProp_AssetImportData, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_AssetImportData, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_AssetImportData, TEXT("ToolTip"), TEXT("Importing data and options used for this mesh"));
				MetaData->SetValue(NewProp_PhysicsAsset, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_PhysicsAsset, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_PhysicsAsset, TEXT("ToolTip"), TEXT("Physics and collision information used for this USkeletalMesh, set up in PhAT.\nThis is used for per-bone hit detection, accurate bounding box calculation and ragdoll physics for example."));
				MetaData->SetValue(NewProp_BodySetup, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_BodySetup, TEXT("ToolTip"), TEXT("Physics data for the per poly collision case. In 99% of cases you will not need this and are better off using simple ragdoll collision (physics asset)"));
				MetaData->SetValue(NewProp_bEnablePerPolyCollision, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_bEnablePerPolyCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_bEnablePerPolyCollision, TEXT("ToolTip"), TEXT("Uses skinned data for collision data. Per poly collision cannot be used for simulation, in most cases you are better off using the physics asset"));
				MetaData->SetValue(NewProp_bHasVertexColors, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_bHasVertexColors, TEXT("ToolTip"), TEXT("Whether or not the mesh has vertex colors"));
				MetaData->SetValue(NewProp_bHasBeenSimplified, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_bHasBeenSimplified, TEXT("ToolTip"), TEXT("true if this mesh has ever been simplified with Simplygon."));
				MetaData->SetValue(NewProp_bUseFullPrecisionUVs, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_bUseFullPrecisionUVs, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_bUseFullPrecisionUVs, TEXT("ToolTip"), TEXT("If true, use 32 bit UVs. If false, use 16 bit UVs to save memory"));
				MetaData->SetValue(NewProp_LODInfo, TEXT("Category"), TEXT("LevelOfDetail"));
				MetaData->SetValue(NewProp_LODInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_LODInfo, TEXT("ToolTip"), TEXT("Struct containing information for each LOD level, such as materials to use, and when use the LOD."));
				MetaData->SetValue(NewProp_SkelMirrorFlipAxis, TEXT("Category"), TEXT("Mirroring"));
				MetaData->SetValue(NewProp_SkelMirrorFlipAxis, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SkelMirrorAxis, TEXT("Category"), TEXT("Mirroring"));
				MetaData->SetValue(NewProp_SkelMirrorAxis, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SkelMirrorTable, TEXT("Category"), TEXT("Mirroring"));
				MetaData->SetValue(NewProp_SkelMirrorTable, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_SkelMirrorTable, TEXT("ToolTip"), TEXT("List of bones that should be mirrored."));
				MetaData->SetValue(NewProp_Materials, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_Materials, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_Materials, TEXT("ToolTip"), TEXT("List of materials applied to this mesh."));
				MetaData->SetValue(NewProp_Bounds, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_Skeleton, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_Skeleton, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SkeletalMesh.h"));
				MetaData->SetValue(NewProp_Skeleton, TEXT("ToolTip"), TEXT("Skeleton of this skeletal mesh *"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkeletalMesh(Z_Construct_UClass_USkeletalMesh, TEXT("USkeletalMesh"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkeletalMesh);
	UEnum* Z_Construct_UEnum_Engine_EAnimGroupRole()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAnimGroupRole_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAnimGroupRole"), 0, Get_Z_Construct_UEnum_Engine_EAnimGroupRole_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAnimGroupRole"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimGroupRole::CanBeLeader")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimGroupRole::AlwaysFollower")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimGroupRole::AlwaysLeader")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimGroupRole::EAnimGroupRole_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AlwaysFollower.ToolTip"), TEXT("This node will always be a follower (unless there are only followers, in which case the first one ticked wins)."));
			MetaData->SetValue(ReturnEnum, TEXT("AlwaysLeader.ToolTip"), TEXT("This node will always be a leader (if more than one node is AlwaysLeader, the last one ticked wins)."));
			MetaData->SetValue(ReturnEnum, TEXT("CanBeLeader.ToolTip"), TEXT("This node can be the leader, as long as it has a higher blend weight than the previous best leader."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAnimGroupRole_CRC() { return 2025464696U; }
	UEnum* Z_Construct_UEnum_Engine_ERootMotionMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ERootMotionMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ERootMotionMode"), 0, Get_Z_Construct_UEnum_Engine_ERootMotionMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ERootMotionMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionMode::NoRootMotionExtraction")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionMode::IgnoreRootMotion")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionMode::RootMotionFromEverything")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionMode::RootMotionFromMontagesOnly")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionMode::ERootMotionMode_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("IgnoreRootMotion.ToolTip"), TEXT("Extract root motion but do not apply it."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(ReturnEnum, TEXT("NoRootMotionExtraction.ToolTip"), TEXT("Leave root motion in animation."));
			MetaData->SetValue(ReturnEnum, TEXT("RootMotionFromEverything.ToolTip"), TEXT("Root motion is taken from all animations contributing to the final pose, not suitable for network multiplayer setups."));
			MetaData->SetValue(ReturnEnum, TEXT("RootMotionFromMontagesOnly.ToolTip"), TEXT("Root motion is only taken from montages, suitable for network multiplayer setups."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ERootMotionMode_CRC() { return 632906700U; }
	UEnum* Z_Construct_UEnum_Engine_ERootMotionRootLock()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ERootMotionRootLock_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ERootMotionRootLock"), 0, Get_Z_Construct_UEnum_Engine_ERootMotionRootLock_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ERootMotionRootLock"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionRootLock::RefPose")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionRootLock::AnimFirstFrame")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionRootLock::Zero")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ERootMotionRootLock::ERootMotionRootLock_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AnimFirstFrame.ToolTip"), TEXT("Use root bone position on first frame of animation."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(ReturnEnum, TEXT("RefPose.ToolTip"), TEXT("Use reference pose root bone position."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Root Bone Lock options when extracting Root Motion."));
			MetaData->SetValue(ReturnEnum, TEXT("Zero.ToolTip"), TEXT("FTransform::Identity."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ERootMotionRootLock_CRC() { return 114161384U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimationGroupReference()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimationGroupReference_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimationGroupReference"), sizeof(FAnimationGroupReference), Get_Z_Construct_UScriptStruct_FAnimationGroupReference_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimationGroupReference"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimationGroupReference>, EStructFlags(0x00000001));
			UProperty* NewProp_GroupRole = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GroupRole"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(GroupRole, FAnimationGroupReference), 0x0000000000000001, Z_Construct_UEnum_Engine_EAnimGroupRole());
			UProperty* NewProp_GroupName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GroupName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(GroupName, FAnimationGroupReference), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_GroupRole, TEXT("Category"), TEXT("Settings"));
			MetaData->SetValue(NewProp_GroupRole, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_GroupRole, TEXT("ToolTip"), TEXT("The type of membership in the group (potential leader, always follower, etc...)"));
			MetaData->SetValue(NewProp_GroupName, TEXT("Category"), TEXT("Settings"));
			MetaData->SetValue(NewProp_GroupName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_GroupName, TEXT("ToolTip"), TEXT("The name of the group"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimationGroupReference_CRC() { return 2734549771U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRootMotionMovementParams()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FRootMotionMovementParams_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("RootMotionMovementParams"), sizeof(FRootMotionMovementParams), Get_Z_Construct_UScriptStruct_FRootMotionMovementParams_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RootMotionMovementParams"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRootMotionMovementParams>, EStructFlags(0x00000001));
			UProperty* NewProp_RootMotionTransform = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RootMotionTransform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RootMotionTransform, FRootMotionMovementParams), 0x0000000000000000, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_BlendWeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BlendWeight, FRootMotionMovementParams), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasRootMotion, FRootMotionMovementParams, bool);
			UProperty* NewProp_bHasRootMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bHasRootMotion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasRootMotion, FRootMotionMovementParams), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasRootMotion, FRootMotionMovementParams), sizeof(bool), true);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Utility struct to accumulate root motion."));
			MetaData->SetValue(NewProp_RootMotionTransform, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_BlendWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_bHasRootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRootMotionMovementParams_CRC() { return 2673057231U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimGroupInstance()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimGroupInstance_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimGroupInstance"), sizeof(FAnimGroupInstance), Get_Z_Construct_UScriptStruct_FAnimGroupInstance_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimGroupInstance"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimGroupInstance>, EStructFlags(0x00000001));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimGroupInstance_CRC() { return 2755222579U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimTickRecord()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimTickRecord_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimTickRecord"), sizeof(FAnimTickRecord), Get_Z_Construct_UScriptStruct_FAnimTickRecord_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimTickRecord"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimTickRecord>, EStructFlags(0x00000001));
			UProperty* NewProp_SourceAsset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SourceAsset"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SourceAsset, FAnimTickRecord), 0x0000000000000000, Z_Construct_UClass_UAnimationAsset_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Information about an animation asset that needs to be ticked"));
			MetaData->SetValue(NewProp_SourceAsset, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimTickRecord_CRC() { return 1606245893U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimExtractContext()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimExtractContext_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimExtractContext"), sizeof(FAnimExtractContext), Get_Z_Construct_UScriptStruct_FAnimExtractContext_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimExtractContext"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimExtractContext>, EStructFlags(0x00000001));
			UProperty* NewProp_CurrentTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CurrentTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CurrentTime, FAnimExtractContext), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bExtractRootMotion, FAnimExtractContext, bool);
			UProperty* NewProp_bExtractRootMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bExtractRootMotion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bExtractRootMotion, FAnimExtractContext), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bExtractRootMotion, FAnimExtractContext), sizeof(bool), true);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Animation Extraction Context"));
			MetaData->SetValue(NewProp_CurrentTime, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_CurrentTime, TEXT("ToolTip"), TEXT("Position in animation to extract pose from"));
			MetaData->SetValue(NewProp_bExtractRootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_bExtractRootMotion, TEXT("ToolTip"), TEXT("Is Root Motion being extracted?"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimExtractContext_CRC() { return 3430569258U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBlendFilter()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBlendFilter_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BlendFilter"), sizeof(FBlendFilter), Get_Z_Construct_UScriptStruct_FBlendFilter_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlendFilter"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBlendFilter>, EStructFlags(0x00000001));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBlendFilter_CRC() { return 1110508334U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBlendSampleData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBlendSampleData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BlendSampleData"), sizeof(FBlendSampleData), Get_Z_Construct_UScriptStruct_FBlendSampleData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlendSampleData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBlendSampleData>, EStructFlags(0x00000001));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, FBlendSampleData), 0x0000000000000000);
			UProperty* NewProp_TotalWeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TotalWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TotalWeight, FBlendSampleData), 0x0000000000000000);
			UProperty* NewProp_SampleDataIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SampleDataIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SampleDataIndex, FBlendSampleData), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Transform definition"));
			MetaData->SetValue(NewProp_Time, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_TotalWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
			MetaData->SetValue(NewProp_SampleDataIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBlendSampleData_CRC() { return 671526929U; }
	UClass* Z_Construct_UClass_UAnimationAsset_NoRegister()
	{
		return UAnimationAsset::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimationAsset()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = UAnimationAsset::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_PreviewSkeletalMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewSkeletalMesh"), RF_Public|RF_Transient|RF_Native) UAssetObjectProperty(CPP_PROPERTY_BASE(PreviewSkeletalMesh, UAnimationAsset), 0x0004010800200000, Z_Construct_UClass_USkeletalMesh_NoRegister());
				UProperty* NewProp_ThumbnailInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailInfo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ThumbnailInfo, UAnimationAsset), 0x00020008000a0009, Z_Construct_UClass_UThumbnailInfo_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_MetaData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MetaData"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(MetaData, UAnimationAsset), 0x0000008000000009);
				UProperty* NewProp_MetaData_Inner = new(EC_InternalUseOnlyConstructor, NewProp_MetaData, TEXT("MetaData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UAnimMetaData_NoRegister());
				UProperty* NewProp_Skeleton = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Skeleton"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Skeleton, UAnimationAsset), 0x0000010000020001, Z_Construct_UClass_USkeleton_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Animation/AnimationAsset.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
				MetaData->SetValue(NewProp_PreviewSkeletalMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
				MetaData->SetValue(NewProp_PreviewSkeletalMesh, TEXT("ToolTip"), TEXT("The default skeletal mesh to use when previewing this asset - this only applies when you open Persona using this asset"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("Category"), TEXT("Thumbnail"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("ToolTip"), TEXT("Information for thumbnail rendering"));
				MetaData->SetValue(NewProp_MetaData, TEXT("Category"), TEXT("MetaData"));
				MetaData->SetValue(NewProp_MetaData, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MetaData, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
				MetaData->SetValue(NewProp_MetaData, TEXT("ToolTip"), TEXT("Meta data that can be saved with the asset\n\nYou can query by GetMetaData function"));
				MetaData->SetValue(NewProp_MetaData_Inner, TEXT("Category"), TEXT("MetaData"));
				MetaData->SetValue(NewProp_MetaData_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MetaData_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
				MetaData->SetValue(NewProp_MetaData_Inner, TEXT("ToolTip"), TEXT("Meta data that can be saved with the asset\n\nYou can query by GetMetaData function"));
				MetaData->SetValue(NewProp_Skeleton, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_Skeleton, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimationAsset.h"));
				MetaData->SetValue(NewProp_Skeleton, TEXT("ToolTip"), TEXT("Pointer to the Skeleton this asset can be played on ."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimationAsset(Z_Construct_UClass_UAnimationAsset, TEXT("UAnimationAsset"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimationAsset);
	UFunction* Z_Construct_UDelegateFunction_Engine_CharacterReachedApexSignature__DelegateSignature()
	{
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CharacterReachedApexSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_CharacterMovementUpdatedSignature__DelegateSignature()
	{
		struct _Script_Engine_eventCharacterMovementUpdatedSignature_Parms
		{
			float DeltaSeconds;
			FVector OldLocation;
			FVector OldVelocity;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CharacterMovementUpdatedSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventCharacterMovementUpdatedSignature_Parms));
			UProperty* NewProp_OldVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OldVelocity, _Script_Engine_eventCharacterMovementUpdatedSignature_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OldLocation, _Script_Engine_eventCharacterMovementUpdatedSignature_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DeltaSeconds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaSeconds"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DeltaSeconds, _Script_Engine_eventCharacterMovementUpdatedSignature_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_MovementModeChangedSignature__DelegateSignature()
	{
		struct _Script_Engine_eventMovementModeChangedSignature_Parms
		{
			ACharacter* Character;
			TEnumAsByte<EMovementMode> PrevMovementMode;
			uint8 PreviousCustomMode;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MovementModeChangedSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventMovementModeChangedSignature_Parms));
			UProperty* NewProp_PreviousCustomMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreviousCustomMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PreviousCustomMode, _Script_Engine_eventMovementModeChangedSignature_Parms), 0x0000000000000080);
			UProperty* NewProp_PrevMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PrevMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PrevMovementMode, _Script_Engine_eventMovementModeChangedSignature_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EMovementMode());
			UProperty* NewProp_Character = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Character"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Character, _Script_Engine_eventMovementModeChangedSignature_Parms), 0x0000000000000080, Z_Construct_UClass_ACharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
		}
		return ReturnFunction;
	}
	UScriptStruct* Z_Construct_UScriptStruct_FBasedMovementInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBasedMovementInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BasedMovementInfo"), sizeof(FBasedMovementInfo), Get_Z_Construct_UScriptStruct_FBasedMovementInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BasedMovementInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBasedMovementInfo>, EStructFlags(0x00000005));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bServerHasVelocity, FBasedMovementInfo, bool);
			UProperty* NewProp_bServerHasVelocity = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bServerHasVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bServerHasVelocity, FBasedMovementInfo), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bServerHasVelocity, FBasedMovementInfo), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRelativeRotation, FBasedMovementInfo, bool);
			UProperty* NewProp_bRelativeRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bRelativeRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRelativeRotation, FBasedMovementInfo), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bRelativeRotation, FBasedMovementInfo), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bServerHasBaseComponent, FBasedMovementInfo, bool);
			UProperty* NewProp_bServerHasBaseComponent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bServerHasBaseComponent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bServerHasBaseComponent, FBasedMovementInfo), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bServerHasBaseComponent, FBasedMovementInfo), sizeof(bool), true);
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Rotation, FBasedMovementInfo), 0x0000000000000000, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, FBasedMovementInfo), 0x0000000000000000, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, FBasedMovementInfo), 0x0000000000000000);
			UProperty* NewProp_MovementBase = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MovementBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MovementBase, FBasedMovementInfo), 0x0000000000080008, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct to hold information about the \"base\" object the character is standing on."));
			MetaData->SetValue(NewProp_bServerHasVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_bServerHasVelocity, TEXT("ToolTip"), TEXT("Whether there is a velocity on the server. Used for forcing replication when velocity goes to zero."));
			MetaData->SetValue(NewProp_bRelativeRotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_bRelativeRotation, TEXT("ToolTip"), TEXT("Whether rotation is relative to the base or absolute. It can only be relative if location is also relative."));
			MetaData->SetValue(NewProp_bServerHasBaseComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_bServerHasBaseComponent, TEXT("ToolTip"), TEXT("Whether the server says that there is a base. On clients, the component may not have resolved yet."));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ToolTip"), TEXT("Rotation: relative to MovementBase if HasRelativeRotation() is true, absolute otherwise."));
			MetaData->SetValue(NewProp_Location, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_Location, TEXT("ToolTip"), TEXT("Location relative to MovementBase. Only valid if HasRelativeLocation() is true."));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ToolTip"), TEXT("Bone name on component, for skeletal meshes. NAME_None if not a skeletal mesh or if bone is invalid."));
			MetaData->SetValue(NewProp_MovementBase, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_MovementBase, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_MovementBase, TEXT("ToolTip"), TEXT("Component we are based on"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBasedMovementInfo_CRC() { return 2931292710U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSimulatedRootMotionReplicatedMove()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSimulatedRootMotionReplicatedMove_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SimulatedRootMotionReplicatedMove"), sizeof(FSimulatedRootMotionReplicatedMove), Get_Z_Construct_UScriptStruct_FSimulatedRootMotionReplicatedMove_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulatedRootMotionReplicatedMove"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSimulatedRootMotionReplicatedMove>, EStructFlags(0x00000005));
			UProperty* NewProp_RootMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RootMotion"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RootMotion, FSimulatedRootMotionReplicatedMove), 0x0000008000000000, Z_Construct_UScriptStruct_FRepRootMotionMontage());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, FSimulatedRootMotionReplicatedMove), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_RootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_RootMotion, TEXT("ToolTip"), TEXT("Root Motion information"));
			MetaData->SetValue(NewProp_Time, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_Time, TEXT("ToolTip"), TEXT("Local time when move was received on client and saved."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSimulatedRootMotionReplicatedMove_CRC() { return 1644344621U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRepRootMotionMontage()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FRepRootMotionMontage_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("RepRootMotionMontage"), sizeof(FRepRootMotionMontage), Get_Z_Construct_UScriptStruct_FRepRootMotionMontage_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RepRootMotionMontage"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRepRootMotionMontage>, EStructFlags(0x00000005));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRelativeRotation, FRepRootMotionMontage, bool);
			UProperty* NewProp_bRelativeRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bRelativeRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRelativeRotation, FRepRootMotionMontage), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bRelativeRotation, FRepRootMotionMontage), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRelativePosition, FRepRootMotionMontage, bool);
			UProperty* NewProp_bRelativePosition = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bRelativePosition"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRelativePosition, FRepRootMotionMontage), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bRelativePosition, FRepRootMotionMontage), sizeof(bool), true);
			UProperty* NewProp_MovementBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MovementBaseBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(MovementBaseBoneName, FRepRootMotionMontage), 0x0000000000000000);
			UProperty* NewProp_MovementBase = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MovementBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MovementBase, FRepRootMotionMontage), 0x0000000000080008, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Rotation, FRepRootMotionMontage), 0x0000000000000000, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, FRepRootMotionMontage), 0x0000000000000000, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Position, FRepRootMotionMontage), 0x0000000000000000);
			UProperty* NewProp_AnimMontage = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimMontage"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimMontage, FRepRootMotionMontage), 0x0000000000000000, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Replicated data when playing a root motion montage."));
			MetaData->SetValue(NewProp_bRelativeRotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_bRelativeRotation, TEXT("ToolTip"), TEXT("Whether rotation is relative or absolute."));
			MetaData->SetValue(NewProp_bRelativePosition, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_bRelativePosition, TEXT("ToolTip"), TEXT("Additional replicated flag, if MovementBase can't be resolved on the client. So we don't use wrong data."));
			MetaData->SetValue(NewProp_MovementBaseBoneName, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_MovementBaseBoneName, TEXT("ToolTip"), TEXT("Bone on the MovementBase, if a skeletal mesh."));
			MetaData->SetValue(NewProp_MovementBase, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_MovementBase, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_MovementBase, TEXT("ToolTip"), TEXT("Movement Relative to Base"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ToolTip"), TEXT("Rotation"));
			MetaData->SetValue(NewProp_Location, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_Location, TEXT("ToolTip"), TEXT("Location"));
			MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_Position, TEXT("ToolTip"), TEXT("Track position of Montage"));
			MetaData->SetValue(NewProp_AnimMontage, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(NewProp_AnimMontage, TEXT("ToolTip"), TEXT("AnimMontage providing Root Motion"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRepRootMotionMontage_CRC() { return 1705529407U; }
	UFunction* Z_Construct_UFunction_ACharacter_CanJump()
	{
		struct Character_eventCanJump_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanJump"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(Character_eventCanJump_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, Character_eventCanJump_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, Character_eventCanJump_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, Character_eventCanJump_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the character can jump in the current state.\n\nThe default implementation may be overridden or extended by implementing the custom CanJump event in Blueprints.\n\n@Return Whether the character can jump in the current state."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_CanJumpInternal()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanJumpInternal"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x48080C00, 65535, sizeof(Character_eventCanJumpInternal_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, Character_eventCanJumpInternal_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, Character_eventCanJumpInternal_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, Character_eventCanJumpInternal_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("CanJump"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Customizable event to check if the character can jump in the current state.\nDefault implementation returns true if the character is on the ground and not crouching,\nhas a valid CharacterMovementComponent and CanEverJump() returns true.\nDefault implementation also allows for 'hold to jump higher' functionality:\nAs well as returning true when on the ground, it also returns true when GetMaxJumpTime is more\nthan zero and IsJumping returns true.\n\n\n@Return Whether the character can jump in the current state."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_ClientCheatFly()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientCheatFly"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01020CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_ClientCheatGhost()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientCheatGhost"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01020CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_ClientCheatWalk()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientCheatWalk"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01020CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_Crouch()
	{
		struct Character_eventCrouch_Parms
		{
			bool bClientSimulation;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Crouch"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(Character_eventCrouch_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClientSimulation, Character_eventCrouch_Parms, bool);
			UProperty* NewProp_bClientSimulation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bClientSimulation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClientSimulation, Character_eventCrouch_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bClientSimulation, Character_eventCrouch_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bClientSimulation"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("HidePin"), TEXT("bClientSimulation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Request the character to start crouching. The request is processed on the next update of the CharacterMovementComponent.\n@see OnStartCrouch\n@see IsCrouched\n@see CharacterMovement->WantsToCrouch"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_GetCurrentMontage()
	{
		struct Character_eventGetCurrentMontage_Parms
		{
			UAnimMontage* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentMontage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(Character_eventGetCurrentMontage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, Character_eventGetCurrentMontage_Parms), 0x0000000000000580, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return current playing Montage *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_IsJumpProvidingForce()
	{
		struct Character_eventIsJumpProvidingForce_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsJumpProvidingForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(Character_eventIsJumpProvidingForce_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, Character_eventIsJumpProvidingForce_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, Character_eventIsJumpProvidingForce_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, Character_eventIsJumpProvidingForce_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("True if jump is actively providing a force, such as when the jump key is held and the time it has been held is less than JumpMaxHoldTime.\n@see CharacterMovement->IsFalling"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_IsPlayingNetworkedRootMotionMontage()
	{
		struct Character_eventIsPlayingNetworkedRootMotionMontage_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsPlayingNetworkedRootMotionMontage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(Character_eventIsPlayingNetworkedRootMotionMontage_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, Character_eventIsPlayingNetworkedRootMotionMontage_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, Character_eventIsPlayingNetworkedRootMotionMontage_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, Character_eventIsPlayingNetworkedRootMotionMontage_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("true if we are playing Root Motion right now, through a Montage with RootMotionMode == ERootMotionMode::RootMotionFromMontagesOnly.\nThis means code path for networked root motion is enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_IsPlayingRootMotion()
	{
		struct Character_eventIsPlayingRootMotion_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsPlayingRootMotion"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(Character_eventIsPlayingRootMotion_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, Character_eventIsPlayingRootMotion_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, Character_eventIsPlayingRootMotion_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, Character_eventIsPlayingRootMotion_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("true if we are playing Root Motion right now"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_Jump()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Jump"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Make the character jump on the next update.\nIf you want your character to jump according to the time that the jump key is held,\nthen you can set JumpKeyHoldTime to some non-zero value. Make sure in this case to\ncall StopJumping() when you want the jump's z-velocity to stop being applied (such\nas on a button up event), otherwise the character will carry on receiving the\nvelocity until JumpKeyHoldTime is reached."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_K2_OnEndCrouch()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_OnEndCrouch"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(Character_eventK2_OnEndCrouch_Parms));
			UProperty* NewProp_ScaledHalfHeightAdjust = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ScaledHalfHeightAdjust"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaledHalfHeightAdjust, Character_eventK2_OnEndCrouch_Parms), 0x0000000000000080);
			UProperty* NewProp_HalfHeightAdjust = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeightAdjust"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HalfHeightAdjust, Character_eventK2_OnEndCrouch_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("OnEndCrouch"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event when Character stops crouching.\n@param       HalfHeightAdjust                difference between default collision half-height, and actual crouched capsule half-height.\n@param       ScaledHalfHeightAdjust  difference after component scale is taken in to account."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_K2_OnMovementModeChanged()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_OnMovementModeChanged"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(Character_eventK2_OnMovementModeChanged_Parms));
			UProperty* NewProp_NewCustomMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewCustomMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewCustomMode, Character_eventK2_OnMovementModeChanged_Parms), 0x0000000000000080);
			UProperty* NewProp_PrevCustomMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PrevCustomMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PrevCustomMode, Character_eventK2_OnMovementModeChanged_Parms), 0x0000000000000080);
			UProperty* NewProp_NewMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewMovementMode, Character_eventK2_OnMovementModeChanged_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EMovementMode());
			UProperty* NewProp_PrevMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PrevMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PrevMovementMode, Character_eventK2_OnMovementModeChanged_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("OnMovementModeChanged"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called from CharacterMovementComponent to notify the character that the movement mode has changed.\n@param       PrevMovementMode        Movement mode before the change\n@param       NewMovementMode         New movement mode\n@param       PrevCustomMode          Custom mode before the change (applicable if PrevMovementMode is Custom)\n@param       NewCustomMode           New custom mode (applicable if NewMovementMode is Custom)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_K2_OnStartCrouch()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_OnStartCrouch"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(Character_eventK2_OnStartCrouch_Parms));
			UProperty* NewProp_ScaledHalfHeightAdjust = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ScaledHalfHeightAdjust"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaledHalfHeightAdjust, Character_eventK2_OnStartCrouch_Parms), 0x0000000000000080);
			UProperty* NewProp_HalfHeightAdjust = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeightAdjust"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HalfHeightAdjust, Character_eventK2_OnStartCrouch_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("OnStartCrouch"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event when Character crouches.\n@param       HalfHeightAdjust                difference between default collision half-height, and actual crouched capsule half-height.\n@param       ScaledHalfHeightAdjust  difference after component scale is taken in to account."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_K2_UpdateCustomMovement()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_UpdateCustomMovement"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(Character_eventK2_UpdateCustomMovement_Parms));
			UProperty* NewProp_DeltaTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DeltaTime, Character_eventK2_UpdateCustomMovement_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("UpdateCustomMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event for implementing custom character movement mode. Called by CharacterMovement if MovementMode is set to Custom.\n@note C++ code should override UCharacterMovementComponent::PhysCustom() instead.\n@see UCharacterMovementComponent::PhysCustom()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_LaunchCharacter()
	{
		struct Character_eventLaunchCharacter_Parms
		{
			FVector LaunchVelocity;
			bool bXYOverride;
			bool bZOverride;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LaunchCharacter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(Character_eventLaunchCharacter_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bZOverride, Character_eventLaunchCharacter_Parms, bool);
			UProperty* NewProp_bZOverride = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bZOverride"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bZOverride, Character_eventLaunchCharacter_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bZOverride, Character_eventLaunchCharacter_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bXYOverride, Character_eventLaunchCharacter_Parms, bool);
			UProperty* NewProp_bXYOverride = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bXYOverride"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bXYOverride, Character_eventLaunchCharacter_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bXYOverride, Character_eventLaunchCharacter_Parms), sizeof(bool), true);
			UProperty* NewProp_LaunchVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LaunchVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LaunchVelocity, Character_eventLaunchCharacter_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a pending launch velocity on the Character. This velocity will be processed on the next CharacterMovementComponent tick,\nand will set it to the \"falling\" state. Triggers the OnLaunched event.\n@PARAM LaunchVelocity is the velocity to impart to the Character\n@PARAM bXYOverride if true replace the XY part of the Character's velocity instead of adding to it.\n@PARAM bZOverride if true replace the Z component of the Character's velocity instead of adding to it."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnJumped()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnJumped"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event fired when the character has just started jumping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnLanded()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnLanded"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(Character_eventOnLanded_Parms));
			UProperty* NewProp_Hit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Hit"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Hit, Character_eventOnLanded_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called upon landing when falling, to perform actions based on the Hit result.\nNote that movement mode is still \"Falling\" during this event. Current Velocity value is the velocity at the time of landing.\nConsider OnMovementModeChanged() as well, as that can be used once the movement mode changes to the new mode (most likely Walking).\n\n@param Hit Result describing the landing that resulted in a valid landing spot.\n@see OnMovementModeChanged()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnLaunched()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnLaunched"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08820800, 65535, sizeof(Character_eventOnLaunched_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bZOverride, Character_eventOnLaunched_Parms, bool);
			UProperty* NewProp_bZOverride = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bZOverride"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bZOverride, Character_eventOnLaunched_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bZOverride, Character_eventOnLaunched_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bXYOverride, Character_eventOnLaunched_Parms, bool);
			UProperty* NewProp_bXYOverride = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bXYOverride"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bXYOverride, Character_eventOnLaunched_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bXYOverride, Character_eventOnLaunched_Parms), sizeof(bool), true);
			UProperty* NewProp_LaunchVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LaunchVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LaunchVelocity, Character_eventOnLaunched_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Let blueprint know that we were launched"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnRep_IsCrouched()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_IsCrouched"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Handle Crouching replicated from server"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnRep_ReplicatedBasedMovement()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedBasedMovement"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Rep notify for ReplicatedBasedMovement"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnRep_RootMotion()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_RootMotion"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Handles replicated root motion properties on simulated proxies and position correction."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_OnWalkingOffLedge()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnWalkingOffLedge"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08C20C00, 65535, sizeof(Character_eventOnWalkingOffLedge_Parms));
			UProperty* NewProp_TimeDelta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeDelta"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeDelta, Character_eventOnWalkingOffLedge_Parms), 0x0000000000000080);
			UProperty* NewProp_PreviousLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreviousLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviousLocation, Character_eventOnWalkingOffLedge_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PreviousFloorContactNormal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreviousFloorContactNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviousFloorContactNormal, Character_eventOnWalkingOffLedge_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PreviousFloorImpactNormal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreviousFloorImpactNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviousFloorImpactNormal, Character_eventOnWalkingOffLedge_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event fired when the Character is walking off a surface and is about to fall because CharacterMovement->CurrentFloor became unwalkable.\nIf CharacterMovement->MovementMode does not change during this event then the character will automatically start falling afterwards.\n@note Z velocity is zero during walking movement, and will be here as well. Another velocity can be computed here if desired and will be used when starting to fall.\n\n@param  PreviousFloorImpactNormal Normal of the previous walkable floor.\n@param  PreviousFloorContactNormal Normal of the contact with the previous walkable floor.\n@param  PreviousLocation     Previous character location before movement off the ledge.\n@param  TimeTick     Time delta of movement update resulting in moving off the ledge."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_PlayAnimMontage()
	{
		struct Character_eventPlayAnimMontage_Parms
		{
			UAnimMontage* AnimMontage;
			float InPlayRate;
			FName StartSectionName;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayAnimMontage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(Character_eventPlayAnimMontage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, Character_eventPlayAnimMontage_Parms), 0x0000000000000580);
			UProperty* NewProp_StartSectionName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartSectionName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(StartSectionName, Character_eventPlayAnimMontage_Parms), 0x0000000000000080);
			UProperty* NewProp_InPlayRate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPlayRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InPlayRate, Character_eventPlayAnimMontage_Parms), 0x0000000000000080);
			UProperty* NewProp_AnimMontage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AnimMontage"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimMontage, Character_eventPlayAnimMontage_Parms), 0x0000000000000080, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_InPlayRate"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_StartSectionName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Play Animation Montage on the character mesh *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_SetReplicateMovement()
	{
		struct Character_eventSetReplicateMovement_Parms
		{
			bool bInReplicateMovement;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetReplicateMovement"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(Character_eventSetReplicateMovement_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInReplicateMovement, Character_eventSetReplicateMovement_Parms, bool);
			UProperty* NewProp_bInReplicateMovement = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInReplicateMovement"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInReplicateMovement, Character_eventSetReplicateMovement_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bInReplicateMovement, Character_eventSetReplicateMovement_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Replication"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set whether this actor's movement replicates to network clients."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_StopAnimMontage()
	{
		struct Character_eventStopAnimMontage_Parms
		{
			UAnimMontage* AnimMontage;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopAnimMontage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(Character_eventStopAnimMontage_Parms));
			UProperty* NewProp_AnimMontage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AnimMontage"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimMontage, Character_eventStopAnimMontage_Parms), 0x0000000000000080, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stop Animation Montage. If NULL, it will stop what's currently active *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_StopJumping()
	{
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopJumping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stop the character from jumping on the next update.\nCall this from an input event (such as a button 'up' event) to cease applying\njump Z-velocity. If this is not called, then jump z-velocity will be applied\nuntil JumpMaxHoldTime is reached."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACharacter_UnCrouch()
	{
		struct Character_eventUnCrouch_Parms
		{
			bool bClientSimulation;
		};
		UObject* Outer=Z_Construct_UClass_ACharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UnCrouch"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(Character_eventUnCrouch_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClientSimulation, Character_eventUnCrouch_Parms, bool);
			UProperty* NewProp_bClientSimulation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bClientSimulation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClientSimulation, Character_eventUnCrouch_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bClientSimulation, Character_eventUnCrouch_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Character"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bClientSimulation"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("HidePin"), TEXT("bClientSimulation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Request the character to stop crouching. The request is processed on the next update of the CharacterMovementComponent.\n@see OnEndCrouch\n@see IsCrouched\n@see CharacterMovement->WantsToCrouch"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ACharacter_NoRegister()
	{
		return ACharacter::StaticClass();
	}
	UClass* Z_Construct_UClass_ACharacter()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APawn();
			Z_Construct_UPackage_Engine();
			OuterClass = ACharacter::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_CanJump());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_CanJumpInternal());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_ClientCheatFly());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_ClientCheatGhost());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_ClientCheatWalk());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_Crouch());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_GetCurrentMontage());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_IsJumpProvidingForce());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_IsPlayingNetworkedRootMotionMontage());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_IsPlayingRootMotion());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_Jump());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_K2_OnEndCrouch());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_K2_OnMovementModeChanged());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_K2_OnStartCrouch());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_K2_UpdateCustomMovement());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_LaunchCharacter());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnJumped());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnLanded());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnLaunched());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnRep_IsCrouched());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnRep_ReplicatedBasedMovement());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnRep_RootMotion());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_OnWalkingOffLedge());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_PlayAnimMontage());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_SetReplicateMovement());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_StopAnimMontage());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_StopJumping());
				OuterClass->LinkChild(Z_Construct_UFunction_ACharacter_UnCrouch());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_RepRootMotion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RepRootMotion"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RepRootMotion, ACharacter), 0x0000008100000020, Z_Construct_UScriptStruct_FRepRootMotionMontage());
				NewProp_RepRootMotion->RepNotifyFunc = FName(TEXT("OnRep_RootMotion"));
				UProperty* NewProp_RootMotionRepMoves = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RootMotionRepMoves"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(RootMotionRepMoves, ACharacter), 0x0000008000002000);
				UProperty* NewProp_RootMotionRepMoves_Inner = new(EC_InternalUseOnlyConstructor, NewProp_RootMotionRepMoves, TEXT("RootMotionRepMoves"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FSimulatedRootMotionReplicatedMove());
				UProperty* NewProp_ClientRootMotionParams = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClientRootMotionParams"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ClientRootMotionParams, ACharacter), 0x0000000000002000, Z_Construct_UScriptStruct_FRootMotionMovementParams());
				UProperty* NewProp_OnCharacterMovementUpdated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnCharacterMovementUpdated"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnCharacterMovementUpdated, ACharacter), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_CharacterMovementUpdatedSignature__DelegateSignature());
				UProperty* NewProp_OnReachedJumpApex = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnReachedJumpApex"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnReachedJumpApex, ACharacter), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_CharacterReachedApexSignature__DelegateSignature());
				UProperty* NewProp_JumpMaxHoldTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("JumpMaxHoldTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(JumpMaxHoldTime, ACharacter), 0x0000000000000025);
				UProperty* NewProp_JumpKeyHoldTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("JumpKeyHoldTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(JumpKeyHoldTime, ACharacter), 0x0000000000022815);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bServerMoveIgnoreRootMotion, ACharacter, uint8);
				UProperty* NewProp_bServerMoveIgnoreRootMotion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bServerMoveIgnoreRootMotion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bServerMoveIgnoreRootMotion, ACharacter), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bServerMoveIgnoreRootMotion, ACharacter), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimGravityDisabled, ACharacter, uint8);
				UProperty* NewProp_bSimGravityDisabled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSimGravityDisabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimGravityDisabled, ACharacter), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bSimGravityDisabled, ACharacter), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClientResimulateRootMotion, ACharacter, uint8);
				UProperty* NewProp_bClientResimulateRootMotion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bClientResimulateRootMotion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClientResimulateRootMotion, ACharacter), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bClientResimulateRootMotion, ACharacter), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClientWasFalling, ACharacter, uint8);
				UProperty* NewProp_bClientWasFalling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bClientWasFalling"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClientWasFalling, ACharacter), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bClientWasFalling, ACharacter), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClientUpdating, ACharacter, uint8);
				UProperty* NewProp_bClientUpdating = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bClientUpdating"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClientUpdating, ACharacter), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bClientUpdating, ACharacter), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPressedJump, ACharacter, uint8);
				UProperty* NewProp_bPressedJump = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPressedJump"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPressedJump, ACharacter), 0x0000000000000014, CPP_BOOL_PROPERTY_BITMASK(bPressedJump, ACharacter), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsCrouched, ACharacter, uint8);
				UProperty* NewProp_bIsCrouched = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsCrouched"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsCrouched, ACharacter), 0x0000000100000034, CPP_BOOL_PROPERTY_BITMASK(bIsCrouched, ACharacter), sizeof(uint8), false);
				NewProp_bIsCrouched->RepNotifyFunc = FName(TEXT("OnRep_IsCrouched"));
				UProperty* NewProp_CrouchedEyeHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CrouchedEyeHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CrouchedEyeHeight, ACharacter), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInBaseReplication, ACharacter, bool);
				UProperty* NewProp_bInBaseReplication = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInBaseReplication"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInBaseReplication, ACharacter), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bInBaseReplication, ACharacter), sizeof(bool), true);
				UProperty* NewProp_ReplicatedMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReplicatedMovementMode, ACharacter), 0x0000080000000020);
				UProperty* NewProp_BaseRotationOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BaseRotationOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BaseRotationOffset, ACharacter), 0x0000080000000000, Z_Construct_UScriptStruct_FQuat());
				UProperty* NewProp_BaseTranslationOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BaseTranslationOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BaseTranslationOffset, ACharacter), 0x0000080000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_ReplicatedBasedMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedBasedMovement"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReplicatedBasedMovement, ACharacter), 0x0000088100000020, Z_Construct_UScriptStruct_FBasedMovementInfo());
				NewProp_ReplicatedBasedMovement->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedBasedMovement"));
				UProperty* NewProp_BasedMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BasedMovement"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BasedMovement, ACharacter), 0x0000088000000000, Z_Construct_UScriptStruct_FBasedMovementInfo());
				UProperty* NewProp_CapsuleComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CapsuleComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CapsuleComponent, ACharacter), 0x00000000000a001d, Z_Construct_UClass_UCapsuleComponent_NoRegister());
				UProperty* NewProp_CharacterMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CharacterMovement"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CharacterMovement, ACharacter), 0x00000000000a001d, Z_Construct_UClass_UCharacterMovementComponent_NoRegister());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_ArrowComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ArrowComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ArrowComponent, ACharacter), 0x0000000800080008, Z_Construct_UClass_UArrowComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_Mesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Mesh, ACharacter), 0x00000000000a001d, Z_Construct_UClass_USkeletalMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_CanJump()); // 566729725
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_CanJumpInternal()); // 1350819204
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_ClientCheatFly()); // 2046740133
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_ClientCheatGhost()); // 358186176
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_ClientCheatWalk()); // 2280704342
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_Crouch()); // 4248757029
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_GetCurrentMontage()); // 2641141792
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_IsJumpProvidingForce()); // 140944269
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_IsPlayingNetworkedRootMotionMontage()); // 2123885439
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_IsPlayingRootMotion()); // 4143916766
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_Jump()); // 1800874097
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_K2_OnEndCrouch()); // 1421341442
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_K2_OnMovementModeChanged()); // 635859877
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_K2_OnStartCrouch()); // 4193412354
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_K2_UpdateCustomMovement()); // 3162128710
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_LaunchCharacter()); // 2101985518
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnJumped()); // 1703197584
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnLanded()); // 47186719
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnLaunched()); // 969749946
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnRep_IsCrouched()); // 684031919
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnRep_ReplicatedBasedMovement()); // 3579788015
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnRep_RootMotion()); // 1918033360
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_OnWalkingOffLedge()); // 1824397316
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_PlayAnimMontage()); // 2587535366
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_SetReplicateMovement()); // 2756897547
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_StopAnimMontage()); // 1183886321
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_StopJumping()); // 629291686
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ACharacter_UnCrouch()); // 1940342810
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/Character.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(OuterClass, TEXT("ShortTooltip"), TEXT("A character is a type of Pawn that includes the ability to walk around."));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Characters are Pawns that have a mesh, collision, and built-in movement logic.\nThey are responsible for all physical interaction between the player or AI and the world, and also implement basic networking and input models.\nThey are designed for a vertically-oriented player representation that can walk, jump, fly, and swim through the world using CharacterMovementComponent.\n\n@see APawn, UCharacterMovementComponent\n@see https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/Character/"));
				MetaData->SetValue(NewProp_RepRootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_RepRootMotion, TEXT("ToolTip"), TEXT("Replicated Root Motion montage"));
				MetaData->SetValue(NewProp_RootMotionRepMoves, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_RootMotionRepMoves, TEXT("ToolTip"), TEXT("Array of previously received root motion moves from the server."));
				MetaData->SetValue(NewProp_ClientRootMotionParams, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_ClientRootMotionParams, TEXT("ToolTip"), TEXT("For LocallyControlled Autonomous clients. Saved root motion data to be used by SavedMoves."));
				MetaData->SetValue(NewProp_OnCharacterMovementUpdated, TEXT("Category"), TEXT("Pawn|Character"));
				MetaData->SetValue(NewProp_OnCharacterMovementUpdated, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_OnCharacterMovementUpdated, TEXT("ToolTip"), TEXT("Event triggered at the end of a CharacterMovementComponent movement update.\nThis is the preferred event to use rather than the Tick event when performing custom updates to CharacterMovement properties based on the current state.\nThis is mainly due to the nature of network updates, where client corrections in position from the server can cause multiple iterations of a movement update,\nwhich allows this event to update as well, while a Tick event would not.\n\n@param       DeltaSeconds            Delta time in seconds for this update\n@param       InitialLocation         Location at the start of the update. May be different than the current location if movement occurred.\n@param       InitialVelocity         Velocity at the start of the update. May be different than the current velocity."));
				MetaData->SetValue(NewProp_OnReachedJumpApex, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_OnReachedJumpApex, TEXT("ToolTip"), TEXT("Broadcast when Character's jump reaches its apex. Needs CharacterMovement->bNotifyApex = true"));
				MetaData->SetValue(NewProp_JumpMaxHoldTime, TEXT("Category"), TEXT("Character"));
				MetaData->SetValue(NewProp_JumpMaxHoldTime, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_JumpMaxHoldTime, TEXT("ToolTip"), TEXT("The max time the jump key can be held.\nNote that if StopJumping() is not called before the max jump hold time is reached,\nthen the character will carry on receiving vertical velocity. Therefore it is usually\nbest to call StopJumping() when jump input has ceased (such as a button up event)."));
				MetaData->SetValue(NewProp_JumpKeyHoldTime, TEXT("Category"), TEXT("Character"));
				MetaData->SetValue(NewProp_JumpKeyHoldTime, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_JumpKeyHoldTime, TEXT("ToolTip"), TEXT("Jump key Held Time.\nThis is the time that the player has held the jump key, in seconds."));
				MetaData->SetValue(NewProp_bServerMoveIgnoreRootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bServerMoveIgnoreRootMotion, TEXT("ToolTip"), TEXT("Disable root motion on the server. When receiving a DualServerMove, where the first move is not root motion and the second is."));
				MetaData->SetValue(NewProp_bSimGravityDisabled, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bSimGravityDisabled, TEXT("ToolTip"), TEXT("Disable simulated gravity (set when character encroaches geometry on client, to keep him from falling through floors)"));
				MetaData->SetValue(NewProp_bClientResimulateRootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bClientResimulateRootMotion, TEXT("ToolTip"), TEXT("If server disagrees with root motion track position, client has to resimulate root motion from last AckedMove."));
				MetaData->SetValue(NewProp_bClientWasFalling, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bClientWasFalling, TEXT("ToolTip"), TEXT("True if Pawn was initially falling when started to replay network moves."));
				MetaData->SetValue(NewProp_bClientUpdating, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bClientUpdating, TEXT("ToolTip"), TEXT("When true, applying updates to network client (replaying saved moves for a locally controlled character)"));
				MetaData->SetValue(NewProp_bPressedJump, TEXT("Category"), TEXT("Pawn|Character"));
				MetaData->SetValue(NewProp_bPressedJump, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bPressedJump, TEXT("ToolTip"), TEXT("When true, player wants to jump"));
				MetaData->SetValue(NewProp_bIsCrouched, TEXT("Category"), TEXT("Character"));
				MetaData->SetValue(NewProp_bIsCrouched, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bIsCrouched, TEXT("ToolTip"), TEXT("Set by character movement to specify that this Character is currently crouched."));
				MetaData->SetValue(NewProp_CrouchedEyeHeight, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_CrouchedEyeHeight, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_CrouchedEyeHeight, TEXT("ToolTip"), TEXT("Default crouched eye height"));
				MetaData->SetValue(NewProp_bInBaseReplication, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_bInBaseReplication, TEXT("ToolTip"), TEXT("Flag that we are receiving replication of the based movement."));
				MetaData->SetValue(NewProp_ReplicatedMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_ReplicatedMovementMode, TEXT("ToolTip"), TEXT("CharacterMovement MovementMode (and custom mode) replicated for simulated proxies. Use CharacterMovementComponent::UnpackNetworkMovementMode() to translate it."));
				MetaData->SetValue(NewProp_BaseRotationOffset, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_BaseRotationOffset, TEXT("ToolTip"), TEXT("Saved rotation offset of mesh."));
				MetaData->SetValue(NewProp_BaseTranslationOffset, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_BaseTranslationOffset, TEXT("ToolTip"), TEXT("Saved translation offset of mesh."));
				MetaData->SetValue(NewProp_ReplicatedBasedMovement, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_ReplicatedBasedMovement, TEXT("ToolTip"), TEXT("Replicated version of relative movement. Read-only on simulated proxies!"));
				MetaData->SetValue(NewProp_BasedMovement, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_BasedMovement, TEXT("ToolTip"), TEXT("Info about our current movement base (object we are standing on)."));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("Category"), TEXT("Character"));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_CharacterMovement, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CharacterMovement, TEXT("Category"), TEXT("Character"));
				MetaData->SetValue(NewProp_CharacterMovement, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CharacterMovement, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_ArrowComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ArrowComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
				MetaData->SetValue(NewProp_Mesh, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_Mesh, TEXT("Category"), TEXT("Character"));
				MetaData->SetValue(NewProp_Mesh, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Mesh, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/Character.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ACharacter(Z_Construct_UClass_ACharacter, TEXT("ACharacter"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ACharacter);
	UFunction* Z_Construct_UFunction_ADefaultPawn_LookUp()
	{
		struct DefaultPawn_eventLookUp_Parms
		{
			float Val;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LookUp"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04040401, 65535, sizeof(DefaultPawn_eventLookUp_Parms));
			UProperty* NewProp_Val = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Val"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Val, DefaultPawn_eventLookUp_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use Pawn.AddControllerPitchInput instead."));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Input callback on pitch (look up) input."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ADefaultPawn_LookUpAtRate()
	{
		struct DefaultPawn_eventLookUpAtRate_Parms
		{
			float Rate;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LookUpAtRate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DefaultPawn_eventLookUpAtRate_Parms));
			UProperty* NewProp_Rate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Rate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Rate, DefaultPawn_eventLookUpAtRate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called via input to look up at a given rate (or down if Rate is negative).\n@param Rate   This is a normalized rate, i.e. 1.0 means 100% of desired turn rate"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ADefaultPawn_MoveForward()
	{
		struct DefaultPawn_eventMoveForward_Parms
		{
			float Val;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MoveForward"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(DefaultPawn_eventMoveForward_Parms));
			UProperty* NewProp_Val = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Val"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Val, DefaultPawn_eventMoveForward_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Input callback to move forward in local space (or backward if Val is negative).\n@param Val Amount of movement in the forward direction (or backward if negative).\n@see APawn::AddMovementInput()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ADefaultPawn_MoveRight()
	{
		struct DefaultPawn_eventMoveRight_Parms
		{
			float Val;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MoveRight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(DefaultPawn_eventMoveRight_Parms));
			UProperty* NewProp_Val = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Val"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Val, DefaultPawn_eventMoveRight_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Input callback to strafe right in local space (or left if Val is negative).\n@param Val Amount of movement in the right direction (or left if negative).\n@see APawn::AddMovementInput()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ADefaultPawn_MoveUp_World()
	{
		struct DefaultPawn_eventMoveUp_World_Parms
		{
			float Val;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MoveUp_World"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(DefaultPawn_eventMoveUp_World_Parms));
			UProperty* NewProp_Val = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Val"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Val, DefaultPawn_eventMoveUp_World_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Input callback to move up in world space (or down if Val is negative).\n@param Val Amount of movement in the world up direction (or down if negative).\n@see APawn::AddMovementInput()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ADefaultPawn_Turn()
	{
		struct DefaultPawn_eventTurn_Parms
		{
			float Val;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Turn"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04040401, 65535, sizeof(DefaultPawn_eventTurn_Parms));
			UProperty* NewProp_Val = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Val"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Val, DefaultPawn_eventTurn_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use Pawn.AddControllerYawInput instead."));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Input callback on yaw (turn) input."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ADefaultPawn_TurnAtRate()
	{
		struct DefaultPawn_eventTurnAtRate_Parms
		{
			float Rate;
		};
		UObject* Outer=Z_Construct_UClass_ADefaultPawn();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TurnAtRate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DefaultPawn_eventTurnAtRate_Parms));
			UProperty* NewProp_Rate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Rate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Rate, DefaultPawn_eventTurnAtRate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called via input to turn at a given rate.\n@param Rate  This is a normalized rate, i.e. 1.0 means 100% of desired turn rate"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ADefaultPawn_NoRegister()
	{
		return ADefaultPawn::StaticClass();
	}
	UClass* Z_Construct_UClass_ADefaultPawn()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APawn();
			Z_Construct_UPackage_Engine();
			OuterClass = ADefaultPawn::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_LookUp());
				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_LookUpAtRate());
				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_MoveForward());
				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_MoveRight());
				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_MoveUp_World());
				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_Turn());
				OuterClass->LinkChild(Z_Construct_UFunction_ADefaultPawn_TurnAtRate());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAddDefaultMovementBindings, ADefaultPawn, uint8);
				UProperty* NewProp_bAddDefaultMovementBindings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAddDefaultMovementBindings"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAddDefaultMovementBindings, ADefaultPawn), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAddDefaultMovementBindings, ADefaultPawn), sizeof(uint8), false);
				UProperty* NewProp_MeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MeshComponent, ADefaultPawn), 0x00000000000a001d, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
				UProperty* NewProp_CollisionComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CollisionComponent, ADefaultPawn), 0x00000000000a001d, Z_Construct_UClass_USphereComponent_NoRegister());
				UProperty* NewProp_MovementComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MovementComponent, ADefaultPawn), 0x00000000000a001d, Z_Construct_UClass_UPawnMovementComponent_NoRegister());
				UProperty* NewProp_BaseLookUpRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BaseLookUpRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseLookUpRate, ADefaultPawn), 0x0000000000020015);
				UProperty* NewProp_BaseTurnRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BaseTurnRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseTurnRate, ADefaultPawn), 0x0000000000020015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_LookUp()); // 2597685909
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_LookUpAtRate()); // 477997617
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_MoveForward()); // 2607544125
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_MoveRight()); // 2969374521
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_MoveUp_World()); // 1277580537
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_Turn()); // 310697877
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ADefaultPawn_TurnAtRate()); // 248512644
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/DefaultPawn.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("DefaultPawn implements a simple Pawn with spherical collision and built-in flying movement.\n@see UFloatingPawnMovement"));
				MetaData->SetValue(NewProp_bAddDefaultMovementBindings, TEXT("Category"), TEXT("Pawn"));
				MetaData->SetValue(NewProp_bAddDefaultMovementBindings, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(NewProp_bAddDefaultMovementBindings, TEXT("ToolTip"), TEXT("If true, adds default input bindings for movement and camera look."));
				MetaData->SetValue(NewProp_MeshComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_MeshComponent, TEXT("Category"), TEXT("Pawn"));
				MetaData->SetValue(NewProp_MeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MeshComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("Category"), TEXT("Pawn"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("Category"), TEXT("Pawn"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("ToolTip"), TEXT("DefaultPawn movement component"));
				MetaData->SetValue(NewProp_BaseLookUpRate, TEXT("Category"), TEXT("Pawn"));
				MetaData->SetValue(NewProp_BaseLookUpRate, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(NewProp_BaseLookUpRate, TEXT("ToolTip"), TEXT("Base lookup rate, in deg/sec. Other scaling may affect final lookup rate."));
				MetaData->SetValue(NewProp_BaseTurnRate, TEXT("Category"), TEXT("Pawn"));
				MetaData->SetValue(NewProp_BaseTurnRate, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/DefaultPawn.h"));
				MetaData->SetValue(NewProp_BaseTurnRate, TEXT("ToolTip"), TEXT("Base turn rate, in deg/sec. Other scaling may affect final turn rate."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ADefaultPawn(Z_Construct_UClass_ADefaultPawn, TEXT("ADefaultPawn"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ADefaultPawn);
	UClass* Z_Construct_UClass_ASpectatorPawn_NoRegister()
	{
		return ASpectatorPawn::StaticClass();
	}
	UClass* Z_Construct_UClass_ASpectatorPawn()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ADefaultPawn();
			Z_Construct_UPackage_Engine();
			OuterClass = ASpectatorPawn::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900280;


				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/SpectatorPawn.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpectatorPawn.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASpectatorPawn(Z_Construct_UClass_ASpectatorPawn, TEXT("ASpectatorPawn"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASpectatorPawn);
	UClass* Z_Construct_UClass_AWheeledVehicle_NoRegister()
	{
		return AWheeledVehicle::StaticClass();
	}
	UClass* Z_Construct_UClass_AWheeledVehicle()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APawn();
			Z_Construct_UPackage_Engine();
			OuterClass = AWheeledVehicle::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VehicleMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VehicleMovement"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VehicleMovement, AWheeledVehicle), 0x00000000000b001d, Z_Construct_UClass_UWheeledVehicleMovementComponent_NoRegister());
				UProperty* NewProp_Mesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Mesh, AWheeledVehicle), 0x00000000000b001d, Z_Construct_UClass_USkeletalMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/WheeledVehicle.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/WheeledVehicle.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("WheeledVehicle is the base wheeled vehicle pawn actor.\nBy default it uses UWheeledVehicleMovementComponent4W for its simulation, but this can be overridden by inheriting from the class and modifying its constructor like so:\nSuper(ObjectInitializer.SetDefautSubobjectClass<UMyMovement>(VehicleMovementComponentName))\nWhere UMyMovement is the new movement type that inherits from UWheeledVehicleMovementComponent\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Physics/Vehicles/VehicleUserGuide/\n@see UWheeledVehicleMovementComponent4W"));
				MetaData->SetValue(NewProp_VehicleMovement, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VehicleMovement, TEXT("Category"), TEXT("Vehicle"));
				MetaData->SetValue(NewProp_VehicleMovement, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VehicleMovement, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/WheeledVehicle.h"));
				MetaData->SetValue(NewProp_Mesh, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_Mesh, TEXT("Category"), TEXT("Vehicle"));
				MetaData->SetValue(NewProp_Mesh, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Mesh, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/WheeledVehicle.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AWheeledVehicle(Z_Construct_UClass_AWheeledVehicle, TEXT("AWheeledVehicle"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AWheeledVehicle);
	UClass* Z_Construct_UClass_AReflectionCapture_NoRegister()
	{
		return AReflectionCapture::StaticClass();
	}
	UClass* Z_Construct_UClass_AReflectionCapture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = AReflectionCapture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, AReflectionCapture), 0x0000000800080008, Z_Construct_UClass_UBillboardComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_CaptureComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CaptureComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CaptureComponent, AReflectionCapture), 0x00000000000a001d, Z_Construct_UClass_UReflectionCaptureComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/ReflectionCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/ReflectionCapture.h"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/ReflectionCapture.h"));
				MetaData->SetValue(NewProp_CaptureComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CaptureComponent, TEXT("Category"), TEXT("DecalActor"));
				MetaData->SetValue(NewProp_CaptureComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CaptureComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/ReflectionCapture.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AReflectionCapture(Z_Construct_UClass_AReflectionCapture, TEXT("AReflectionCapture"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AReflectionCapture);
	UClass* Z_Construct_UClass_ABoxReflectionCapture_NoRegister()
	{
		return ABoxReflectionCapture::StaticClass();
	}
	UClass* Z_Construct_UClass_ABoxReflectionCapture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AReflectionCapture();
			Z_Construct_UPackage_Engine();
			OuterClass = ABoxReflectionCapture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Attachment Actor Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/BoxReflectionCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/BoxReflectionCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Actor used to capture the scene for reflection in a box shape\n@see https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Reflections/1_3/index.html"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ABoxReflectionCapture(Z_Construct_UClass_ABoxReflectionCapture, TEXT("ABoxReflectionCapture"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ABoxReflectionCapture);
	UClass* Z_Construct_UClass_APlaneReflectionCapture_NoRegister()
	{
		return APlaneReflectionCapture::StaticClass();
	}
	UClass* Z_Construct_UClass_APlaneReflectionCapture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AReflectionCapture();
			Z_Construct_UPackage_Engine();
			OuterClass = APlaneReflectionCapture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Attachment Actor Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/PlaneReflectionCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/PlaneReflectionCapture.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_APlaneReflectionCapture(Z_Construct_UClass_APlaneReflectionCapture, TEXT("APlaneReflectionCapture"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(APlaneReflectionCapture);
	UClass* Z_Construct_UClass_ASphereReflectionCapture_NoRegister()
	{
		return ASphereReflectionCapture::StaticClass();
	}
	UClass* Z_Construct_UClass_ASphereReflectionCapture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AReflectionCapture();
			Z_Construct_UPackage_Engine();
			OuterClass = ASphereReflectionCapture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DrawCaptureRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawCaptureRadius"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DrawCaptureRadius, ASphereReflectionCapture), 0x0000000000080008, Z_Construct_UClass_UDrawSphereComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Attachment Actor Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/SphereReflectionCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SphereReflectionCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Actor used to capture the scene for reflection in a sphere shape.\n@see https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Reflections/1_4"));
				MetaData->SetValue(NewProp_DrawCaptureRadius, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DrawCaptureRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SphereReflectionCapture.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASphereReflectionCapture(Z_Construct_UClass_ASphereReflectionCapture, TEXT("ASphereReflectionCapture"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASphereReflectionCapture);
	UClass* Z_Construct_UClass_ARigidBodyBase_NoRegister()
	{
		return ARigidBodyBase::StaticClass();
	}
	UClass* Z_Construct_UClass_ARigidBodyBase()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ARigidBodyBase::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/RigidBodyBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RigidBodyBase.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ARigidBodyBase(Z_Construct_UClass_ARigidBodyBase, TEXT("ARigidBodyBase"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ARigidBodyBase);
	UClass* Z_Construct_UClass_APhysicsConstraintActor_NoRegister()
	{
		return APhysicsConstraintActor::StaticClass();
	}
	UClass* Z_Construct_UClass_APhysicsConstraintActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ARigidBodyBase();
			Z_Construct_UPackage_Engine();
			OuterClass = APhysicsConstraintActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableCollision_DEPRECATED, APhysicsConstraintActor, uint8);
				UProperty* NewProp_bDisableCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableCollision_DEPRECATED, APhysicsConstraintActor), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bDisableCollision_DEPRECATED, APhysicsConstraintActor), sizeof(uint8), false);
				UProperty* NewProp_ConstraintActor2 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintActor2"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ConstraintActor2_DEPRECATED, APhysicsConstraintActor), 0x0000000020000000, Z_Construct_UClass_AActor_NoRegister());
				UProperty* NewProp_ConstraintActor1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintActor1"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ConstraintActor1_DEPRECATED, APhysicsConstraintActor), 0x0000000020000000, Z_Construct_UClass_AActor_NoRegister());
				UProperty* NewProp_ConstraintComp = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ConstraintComp, APhysicsConstraintActor), 0x00000000000a001d, Z_Construct_UClass_UPhysicsConstraintComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/PhysicsConstraintActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsConversionRoot"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintActor.h"));
				MetaData->SetValue(NewProp_bDisableCollision, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintActor.h"));
				MetaData->SetValue(NewProp_ConstraintActor2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintActor.h"));
				MetaData->SetValue(NewProp_ConstraintActor1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintActor.h"));
				MetaData->SetValue(NewProp_ConstraintComp, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ConstraintComp, TEXT("Category"), TEXT("ConstraintActor"));
				MetaData->SetValue(NewProp_ConstraintComp, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ConstraintComp, TEXT("ExposeFunctionCategories"), TEXT("JointDrive,Physics|Components|PhysicsConstraint"));
				MetaData->SetValue(NewProp_ConstraintComp, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_APhysicsConstraintActor(Z_Construct_UClass_APhysicsConstraintActor, TEXT("APhysicsConstraintActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(APhysicsConstraintActor);
	UClass* Z_Construct_UClass_APhysicsThruster_NoRegister()
	{
		return APhysicsThruster::StaticClass();
	}
	UClass* Z_Construct_UClass_APhysicsThruster()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ARigidBodyBase();
			Z_Construct_UPackage_Engine();
			OuterClass = APhysicsThruster::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, APhysicsThruster), 0x0000000800080008, Z_Construct_UClass_UBillboardComponent_NoRegister());
				UProperty* NewProp_ArrowComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ArrowComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ArrowComponent, APhysicsThruster), 0x0000000800080008, Z_Construct_UClass_UArrowComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_ThrusterComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThrusterComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ThrusterComponent, APhysicsThruster), 0x00000000000a001d, Z_Construct_UClass_UPhysicsThrusterComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Input Collision Replication"));
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/PhysicsThruster.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsThruster.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Attach one of these on an object using physics simulation and it will apply a force down the negative-X direction\nie. point X in the direction you want the thrust in."));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsThruster.h"));
				MetaData->SetValue(NewProp_ArrowComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ArrowComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsThruster.h"));
				MetaData->SetValue(NewProp_ThrusterComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ThrusterComponent, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_ThrusterComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ThrusterComponent, TEXT("ExposeFunctionCategories"), TEXT("Activation,Components|Activation"));
				MetaData->SetValue(NewProp_ThrusterComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsThruster.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_APhysicsThruster(Z_Construct_UClass_APhysicsThruster, TEXT("APhysicsThruster"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(APhysicsThruster);
	UFunction* Z_Construct_UFunction_ARadialForceActor_DisableForce()
	{
		UObject* Outer=Z_Construct_UClass_ARadialForceActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DisableForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ARadialForceActor_EnableForce()
	{
		UObject* Outer=Z_Construct_UClass_ARadialForceActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnableForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ARadialForceActor_FireImpulse()
	{
		UObject* Outer=Z_Construct_UClass_ARadialForceActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FireImpulse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("BEGIN DEPRECATED (use component functions now in level script)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ARadialForceActor_ToggleForce()
	{
		UObject* Outer=Z_Construct_UClass_ARadialForceActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ToggleForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ARadialForceActor_NoRegister()
	{
		return ARadialForceActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ARadialForceActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ARigidBodyBase();
			Z_Construct_UPackage_Engine();
			OuterClass = ARadialForceActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;

				OuterClass->LinkChild(Z_Construct_UFunction_ARadialForceActor_DisableForce());
				OuterClass->LinkChild(Z_Construct_UFunction_ARadialForceActor_EnableForce());
				OuterClass->LinkChild(Z_Construct_UFunction_ARadialForceActor_FireImpulse());
				OuterClass->LinkChild(Z_Construct_UFunction_ARadialForceActor_ToggleForce());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, ARadialForceActor), 0x0000000800080008, Z_Construct_UClass_UBillboardComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_ForceComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ForceComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ForceComponent, ARadialForceActor), 0x00000000000a001d, Z_Construct_UClass_URadialForceComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ARadialForceActor_DisableForce()); // 553147689
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ARadialForceActor_EnableForce()); // 1686636651
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ARadialForceActor_FireImpulse()); // 3142786150
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ARadialForceActor_ToggleForce()); // 3706497298
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Input"));
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/RadialForceActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
				MetaData->SetValue(NewProp_ForceComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ForceComponent, TEXT("Category"), TEXT("RadialForceActor"));
				MetaData->SetValue(NewProp_ForceComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ForceComponent, TEXT("ExposeFunctionCategories"), TEXT("Activation,Components|Activation,Physics,Physics|Components|RadialForce"));
				MetaData->SetValue(NewProp_ForceComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ARadialForceActor(Z_Construct_UClass_ARadialForceActor, TEXT("ARadialForceActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ARadialForceActor);
	UClass* Z_Construct_UClass_ASceneCapture_NoRegister()
	{
		return ASceneCapture::StaticClass();
	}
	UClass* Z_Construct_UClass_ASceneCapture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ASceneCapture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MeshComp = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MeshComp, ASceneCapture), 0x0000000000080008, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/SceneCapture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCapture.h"));
				MetaData->SetValue(NewProp_MeshComp, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MeshComp, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCapture.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASceneCapture(Z_Construct_UClass_ASceneCapture, TEXT("ASceneCapture"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASceneCapture);
	UFunction* Z_Construct_UFunction_ASceneCapture2D_OnInterpToggle()
	{
		struct SceneCapture2D_eventOnInterpToggle_Parms
		{
			bool bEnable;
		};
		UObject* Outer=Z_Construct_UClass_ASceneCapture2D();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToggle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SceneCapture2D_eventOnInterpToggle_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnable, SceneCapture2D_eventOnInterpToggle_Parms, bool);
			UProperty* NewProp_bEnable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnable, SceneCapture2D_eventOnInterpToggle_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnable, SceneCapture2D_eventOnInterpToggle_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCapture2D.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ASceneCapture2D_NoRegister()
	{
		return ASceneCapture2D::StaticClass();
	}
	UClass* Z_Construct_UClass_ASceneCapture2D()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ASceneCapture();
			Z_Construct_UPackage_Engine();
			OuterClass = ASceneCapture2D::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;

				OuterClass->LinkChild(Z_Construct_UFunction_ASceneCapture2D_OnInterpToggle());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DrawFrustum = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawFrustum"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DrawFrustum, ASceneCapture2D), 0x0000000000080008, Z_Construct_UClass_UDrawFrustumComponent_NoRegister());
				UProperty* NewProp_CaptureComponent2D = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CaptureComponent2D"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CaptureComponent2D, ASceneCapture2D), 0x00000000000a001d, Z_Construct_UClass_USceneCaptureComponent2D_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASceneCapture2D_OnInterpToggle()); // 283525443
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Material Attachment Actor Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/SceneCapture2D.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCapture2D.h"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCapture2D.h"));
				MetaData->SetValue(NewProp_CaptureComponent2D, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CaptureComponent2D, TEXT("Category"), TEXT("DecalActor"));
				MetaData->SetValue(NewProp_CaptureComponent2D, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CaptureComponent2D, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCapture2D.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASceneCapture2D(Z_Construct_UClass_ASceneCapture2D, TEXT("ASceneCapture2D"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASceneCapture2D);
	UFunction* Z_Construct_UFunction_ASceneCaptureCube_OnInterpToggle()
	{
		struct SceneCaptureCube_eventOnInterpToggle_Parms
		{
			bool bEnable;
		};
		UObject* Outer=Z_Construct_UClass_ASceneCaptureCube();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToggle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SceneCaptureCube_eventOnInterpToggle_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnable, SceneCaptureCube_eventOnInterpToggle_Parms, bool);
			UProperty* NewProp_bEnable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnable, SceneCaptureCube_eventOnInterpToggle_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnable, SceneCaptureCube_eventOnInterpToggle_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCaptureCube.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ASceneCaptureCube_NoRegister()
	{
		return ASceneCaptureCube::StaticClass();
	}
	UClass* Z_Construct_UClass_ASceneCaptureCube()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ASceneCapture();
			Z_Construct_UPackage_Engine();
			OuterClass = ASceneCaptureCube::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_ASceneCaptureCube_OnInterpToggle());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DrawFrustum = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawFrustum"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DrawFrustum, ASceneCaptureCube), 0x0000000000080008, Z_Construct_UClass_UDrawFrustumComponent_NoRegister());
				UProperty* NewProp_CaptureComponentCube = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CaptureComponentCube"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CaptureComponentCube, ASceneCaptureCube), 0x00000000000a001d, Z_Construct_UClass_USceneCaptureComponentCube_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASceneCaptureCube_OnInterpToggle()); // 3935193896
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Material Attachment Actor Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/SceneCaptureCube.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCaptureCube.h"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCaptureCube.h"));
				MetaData->SetValue(NewProp_CaptureComponentCube, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CaptureComponentCube, TEXT("Category"), TEXT("DecalActor"));
				MetaData->SetValue(NewProp_CaptureComponentCube, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CaptureComponentCube, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SceneCaptureCube.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASceneCaptureCube(Z_Construct_UClass_ASceneCaptureCube, TEXT("ASceneCaptureCube"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASceneCaptureCube);
	UEnum* Z_Construct_UEnum_Engine_EDOFMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EDOFMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EDOFMode"), 0, Get_Z_Construct_UEnum_Engine_EDOFMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EDOFMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::Default")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::SixDOF")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::YZPlane")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::XZPlane")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::XYPlane")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::CustomPlane")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::None")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EDOFMode::EDOFMode_MAX")), 7));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("CustomPlane.ToolTip"), TEXT("Allows 2D movement along the plane of a given normal"));
			MetaData->SetValue(ReturnEnum, TEXT("Default.ToolTip"), TEXT("Inherits the degrees of freedom from the project settings."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(ReturnEnum, TEXT("None.ToolTip"), TEXT("No constraints."));
			MetaData->SetValue(ReturnEnum, TEXT("SixDOF.ToolTip"), TEXT("Specifies which axis to freeze rotation and movement along."));
			MetaData->SetValue(ReturnEnum, TEXT("XYPlane.ToolTip"), TEXT("Allows 2D movement along the X-Y plane."));
			MetaData->SetValue(ReturnEnum, TEXT("XZPlane.ToolTip"), TEXT("Allows 2D movement along the X-Z plane."));
			MetaData->SetValue(ReturnEnum, TEXT("YZPlane.ToolTip"), TEXT("Allows 2D movement along the Y-Z plane."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EDOFMode_CRC() { return 4095528928U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBodyInstance()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBodyInstance_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BodyInstance"), sizeof(FBodyInstance), Get_Z_Construct_UScriptStruct_FBodyInstance_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BodyInstance"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBodyInstance>, EStructFlags(0x00000201));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ObjectType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ObjectType, FBodyInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_ECollisionChannel());
			UProperty* NewProp_CollisionEnabled = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CollisionEnabled"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CollisionEnabled, FBodyInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_ECollisionEnabled());
			UProperty* NewProp_DOFMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DOFMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DOFMode, FBodyInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_EDOFMode());
			UProperty* NewProp_SleepFamily = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SleepFamily"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SleepFamily, FBodyInstance), 0x0000040000000005, Z_Construct_UEnum_Engine_ESleepFamily());
			UProperty* NewProp_VelocitySolverIterationCount = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VelocitySolverIterationCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(VelocitySolverIterationCount, FBodyInstance), 0x0000040000000015);
			UProperty* NewProp_RigidActorAsyncId = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RigidActorAsyncId"), RF_Public|RF_Transient|RF_Native) UUInt64Property(CPP_PROPERTY_BASE(RigidActorAsyncId, FBodyInstance), 0x0000000000000000);
			UProperty* NewProp_RigidActorSyncId = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RigidActorSyncId"), RF_Public|RF_Transient|RF_Native) UUInt64Property(CPP_PROPERTY_BASE(RigidActorSyncId, FBodyInstance), 0x0000000000000000);
			UProperty* NewProp_PositionSolverIterationCount = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PositionSolverIterationCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PositionSolverIterationCount, FBodyInstance), 0x0000040000000015);
			UProperty* NewProp_PhysicsBlendWeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PhysicsBlendWeight, FBodyInstance), 0x0000000000000000);
			UProperty* NewProp_CustomSleepThresholdMultiplier = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomSleepThresholdMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CustomSleepThresholdMultiplier, FBodyInstance), 0x0000040000000015);
			UProperty* NewProp_MaxAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxAngularVelocity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxAngularVelocity, FBodyInstance), 0x0000040000000015);
			UProperty* NewProp_PhysMaterialOverride = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PhysMaterialOverride"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PhysMaterialOverride, FBodyInstance), 0x0000080000000015, Z_Construct_UClass_UPhysicalMaterial_NoRegister());
			UProperty* NewProp_WalkableSlopeOverride = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("WalkableSlopeOverride"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WalkableSlopeOverride, FBodyInstance), 0x00000c0000000015, Z_Construct_UScriptStruct_FWalkableSlopeOverride());
			UProperty* NewProp_MassScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MassScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MassScale, FBodyInstance), 0x0000040000000005);
			UProperty* NewProp_COMNudge = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("COMNudge"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(COMNudge, FBodyInstance), 0x0000040000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CustomDOFPlaneNormal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomDOFPlaneNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CustomDOFPlaneNormal, FBodyInstance), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AngularDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularDamping, FBodyInstance), 0x0000000000000005);
			UProperty* NewProp_LinearDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearDamping, FBodyInstance), 0x0000000000000005);
			UProperty* NewProp_MassInKg = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MassInKg"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MassInKg, FBodyInstance), 0x0000000000000015);
			UProperty* NewProp_MaxDepenetrationVelocity = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxDepenetrationVelocity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxDepenetrationVelocity, FBodyInstance), 0x00000c0000000015);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideWalkableSlopeOnInstance, FBodyInstance, uint8);
			UProperty* NewProp_bOverrideWalkableSlopeOnInstance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideWalkableSlopeOnInstance"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideWalkableSlopeOnInstance, FBodyInstance), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideWalkableSlopeOnInstance, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMaxDepenetrationVelocity, FBodyInstance, uint8);
			UProperty* NewProp_bOverrideMaxDepenetrationVelocity = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideMaxDepenetrationVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMaxDepenetrationVelocity, FBodyInstance), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideMaxDepenetrationVelocity, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseAsyncScene, FBodyInstance, uint8);
			UProperty* NewProp_bUseAsyncScene = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bUseAsyncScene"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseAsyncScene, FBodyInstance), 0x00000c0000000005, CPP_BOOL_PROPERTY_BITMASK(bUseAsyncScene, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMaxAngularVelocity, FBodyInstance, uint8);
			UProperty* NewProp_bOverrideMaxAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideMaxAngularVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMaxAngularVelocity, FBodyInstance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideMaxAngularVelocity, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockZRotation, FBodyInstance, uint8);
			UProperty* NewProp_bLockZRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockZRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockZRotation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockZRotation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockYRotation, FBodyInstance, uint8);
			UProperty* NewProp_bLockYRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockYRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockYRotation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockYRotation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockXRotation, FBodyInstance, uint8);
			UProperty* NewProp_bLockXRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockXRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockXRotation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockXRotation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockZTranslation, FBodyInstance, uint8);
			UProperty* NewProp_bLockZTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockZTranslation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockZTranslation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockZTranslation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockYTranslation, FBodyInstance, uint8);
			UProperty* NewProp_bLockYTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockYTranslation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockYTranslation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockYTranslation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockXTranslation, FBodyInstance, uint8);
			UProperty* NewProp_bLockXTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockXTranslation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockXTranslation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockXTranslation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockRotation, FBodyInstance, uint8);
			UProperty* NewProp_bLockRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockRotation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockRotation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockTranslation, FBodyInstance, uint8);
			UProperty* NewProp_bLockTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLockTranslation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockTranslation, FBodyInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLockTranslation, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateMassWhenScaleChanges, FBodyInstance, uint8);
			UProperty* NewProp_bUpdateMassWhenScaleChanges = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bUpdateMassWhenScaleChanges"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateMassWhenScaleChanges, FBodyInstance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUpdateMassWhenScaleChanges, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGenerateWakeEvents, FBodyInstance, uint8);
			UProperty* NewProp_bGenerateWakeEvents = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGenerateWakeEvents"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGenerateWakeEvents, FBodyInstance), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bGenerateWakeEvents, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStartAwake, FBodyInstance, uint8);
			UProperty* NewProp_bStartAwake = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bStartAwake"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStartAwake, FBodyInstance), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bStartAwake, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoWeld, FBodyInstance, uint8);
			UProperty* NewProp_bAutoWeld = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAutoWeld"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoWeld, FBodyInstance), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bAutoWeld, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableGravity, FBodyInstance, uint8);
			UProperty* NewProp_bEnableGravity = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEnableGravity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableGravity, FBodyInstance), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bEnableGravity, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMass, FBodyInstance, uint8);
			UProperty* NewProp_bOverrideMass = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideMass"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMass, FBodyInstance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideMass, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulatePhysics, FBodyInstance, uint8);
			UProperty* NewProp_bSimulatePhysics = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSimulatePhysics"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulatePhysics, FBodyInstance), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bSimulatePhysics, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNotifyRigidBodyCollision, FBodyInstance, uint8);
			UProperty* NewProp_bNotifyRigidBodyCollision = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bNotifyRigidBodyCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNotifyRigidBodyCollision, FBodyInstance), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bNotifyRigidBodyCollision, FBodyInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseCCD, FBodyInstance, uint8);
			UProperty* NewProp_bUseCCD = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bUseCCD"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseCCD, FBodyInstance), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bUseCCD, FBodyInstance), sizeof(uint8), false);
			UProperty* NewProp_CollisionResponses = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CollisionResponses"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CollisionResponses, FBodyInstance), 0x0000000000000001, Z_Construct_UScriptStruct_FCollisionResponse());
			UProperty* NewProp_CollisionProfileName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CollisionProfileName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(CollisionProfileName, FBodyInstance), 0x0000000000000001);
			UProperty* NewProp_ResponseToChannels = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ResponseToChannels"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ResponseToChannels_DEPRECATED, FBodyInstance), 0x0000000020000000, Z_Construct_UScriptStruct_FCollisionResponseContainer());
			UProperty* NewProp_Scale3D = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Scale3D"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Scale3D, FBodyInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Container for a physics representation of an object"));
			MetaData->SetValue(NewProp_ObjectType, TEXT("Category"), TEXT("Custom"));
			MetaData->SetValue(NewProp_ObjectType, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_ObjectType, TEXT("ToolTip"), TEXT("Enum indicating what type of object this should be considered as when it moves"));
			MetaData->SetValue(NewProp_CollisionEnabled, TEXT("Category"), TEXT("Custom"));
			MetaData->SetValue(NewProp_CollisionEnabled, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_CollisionEnabled, TEXT("ToolTip"), TEXT("Type of collision enabled.\n\n     No Collision      : No collision is performed against this body.\n     Query Only        : This body is used only for collision queries (raycasts, sweeps, and overlaps).\n     Physics Only      : This body is used only for physics collision.\n     Collision Enabled : This body interacts with all collision (Query and Physics)."));
			MetaData->SetValue(NewProp_DOFMode, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_DOFMode, TEXT("DisplayName"), TEXT("Mode"));
			MetaData->SetValue(NewProp_DOFMode, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_DOFMode, TEXT("ToolTip"), TEXT("Locks physical movement along specified axis."));
			MetaData->SetValue(NewProp_SleepFamily, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_SleepFamily, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_SleepFamily, TEXT("ToolTip"), TEXT("The set of values used in considering when put this body to sleep."));
			MetaData->SetValue(NewProp_VelocitySolverIterationCount, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_VelocitySolverIterationCount, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_VelocitySolverIterationCount, TEXT("ToolTip"), TEXT("This physics body's solver iteration count for velocity. Increasing this will be more CPU intensive, but better stabilized."));
			MetaData->SetValue(NewProp_RigidActorAsyncId, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_RigidActorAsyncId, TEXT("ToolTip"), TEXT("Internal use. Physics-engine id of the actor used during serialization.  Needs to be outside the ifdef for serialization purposes"));
			MetaData->SetValue(NewProp_RigidActorSyncId, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_RigidActorSyncId, TEXT("ToolTip"), TEXT("Internal use. Physics-engine id of the actor used during serialization. Needs to be outside the ifdef for serialization purposes"));
			MetaData->SetValue(NewProp_PositionSolverIterationCount, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_PositionSolverIterationCount, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_PositionSolverIterationCount, TEXT("ToolTip"), TEXT("This physics body's solver iteration count for position. Increasing this will be more CPU intensive, but better stabilized."));
			MetaData->SetValue(NewProp_PhysicsBlendWeight, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_PhysicsBlendWeight, TEXT("ToolTip"), TEXT("Provide appropriate interface for doing this instead of allowing BlueprintReadWrite *"));
			MetaData->SetValue(NewProp_CustomSleepThresholdMultiplier, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_CustomSleepThresholdMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_CustomSleepThresholdMultiplier, TEXT("ToolTip"), TEXT("If the SleepFamily is set to custom, multiply the natural sleep threshold by this amount. A higher number will cause the body to sleep sooner."));
			MetaData->SetValue(NewProp_MaxAngularVelocity, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_MaxAngularVelocity, TEXT("editcondition"), TEXT("bOverrideMaxAngularVelocity"));
			MetaData->SetValue(NewProp_MaxAngularVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_MaxAngularVelocity, TEXT("ToolTip"), TEXT("The maximum angular velocity for this instance"));
			MetaData->SetValue(NewProp_PhysMaterialOverride, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(NewProp_PhysMaterialOverride, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_PhysMaterialOverride, TEXT("ToolTip"), TEXT("Allows you to override the PhysicalMaterial to use for simple collision on this body."));
			MetaData->SetValue(NewProp_WalkableSlopeOverride, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_WalkableSlopeOverride, TEXT("editcondition"), TEXT("bOverrideWalkableSlopeOnInstance"));
			MetaData->SetValue(NewProp_WalkableSlopeOverride, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_WalkableSlopeOverride, TEXT("ToolTip"), TEXT("Custom walkable slope override setting for this instance.\n@see GetWalkableSlopeOverride(), SetWalkableSlopeOverride()"));
			MetaData->SetValue(NewProp_MassScale, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_MassScale, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_MassScale, TEXT("ToolTip"), TEXT("Per-instance scaling of mass"));
			MetaData->SetValue(NewProp_COMNudge, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_COMNudge, TEXT("DisplayName"), TEXT("Center Of Mass Offset"));
			MetaData->SetValue(NewProp_COMNudge, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_COMNudge, TEXT("ToolTip"), TEXT("User specified offset for the center of mass of this object, from the calculated location"));
			MetaData->SetValue(NewProp_CustomDOFPlaneNormal, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_CustomDOFPlaneNormal, TEXT("DisplayName"), TEXT("Plane Normal"));
			MetaData->SetValue(NewProp_CustomDOFPlaneNormal, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_CustomDOFPlaneNormal, TEXT("ToolTip"), TEXT("Locks physical movement along a custom plane for a given normal."));
			MetaData->SetValue(NewProp_AngularDamping, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_AngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_AngularDamping, TEXT("ToolTip"), TEXT("'Drag' force added to reduce angular movement"));
			MetaData->SetValue(NewProp_LinearDamping, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_LinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_LinearDamping, TEXT("ToolTip"), TEXT("'Drag' force added to reduce linear movement"));
			MetaData->SetValue(NewProp_MassInKg, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_MassInKg, TEXT("ClampMin"), TEXT("0.001"));
			MetaData->SetValue(NewProp_MassInKg, TEXT("editcondition"), TEXT("bOverrideMass"));
			MetaData->SetValue(NewProp_MassInKg, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_MassInKg, TEXT("ToolTip"), TEXT("Mass of the body in KG. By default we compute this based on physical material and mass scale.\n@see bOverrideMass to set this directly"));
			MetaData->SetValue(NewProp_MassInKg, TEXT("UIMin"), TEXT("0.001"));
			MetaData->SetValue(NewProp_MaxDepenetrationVelocity, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_MaxDepenetrationVelocity, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_MaxDepenetrationVelocity, TEXT("editcondition"), TEXT("bOverrideMaxDepenetrationVelocity"));
			MetaData->SetValue(NewProp_MaxDepenetrationVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_MaxDepenetrationVelocity, TEXT("ToolTip"), TEXT("The maximum velocity used to depenetrate this object"));
			MetaData->SetValue(NewProp_MaxDepenetrationVelocity, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_bOverrideWalkableSlopeOnInstance, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bOverrideWalkableSlopeOnInstance, TEXT("ToolTip"), TEXT("Whether this instance of the object has its own custom walkable slope override setting."));
			MetaData->SetValue(NewProp_bOverrideMaxDepenetrationVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bOverrideMaxDepenetrationVelocity, TEXT("ToolTip"), TEXT("Whether this body instance has its own custom MaxDepenetrationVelocity"));
			MetaData->SetValue(NewProp_bUseAsyncScene, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bUseAsyncScene, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bUseAsyncScene, TEXT("ToolTip"), TEXT("If true, this body will be put into the asynchronous physics scene. If false, it will be put into the synchronous physics scene.\nIf the body is static, it will be placed into both scenes regardless of the value of bUseAsyncScene."));
			MetaData->SetValue(NewProp_bOverrideMaxAngularVelocity, TEXT("editcondition"), TEXT("bSimulatePhysics"));
			MetaData->SetValue(NewProp_bOverrideMaxAngularVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bOverrideMaxAngularVelocity, TEXT("ToolTip"), TEXT("Override the default max angular velocity"));
			MetaData->SetValue(NewProp_bLockZRotation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockZRotation, TEXT("DisplayName"), TEXT("Z"));
			MetaData->SetValue(NewProp_bLockZRotation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockZRotation, TEXT("ToolTip"), TEXT("Lock rotation about the Z-axis"));
			MetaData->SetValue(NewProp_bLockYRotation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockYRotation, TEXT("DisplayName"), TEXT("Y"));
			MetaData->SetValue(NewProp_bLockYRotation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockYRotation, TEXT("ToolTip"), TEXT("Lock rotation about the Y-axis"));
			MetaData->SetValue(NewProp_bLockXRotation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockXRotation, TEXT("DisplayName"), TEXT("X"));
			MetaData->SetValue(NewProp_bLockXRotation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockXRotation, TEXT("ToolTip"), TEXT("Lock rotation about the X-axis"));
			MetaData->SetValue(NewProp_bLockZTranslation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockZTranslation, TEXT("DisplayName"), TEXT("Z"));
			MetaData->SetValue(NewProp_bLockZTranslation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockZTranslation, TEXT("ToolTip"), TEXT("Lock translation along the Z-axis"));
			MetaData->SetValue(NewProp_bLockYTranslation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockYTranslation, TEXT("DisplayName"), TEXT("Y"));
			MetaData->SetValue(NewProp_bLockYTranslation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockYTranslation, TEXT("ToolTip"), TEXT("Lock translation along the Y-axis"));
			MetaData->SetValue(NewProp_bLockXTranslation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockXTranslation, TEXT("DisplayName"), TEXT("X"));
			MetaData->SetValue(NewProp_bLockXTranslation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockXTranslation, TEXT("ToolTip"), TEXT("Lock translation along the X-axis"));
			MetaData->SetValue(NewProp_bLockRotation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockRotation, TEXT("DisplayName"), TEXT("Lock Axis Rotation"));
			MetaData->SetValue(NewProp_bLockRotation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockRotation, TEXT("ToolTip"), TEXT("When a Locked Axis Mode is selected, will lock rotation to the specified axis"));
			MetaData->SetValue(NewProp_bLockTranslation, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bLockTranslation, TEXT("DisplayName"), TEXT("Lock Axis Translation"));
			MetaData->SetValue(NewProp_bLockTranslation, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bLockTranslation, TEXT("ToolTip"), TEXT("When a Locked Axis Mode is selected, will lock translation on the specified axis"));
			MetaData->SetValue(NewProp_bUpdateMassWhenScaleChanges, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bUpdateMassWhenScaleChanges, TEXT("ToolTip"), TEXT("If true, it will update mass when scale changes *"));
			MetaData->SetValue(NewProp_bGenerateWakeEvents, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bGenerateWakeEvents, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bGenerateWakeEvents, TEXT("ToolTip"), TEXT("Should 'wake/sleep' events fire when this object is woken up or put to sleep by the physics simulation."));
			MetaData->SetValue(NewProp_bStartAwake, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bStartAwake, TEXT("editcondition"), TEXT("bSimulatePhysics"));
			MetaData->SetValue(NewProp_bStartAwake, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bStartAwake, TEXT("ToolTip"), TEXT("If object should start awake, or if it should initially be sleeping"));
			MetaData->SetValue(NewProp_bAutoWeld, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bAutoWeld, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bAutoWeld, TEXT("ToolTip"), TEXT("If true and is attached to a parent, the two bodies will be joined into a single rigid body. Physical settings like collision profile and body settings are determined by the root"));
			MetaData->SetValue(NewProp_bEnableGravity, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bEnableGravity, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bEnableGravity, TEXT("ToolTip"), TEXT("If object should have the force of gravity applied"));
			MetaData->SetValue(NewProp_bOverrideMass, TEXT("DisplayName"), TEXT("Override"));
			MetaData->SetValue(NewProp_bOverrideMass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bOverrideMass, TEXT("ToolTip"), TEXT("If true, mass will not be automatically computed and you must set it directly"));
			MetaData->SetValue(NewProp_bSimulatePhysics, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(NewProp_bSimulatePhysics, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bSimulatePhysics, TEXT("ToolTip"), TEXT("If true, this body will use simulation. If false, will be 'fixed' (ie kinematic) and move where it is told."));
			MetaData->SetValue(NewProp_bNotifyRigidBodyCollision, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(NewProp_bNotifyRigidBodyCollision, TEXT("DisplayName"), TEXT("Simulation Generates Hit Events"));
			MetaData->SetValue(NewProp_bNotifyRigidBodyCollision, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bNotifyRigidBodyCollision, TEXT("ToolTip"), TEXT("Should 'Hit' events fire when this object collides during physics simulation."));
			MetaData->SetValue(NewProp_bUseCCD, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(NewProp_bUseCCD, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_bUseCCD, TEXT("ToolTip"), TEXT("If true Continuous Collision Detection (CCD) will be used for this component"));
			MetaData->SetValue(NewProp_CollisionResponses, TEXT("Category"), TEXT("Custom"));
			MetaData->SetValue(NewProp_CollisionResponses, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_CollisionResponses, TEXT("ToolTip"), TEXT("Custom Channels for Responses"));
			MetaData->SetValue(NewProp_CollisionProfileName, TEXT("Category"), TEXT("Custom"));
			MetaData->SetValue(NewProp_CollisionProfileName, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_CollisionProfileName, TEXT("ToolTip"), TEXT("Collision Profile Name *"));
			MetaData->SetValue(NewProp_ResponseToChannels, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_ResponseToChannels, TEXT("ToolTip"), TEXT("@todo : make this to be transient, so that it doesn't have to save anymore\nwe have to still load them until resave"));
			MetaData->SetValue(NewProp_Scale3D, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_Scale3D, TEXT("ToolTip"), TEXT("Current scale of physics - used to know when and how physics must be rescaled to match current transform of OwnerComponent."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBodyInstance_CRC() { return 1499022517U; }
	UScriptStruct* Z_Construct_UScriptStruct_FCollisionResponse()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FCollisionResponse_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("CollisionResponse"), sizeof(FCollisionResponse), Get_Z_Construct_UScriptStruct_FCollisionResponse_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CollisionResponse"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FCollisionResponse>, EStructFlags(0x00000201));
			UProperty* NewProp_ResponseArray = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ResponseArray"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ResponseArray, FCollisionResponse), 0x0000000000000000);
			UProperty* NewProp_ResponseArray_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ResponseArray, TEXT("ResponseArray"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FResponseChannel());
			UProperty* NewProp_ResponseToChannels = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ResponseToChannels"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ResponseToChannels, FCollisionResponse), 0x0000000000002000, Z_Construct_UScriptStruct_FCollisionResponseContainer());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_ResponseArray, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_ResponseArray, TEXT("ToolTip"), TEXT("Custom Channels for Responses"));
			MetaData->SetValue(NewProp_ResponseToChannels, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/BodyInstance.h"));
			MetaData->SetValue(NewProp_ResponseToChannels, TEXT("ToolTip"), TEXT("Types of objects that this physics objects will collide with. // @todo : make this to be transient, so that it doesn't have to save anymore\n// we have to still load them until resave"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FCollisionResponse_CRC() { return 3196400067U; }
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentEndTouchOverSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentEndTouchOverSignature_Parms
		{
			TEnumAsByte<ETouchIndex::Type> FingerIndex;
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentEndTouchOverSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentEndTouchOverSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentEndTouchOverSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_FingerIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FingerIndex"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(FingerIndex, _Script_Engine_eventComponentEndTouchOverSignature_Parms), 0x0000000000000080, Z_Construct_UEnum_InputCore_ETouchIndex());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentBeginTouchOverSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentBeginTouchOverSignature_Parms
		{
			TEnumAsByte<ETouchIndex::Type> FingerIndex;
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentBeginTouchOverSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentBeginTouchOverSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentBeginTouchOverSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_FingerIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FingerIndex"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(FingerIndex, _Script_Engine_eventComponentBeginTouchOverSignature_Parms), 0x0000000000000080, Z_Construct_UEnum_InputCore_ETouchIndex());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnInputTouchEndSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentOnInputTouchEndSignature_Parms
		{
			TEnumAsByte<ETouchIndex::Type> FingerIndex;
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentOnInputTouchEndSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentOnInputTouchEndSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentOnInputTouchEndSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_FingerIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FingerIndex"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(FingerIndex, _Script_Engine_eventComponentOnInputTouchEndSignature_Parms), 0x0000000000000080, Z_Construct_UEnum_InputCore_ETouchIndex());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnInputTouchBeginSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentOnInputTouchBeginSignature_Parms
		{
			TEnumAsByte<ETouchIndex::Type> FingerIndex;
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentOnInputTouchBeginSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentOnInputTouchBeginSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentOnInputTouchBeginSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_FingerIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FingerIndex"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(FingerIndex, _Script_Engine_eventComponentOnInputTouchBeginSignature_Parms), 0x0000000000000080, Z_Construct_UEnum_InputCore_ETouchIndex());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnReleasedSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentOnReleasedSignature_Parms
		{
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentOnReleasedSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentOnReleasedSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentOnReleasedSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentOnClickedSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentOnClickedSignature_Parms
		{
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentOnClickedSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentOnClickedSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentOnClickedSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentEndCursorOverSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentEndCursorOverSignature_Parms
		{
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentEndCursorOverSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentEndCursorOverSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentEndCursorOverSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentBeginCursorOverSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentBeginCursorOverSignature_Parms
		{
			UPrimitiveComponent* TouchedComponent;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentBeginCursorOverSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentBeginCursorOverSignature_Parms));
			UProperty* NewProp_TouchedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TouchedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TouchedComponent, _Script_Engine_eventComponentBeginCursorOverSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_TouchedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentSleepSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentSleepSignature_Parms
		{
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentSleepSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentSleepSignature_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, _Script_Engine_eventComponentSleepSignature_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate for notification when a sleep event is fired by physics"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentWakeSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentWakeSignature_Parms
		{
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentWakeSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentWakeSignature_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, _Script_Engine_eventComponentWakeSignature_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate for notification when a wake event is fired by physics"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentEndOverlapSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentEndOverlapSignature_Parms
		{
			AActor* OtherActor;
			UPrimitiveComponent* OtherComp;
			int32 OtherBodyIndex;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentEndOverlapSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentEndOverlapSignature_Parms));
			UProperty* NewProp_OtherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherBodyIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OtherBodyIndex, _Script_Engine_eventComponentEndOverlapSignature_Parms), 0x0000000000000080);
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, _Script_Engine_eventComponentEndOverlapSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_OtherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherActor, _Script_Engine_eventComponentEndOverlapSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate for notification of end of overlap with a specific component"));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentBeginOverlapSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentBeginOverlapSignature_Parms
		{
			AActor* OtherActor;
			UPrimitiveComponent* OtherComp;
			int32 OtherBodyIndex;
			bool bFromSweep;
			FHitResult SweepResult;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentBeginOverlapSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentBeginOverlapSignature_Parms));
			UProperty* NewProp_SweepResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SweepResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SweepResult, _Script_Engine_eventComponentBeginOverlapSignature_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFromSweep, _Script_Engine_eventComponentBeginOverlapSignature_Parms, bool);
			UProperty* NewProp_bFromSweep = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFromSweep"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFromSweep, _Script_Engine_eventComponentBeginOverlapSignature_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFromSweep, _Script_Engine_eventComponentBeginOverlapSignature_Parms), sizeof(bool), true);
			UProperty* NewProp_OtherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherBodyIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OtherBodyIndex, _Script_Engine_eventComponentBeginOverlapSignature_Parms), 0x0000000000000080);
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, _Script_Engine_eventComponentBeginOverlapSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_OtherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherActor, _Script_Engine_eventComponentBeginOverlapSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate for notification of start of overlap with a specific component"));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentHitSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentHitSignature_Parms
		{
			AActor* OtherActor;
			UPrimitiveComponent* OtherComp;
			FVector NormalImpulse;
			FHitResult Hit;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentHitSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentHitSignature_Parms));
			UProperty* NewProp_Hit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Hit"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Hit, _Script_Engine_eventComponentHitSignature_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_NormalImpulse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NormalImpulse"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NormalImpulse, _Script_Engine_eventComponentHitSignature_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, _Script_Engine_eventComponentHitSignature_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_OtherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherActor, _Script_Engine_eventComponentHitSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate for notification of blocking collision against a specific component.\nNormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions."));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UEnum* Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EHasCustomNavigableGeometry"), 0, Get_Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EHasCustomNavigableGeometry"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHasCustomNavigableGeometry::No")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHasCustomNavigableGeometry::Yes")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHasCustomNavigableGeometry::EvenIfNotCollidable")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHasCustomNavigableGeometry::DontExport")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHasCustomNavigableGeometry::EHasCustomNavigableGeometry_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("DontExport.ToolTip"), TEXT("Don't export navigable geometry even if primitive is relevant for navigation (can still add modifiers)"));
			MetaData->SetValue(ReturnEnum, TEXT("EvenIfNotCollidable.ToolTip"), TEXT("DoCustomNavigableGeometryExport() should be called even if the mesh is non-collidable and wouldn't normally affect the navmesh"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("No.ToolTip"), TEXT("Primitive doesn't have custom navigation geometry, if collision is enabled then its convex/trimesh collision will be used for generating the navmesh"));
			MetaData->SetValue(ReturnEnum, TEXT("Yes.ToolTip"), TEXT("If primitive would normally affect navmesh, DoCustomNavigableGeometryExport() should be called to export this primitive's navigable geometry"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry_CRC() { return 3495056237U; }
	UEnum* Z_Construct_UEnum_Engine_ECanBeCharacterBase()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ECanBeCharacterBase_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ECanBeCharacterBase"), 0, Get_Z_Construct_UEnum_Engine_ECanBeCharacterBase_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ECanBeCharacterBase"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECB_No")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECB_Yes")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECB_Owner")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECB_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ECB_No.ToolTip"), TEXT("Character cannot step up onto this Component."));
			MetaData->SetValue(ReturnEnum, TEXT("ECB_Owner.ToolTip"), TEXT("Owning actor determines whether character can step up onto this Component (default true unless overridden in code).\n@see AActor::CanBeBaseForCharacter()"));
			MetaData->SetValue(ReturnEnum, TEXT("ECB_Yes.ToolTip"), TEXT("Character can step up onto this Component."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Determines whether a Character can attempt to step up onto a component when they walk in to it."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ECanBeCharacterBase_CRC() { return 3689288455U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSpriteCategoryInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSpriteCategoryInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SpriteCategoryInfo"), sizeof(FSpriteCategoryInfo), Get_Z_Construct_UScriptStruct_FSpriteCategoryInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SpriteCategoryInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSpriteCategoryInfo>, EStructFlags(0x00000001));
			UProperty* NewProp_Description = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Description"), RF_Public|RF_Transient|RF_Native) UTextProperty(CPP_PROPERTY_BASE(Description, FSpriteCategoryInfo), 0x0000000000000000);
			UProperty* NewProp_DisplayName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DisplayName"), RF_Public|RF_Transient|RF_Native) UTextProperty(CPP_PROPERTY_BASE(DisplayName, FSpriteCategoryInfo), 0x0000000000000000);
			UProperty* NewProp_Category = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Category"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(Category, FSpriteCategoryInfo), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Information about the sprite category"));
			MetaData->SetValue(NewProp_Description, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_Description, TEXT("ToolTip"), TEXT("Localized description of the sprite category"));
			MetaData->SetValue(NewProp_DisplayName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_DisplayName, TEXT("ToolTip"), TEXT("Localized name of the sprite category"));
			MetaData->SetValue(NewProp_Category, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(NewProp_Category, TEXT("ToolTip"), TEXT("Sprite category that the component belongs to"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSpriteCategoryInfo_CRC() { return 3277778807U; }
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddAngularImpulse()
	{
		struct PrimitiveComponent_eventAddAngularImpulse_Parms
		{
			FVector Impulse;
			FName BoneName;
			bool bVelChange;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddAngularImpulse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddAngularImpulse_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVelChange, PrimitiveComponent_eventAddAngularImpulse_Parms, bool);
			UProperty* NewProp_bVelChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bVelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVelChange, PrimitiveComponent_eventAddAngularImpulse_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bVelChange, PrimitiveComponent_eventAddAngularImpulse_Parms), sizeof(bool), true);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventAddAngularImpulse_Parms), 0x0000000000000080);
			UProperty* NewProp_Impulse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Impulse"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Impulse, PrimitiveComponent_eventAddAngularImpulse_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bVelChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an angular impulse to a single rigid body. Good for one time instant burst.\n\n@param  AngularImpulse  Magnitude and direction of impulse to apply. Direction is axis of rotation.\n@param  BoneName        If a SkeletalMeshComponent, name of body to apply angular impulse to. 'None' indicates root body.\n@param  bVelChange      If true, the Strength is taken as a change in angular velocity instead of an impulse (ie. mass will have no affect)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddForce()
	{
		struct PrimitiveComponent_eventAddForce_Parms
		{
			FVector Force;
			FName BoneName;
			bool bAccelChange;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddForce_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAccelChange, PrimitiveComponent_eventAddForce_Parms, bool);
			UProperty* NewProp_bAccelChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAccelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAccelChange, PrimitiveComponent_eventAddForce_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAccelChange, PrimitiveComponent_eventAddForce_Parms), sizeof(bool), true);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventAddForce_Parms), 0x0000000000000080);
			UProperty* NewProp_Force = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Force"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Force, PrimitiveComponent_eventAddForce_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAccelChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add a force to a single rigid body.\nThis is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.\n\n@param  Force            Force vector to apply. Magnitude indicates strength of force.\n@param  BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.\n@param  bAccelChange If true, Force is taken as a change in acceleration instead of a physical force (i.e. mass will have no affect)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddForceAtLocation()
	{
		struct PrimitiveComponent_eventAddForceAtLocation_Parms
		{
			FVector Force;
			FVector Location;
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddForceAtLocation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddForceAtLocation_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventAddForceAtLocation_Parms), 0x0000000000000080);
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, PrimitiveComponent_eventAddForceAtLocation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Force = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Force"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Force, PrimitiveComponent_eventAddForceAtLocation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add a force to a single rigid body at a particular location.\nThis is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.\n\n@param Force            Force vector to apply. Magnitude indicates strength of force.\n@param Location         Location to apply force, in world space.\n@param BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddImpulse()
	{
		struct PrimitiveComponent_eventAddImpulse_Parms
		{
			FVector Impulse;
			FName BoneName;
			bool bVelChange;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddImpulse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddImpulse_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVelChange, PrimitiveComponent_eventAddImpulse_Parms, bool);
			UProperty* NewProp_bVelChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bVelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVelChange, PrimitiveComponent_eventAddImpulse_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bVelChange, PrimitiveComponent_eventAddImpulse_Parms), sizeof(bool), true);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventAddImpulse_Parms), 0x0000000000000080);
			UProperty* NewProp_Impulse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Impulse"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Impulse, PrimitiveComponent_eventAddImpulse_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bVelChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an impulse to a single rigid body. Good for one time instant burst.\n\n@param  Impulse         Magnitude and direction of impulse to apply.\n@param  BoneName        If a SkeletalMeshComponent, name of body to apply impulse to. 'None' indicates root body.\n@param  bVelChange      If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddImpulseAtLocation()
	{
		struct PrimitiveComponent_eventAddImpulseAtLocation_Parms
		{
			FVector Impulse;
			FVector Location;
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddImpulseAtLocation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddImpulseAtLocation_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventAddImpulseAtLocation_Parms), 0x0000000000000080);
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, PrimitiveComponent_eventAddImpulseAtLocation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Impulse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Impulse"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Impulse, PrimitiveComponent_eventAddImpulseAtLocation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an impulse to a single rigid body at a specific location.\n\n@param  Impulse         Magnitude and direction of impulse to apply.\n@param  Location        Point in world space to apply impulse at.\n@param  BoneName        If a SkeletalMeshComponent, name of bone to apply impulse to. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddRadialForce()
	{
		struct PrimitiveComponent_eventAddRadialForce_Parms
		{
			FVector Origin;
			float Radius;
			float Strength;
			TEnumAsByte<ERadialImpulseFalloff> Falloff;
			bool bAccelChange;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddRadialForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddRadialForce_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAccelChange, PrimitiveComponent_eventAddRadialForce_Parms, bool);
			UProperty* NewProp_bAccelChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAccelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAccelChange, PrimitiveComponent_eventAddRadialForce_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAccelChange, PrimitiveComponent_eventAddRadialForce_Parms), sizeof(bool), true);
			UProperty* NewProp_Falloff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Falloff"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Falloff, PrimitiveComponent_eventAddRadialForce_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ERadialImpulseFalloff());
			UProperty* NewProp_Strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Strength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Strength, PrimitiveComponent_eventAddRadialForce_Parms), 0x0000000000000080);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, PrimitiveComponent_eventAddRadialForce_Parms), 0x0000000000000080);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Origin, PrimitiveComponent_eventAddRadialForce_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAccelChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add a force to all bodies in this component, originating from the supplied world-space location.\n\n@param Origin           Origin of force in world space.\n@param Radius           Radius within which to apply the force.\n@param Strength         Strength of force to apply.\n@param Falloff              Allows you to control the strength of the force as a function of distance from Origin.\n@param bAccelChange If true, Strength is taken as a change in acceleration instead of a physical force (i.e. mass will have no affect)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddRadialImpulse()
	{
		struct PrimitiveComponent_eventAddRadialImpulse_Parms
		{
			FVector Origin;
			float Radius;
			float Strength;
			TEnumAsByte<ERadialImpulseFalloff> Falloff;
			bool bVelChange;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddRadialImpulse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventAddRadialImpulse_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVelChange, PrimitiveComponent_eventAddRadialImpulse_Parms, bool);
			UProperty* NewProp_bVelChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bVelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVelChange, PrimitiveComponent_eventAddRadialImpulse_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bVelChange, PrimitiveComponent_eventAddRadialImpulse_Parms), sizeof(bool), true);
			UProperty* NewProp_Falloff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Falloff"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Falloff, PrimitiveComponent_eventAddRadialImpulse_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ERadialImpulseFalloff());
			UProperty* NewProp_Strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Strength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Strength, PrimitiveComponent_eventAddRadialImpulse_Parms), 0x0000000000000080);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, PrimitiveComponent_eventAddRadialImpulse_Parms), 0x0000000000000080);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Origin, PrimitiveComponent_eventAddRadialImpulse_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bVelChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an impulse to all rigid bodies in this component, radiating out from the specified position.\n\n@param Origin                Point of origin for the radial impulse blast, in world space\n@param Radius                Size of radial impulse. Beyond this distance from Origin, there will be no affect.\n@param Strength              Maximum strength of impulse applied to body.\n@param Falloff               Allows you to control the strength of the impulse as a function of distance from Origin.\n@param bVelChange    If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_AddTorque()
	{
		struct PrimitiveComponent_eventAddTorque_Parms
		{
			FVector Torque;
			FName BoneName;
			bool bAccelChange;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddTorque"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventAddTorque_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAccelChange, PrimitiveComponent_eventAddTorque_Parms, bool);
			UProperty* NewProp_bAccelChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAccelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAccelChange, PrimitiveComponent_eventAddTorque_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAccelChange, PrimitiveComponent_eventAddTorque_Parms), sizeof(bool), true);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventAddTorque_Parms), 0x0000000000000080);
			UProperty* NewProp_Torque = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Torque"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Torque, PrimitiveComponent_eventAddTorque_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAccelChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add a torque to a single rigid body.\n@param Torque           Torque to apply. Direction is axis of rotation and magnitude is strength of torque.\n@param BoneName         If a SkeletalMeshComponent, name of body to apply torque to. 'None' indicates root body.\n@param bAccelChange If true, Torque is taken as a change in angular acceleration instead of a physical torque (i.e. mass will have no affect)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_CanCharacterStepUp()
	{
		struct PrimitiveComponent_eventCanCharacterStepUp_Parms
		{
			APawn* Pawn;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanCharacterStepUp"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventCanCharacterStepUp_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PrimitiveComponent_eventCanCharacterStepUp_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PrimitiveComponent_eventCanCharacterStepUp_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PrimitiveComponent_eventCanCharacterStepUp_Parms), sizeof(bool), true);
			UProperty* NewProp_Pawn = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Pawn"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Pawn, PrimitiveComponent_eventCanCharacterStepUp_Parms), 0x0000000000000080, Z_Construct_UClass_APawn_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return true if the given Pawn can step up onto this component.\nThis controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.\n@param Pawn the Pawn that wants to step onto this component.\n@see CanCharacterStepUpOn"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_ClearMoveIgnoreActors()
	{
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClearMoveIgnoreActors"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clear the list of actors we ignore when moving."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_CopyArrayOfMoveIgnoreActors()
	{
		struct PrimitiveComponent_eventCopyArrayOfMoveIgnoreActors_Parms
		{
			TArray<AActor*> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CopyArrayOfMoveIgnoreActors"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventCopyArrayOfMoveIgnoreActors_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventCopyArrayOfMoveIgnoreActors_Parms), 0x0000000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetMoveIgnoreActors"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the list of actors we currently ignore when moving."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic()
	{
		struct PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamic_Parms
		{
			int32 ElementIndex;
			UMaterialInstanceDynamic* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateAndSetMaterialInstanceDynamic"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamic_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamic_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister());
			UProperty* NewProp_ElementIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ElementIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ElementIndex, PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamic_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use CreateDynamicMaterialInstance instead."));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("CreateMIDForElement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a Dynamic Material Instance for the specified element index.  The parent of the instance is set to the material being replaced.\n@param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial()
	{
		struct PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamicFromMaterial_Parms
		{
			int32 ElementIndex;
			UMaterialInterface* Parent;
			UMaterialInstanceDynamic* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateAndSetMaterialInstanceDynamicFromMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamicFromMaterial_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamicFromMaterial_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister());
			UProperty* NewProp_Parent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Parent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Parent, PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamicFromMaterial_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_ElementIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ElementIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ElementIndex, PrimitiveComponent_eventCreateAndSetMaterialInstanceDynamicFromMaterial_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use CreateDynamicMaterialInstance instead."));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("CreateMIDForElementFromMaterial"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a Dynamic Material Instance for the specified element index.  The parent of the instance is set to the material being replaced.\n@param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_CreateDynamicMaterialInstance()
	{
		struct PrimitiveComponent_eventCreateDynamicMaterialInstance_Parms
		{
			int32 ElementIndex;
			UMaterialInterface* SourceMaterial;
			UMaterialInstanceDynamic* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateDynamicMaterialInstance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventCreateDynamicMaterialInstance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventCreateDynamicMaterialInstance_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister());
			UProperty* NewProp_SourceMaterial = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SourceMaterial, PrimitiveComponent_eventCreateDynamicMaterialInstance_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_ElementIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ElementIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ElementIndex, PrimitiveComponent_eventCreateDynamicMaterialInstance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a Dynamic Material Instance for the specified element index, optionally from the supplied material.\n@param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetAngularDamping()
	{
		struct PrimitiveComponent_eventGetAngularDamping_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAngularDamping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetAngularDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetAngularDamping_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the angular damping of this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCenterOfMass()
	{
		struct PrimitiveComponent_eventGetCenterOfMass_Parms
		{
			FName BoneName;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCenterOfMass"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventGetCenterOfMass_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetCenterOfMass_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetCenterOfMass_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the center of mass of a single body. In the case of a welded body this will return the center of mass of the entire welded body (including its parent and children)\nObjects that are not simulated return (0,0,0) as they do not have COM\n@param BoneName                 If a SkeletalMeshComponent, name of body to get center of mass of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetClosestPointOnCollision()
	{
		struct PrimitiveComponent_eventGetClosestPointOnCollision_Parms
		{
			FVector Point;
			FVector OutPointOnBody;
			FName BoneName;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetClosestPointOnCollision"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(PrimitiveComponent_eventGetClosestPointOnCollision_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetClosestPointOnCollision_Parms), 0x0000000000000580);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetClosestPointOnCollision_Parms), 0x0000000000000080);
			UProperty* NewProp_OutPointOnBody = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutPointOnBody"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutPointOnBody, PrimitiveComponent_eventGetClosestPointOnCollision_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Point = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Point"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Point, PrimitiveComponent_eventGetClosestPointOnCollision_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the distance and closest point to the collision surface.\nComponent must have simple collision to be queried for closest point.\n\n@param Point                          World 3D vector\n@param OutPointOnBody         Point on the surface of collision closest to Point\n@param BoneName                       If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body.\n\n@return               Success if returns > 0.f, if returns 0.f, it is either not convex or inside of the point\n                              If returns < 0.f, this primitive does not have collsion"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCollisionObjectType()
	{
		struct PrimitiveComponent_eventGetCollisionObjectType_Parms
		{
			TEnumAsByte<ECollisionChannel> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCollisionObjectType"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetCollisionObjectType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetCollisionObjectType_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_ECollisionChannel());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the collision object type"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCollisionProfileName()
	{
		struct PrimitiveComponent_eventGetCollisionProfileName_Parms
		{
			FName ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCollisionProfileName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventGetCollisionProfileName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetCollisionProfileName_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the collision profile name"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetCollisionResponseToChannel()
	{
		struct PrimitiveComponent_eventGetCollisionResponseToChannel_Parms
		{
			TEnumAsByte<ECollisionChannel> Channel;
			TEnumAsByte<ECollisionResponse> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCollisionResponseToChannel"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetCollisionResponseToChannel_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetCollisionResponseToChannel_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_ECollisionResponse());
			UProperty* NewProp_Channel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Channel"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Channel, PrimitiveComponent_eventGetCollisionResponseToChannel_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ECollisionChannel());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the response type given a specific channel"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetInertiaTensor()
	{
		struct PrimitiveComponent_eventGetInertiaTensor_Parms
		{
			FName BoneName;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInertiaTensor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(PrimitiveComponent_eventGetInertiaTensor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetInertiaTensor_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetInertiaTensor_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("physics moment of inertia tensor MOI"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the inertia tensor of this component in kg cm^2. The inertia tensor is in local component space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetLinearDamping()
	{
		struct PrimitiveComponent_eventGetLinearDamping_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLinearDamping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetLinearDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetLinearDamping_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the linear damping of this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetMass()
	{
		struct PrimitiveComponent_eventGetMass_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMass"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetMass_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetMass_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the mass of this component in kg."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetMassScale()
	{
		struct PrimitiveComponent_eventGetMassScale_Parms
		{
			FName BoneName;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMassScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetMassScale_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetMassScale_Parms), 0x0000000000000580);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetMassScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the mass scale used to calculate the mass of a single physics body"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetMaterial()
	{
		struct PrimitiveComponent_eventGetMaterial_Parms
		{
			int32 ElementIndex;
			UMaterialInterface* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetMaterial_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetMaterial_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_ElementIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ElementIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ElementIndex, PrimitiveComponent_eventGetMaterial_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the material used by the element at the specified index\n@param ElementIndex - The element to access the material of.\n@return the material used by the indexed element of this mesh."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetNumMaterials()
	{
		struct PrimitiveComponent_eventGetNumMaterials_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetNumMaterials"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventGetNumMaterials_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetNumMaterials_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return number of material elements in this primitive"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetOverlapInfos()
	{
		struct PrimitiveComponent_eventGetOverlapInfos_Parms
		{
			TArray<FOverlapInfo> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOverlapInfos"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(PrimitiveComponent_eventGetOverlapInfos_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetOverlapInfos_Parms), 0x0000000008000582);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FOverlapInfo());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns list of components this component is overlapping."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingActors()
	{
		struct PrimitiveComponent_eventGetOverlappingActors_Parms
		{
			TArray<AActor*> OverlappingActors;
			UClass* ClassFilter;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOverlappingActors"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420401, 65535, sizeof(PrimitiveComponent_eventGetOverlappingActors_Parms));
			UProperty* NewProp_ClassFilter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClassFilter"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(ClassFilter, PrimitiveComponent_eventGetOverlappingActors_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			UProperty* NewProp_OverlappingActors = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverlappingActors"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OverlappingActors, PrimitiveComponent_eventGetOverlappingActors_Parms), 0x0000000000000180);
			UProperty* NewProp_OverlappingActors_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OverlappingActors, TEXT("OverlappingActors"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a list of actors that this component is overlapping.\n@param OverlappingActors             [out] Returned list of overlapping actors\n@param ClassFilter                   [optional] If set, only returns actors of this class or subclasses"));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingComponents()
	{
		struct PrimitiveComponent_eventGetOverlappingComponents_Parms
		{
			TArray<UPrimitiveComponent*> InOverlappingComponents;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOverlappingComponents"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420401, 65535, sizeof(PrimitiveComponent_eventGetOverlappingComponents_Parms));
			UProperty* NewProp_InOverlappingComponents = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InOverlappingComponents"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InOverlappingComponents, PrimitiveComponent_eventGetOverlappingComponents_Parms), 0x0000008000000180);
			UProperty* NewProp_InOverlappingComponents_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InOverlappingComponents, TEXT("InOverlappingComponents"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000080000, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns list of components this component is overlapping."));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
			MetaData->SetValue(NewProp_InOverlappingComponents, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsAngularVelocity()
	{
		struct PrimitiveComponent_eventGetPhysicsAngularVelocity_Parms
		{
			FName BoneName;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysicsAngularVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventGetPhysicsAngularVelocity_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetPhysicsAngularVelocity_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetPhysicsAngularVelocity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the angular velocity of a single body, in degrees per second.\n@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocity()
	{
		struct PrimitiveComponent_eventGetPhysicsLinearVelocity_Parms
		{
			FName BoneName;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysicsLinearVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventGetPhysicsLinearVelocity_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetPhysicsLinearVelocity_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetPhysicsLinearVelocity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the linear velocity of a single body.\n@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint()
	{
		struct PrimitiveComponent_eventGetPhysicsLinearVelocityAtPoint_Parms
		{
			FVector Point;
			FName BoneName;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysicsLinearVelocityAtPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventGetPhysicsLinearVelocityAtPoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetPhysicsLinearVelocityAtPoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventGetPhysicsLinearVelocityAtPoint_Parms), 0x0000000000000080);
			UProperty* NewProp_Point = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Point"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Point, PrimitiveComponent_eventGetPhysicsLinearVelocityAtPoint_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the linear velocity of a point on a single body.\n@param Point                    Point is specified in world space.\n@param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_GetWalkableSlopeOverride()
	{
		struct PrimitiveComponent_eventGetWalkableSlopeOverride_Parms
		{
			FWalkableSlopeOverride ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWalkableSlopeOverride"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(PrimitiveComponent_eventGetWalkableSlopeOverride_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventGetWalkableSlopeOverride_Parms), 0x0000000008000582, Z_Construct_UScriptStruct_FWalkableSlopeOverride());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the slope override struct for this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_IgnoreActorWhenMoving()
	{
		struct PrimitiveComponent_eventIgnoreActorWhenMoving_Parms
		{
			AActor* Actor;
			bool bShouldIgnore;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IgnoreActorWhenMoving"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventIgnoreActorWhenMoving_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldIgnore, PrimitiveComponent_eventIgnoreActorWhenMoving_Parms, bool);
			UProperty* NewProp_bShouldIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bShouldIgnore"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldIgnore, PrimitiveComponent_eventIgnoreActorWhenMoving_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bShouldIgnore, PrimitiveComponent_eventIgnoreActorWhenMoving_Parms), sizeof(bool), true);
			UProperty* NewProp_Actor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Actor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Actor, PrimitiveComponent_eventIgnoreActorWhenMoving_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("Move MoveIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tells this component whether to ignore collision with all components of a specific Actor when this component is moved.\nComponents on the other Actor may also need to be told to do the same when they move.\nDoes not affect movement of this component when simulating physics."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_IsGravityEnabled()
	{
		struct PrimitiveComponent_eventIsGravityEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsGravityEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PrimitiveComponent_eventIsGravityEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PrimitiveComponent_eventIsGravityEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PrimitiveComponent_eventIsGravityEnabled_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PrimitiveComponent_eventIsGravityEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns whether this component is affected by gravity. Returns always false if the component is not simulated."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingActor()
	{
		struct PrimitiveComponent_eventIsOverlappingActor_Parms
		{
			const AActor* Other;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsOverlappingActor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(PrimitiveComponent_eventIsOverlappingActor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PrimitiveComponent_eventIsOverlappingActor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PrimitiveComponent_eventIsOverlappingActor_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PrimitiveComponent_eventIsOverlappingActor_Parms), sizeof(bool), true);
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Other, PrimitiveComponent_eventIsOverlappingActor_Parms), 0x0000000000000082, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check whether this component is overlapping any component of the given Actor.\n@param Other Actor to test this component against.\n@return Whether this component is overlapping any component of the given Actor."));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingComponent()
	{
		struct PrimitiveComponent_eventIsOverlappingComponent_Parms
		{
			const UPrimitiveComponent* OtherComp;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsOverlappingComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(PrimitiveComponent_eventIsOverlappingComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PrimitiveComponent_eventIsOverlappingComponent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PrimitiveComponent_eventIsOverlappingComponent_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PrimitiveComponent_eventIsOverlappingComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, PrimitiveComponent_eventIsOverlappingComponent_Parms), 0x0000000000080082, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check whether this component is overlapping another component.\n@param OtherComp Component to test this component against.\n@return Whether this component is overlapping another component."));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_K2_LineTraceComponent()
	{
		struct PrimitiveComponent_eventK2_LineTraceComponent_Parms
		{
			FVector TraceStart;
			FVector TraceEnd;
			bool bTraceComplex;
			bool bShowTrace;
			FVector HitLocation;
			FVector HitNormal;
			FName BoneName;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_LineTraceComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(PrimitiveComponent_eventK2_LineTraceComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PrimitiveComponent_eventK2_LineTraceComponent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PrimitiveComponent_eventK2_LineTraceComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000180);
			UProperty* NewProp_HitNormal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitNormal, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_HitLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitLocation, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowTrace, PrimitiveComponent_eventK2_LineTraceComponent_Parms, bool);
			UProperty* NewProp_bShowTrace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bShowTrace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowTrace, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bShowTrace, PrimitiveComponent_eventK2_LineTraceComponent_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, PrimitiveComponent_eventK2_LineTraceComponent_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, PrimitiveComponent_eventK2_LineTraceComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceEnd = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceEnd"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TraceEnd, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_TraceStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TraceStart, PrimitiveComponent_eventK2_LineTraceComponent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bTraceComplex"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Line Trace Component"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Perform a line trace against a single component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_PutRigidBodyToSleep()
	{
		struct PrimitiveComponent_eventPutRigidBodyToSleep_Parms
		{
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PutRigidBodyToSleep"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventPutRigidBodyToSleep_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventPutRigidBodyToSleep_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Force a single body back to sleep.\n@param  BoneName        If a SkeletalMeshComponent, name of body to put to sleep. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_ScaleByMomentOfInertia()
	{
		struct PrimitiveComponent_eventScaleByMomentOfInertia_Parms
		{
			FVector InputVector;
			FName BoneName;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ScaleByMomentOfInertia"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(PrimitiveComponent_eventScaleByMomentOfInertia_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PrimitiveComponent_eventScaleByMomentOfInertia_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventScaleByMomentOfInertia_Parms), 0x0000000000000080);
			UProperty* NewProp_InputVector = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InputVector"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InputVector, PrimitiveComponent_eventScaleByMomentOfInertia_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("physics moment of inertia tensor MOI"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Scales the given vector by the world space moment of inertia. Useful for computing the torque needed to rotate an object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetAllMassScale()
	{
		struct PrimitiveComponent_eventSetAllMassScale_Parms
		{
			float InMassScale;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllMassScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetAllMassScale_Parms));
			UProperty* NewProp_InMassScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InMassScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InMassScale, PrimitiveComponent_eventSetAllMassScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_InMassScale"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the mass scale used fo all bodies in this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetAllPhysicsLinearVelocity()
	{
		struct PrimitiveComponent_eventSetAllPhysicsLinearVelocity_Parms
		{
			FVector NewVel;
			bool bAddToCurrent;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllPhysicsLinearVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PrimitiveComponent_eventSetAllPhysicsLinearVelocity_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAddToCurrent, PrimitiveComponent_eventSetAllPhysicsLinearVelocity_Parms, bool);
			UProperty* NewProp_bAddToCurrent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAddToCurrent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAddToCurrent, PrimitiveComponent_eventSetAllPhysicsLinearVelocity_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAddToCurrent, PrimitiveComponent_eventSetAllPhysicsLinearVelocity_Parms), sizeof(bool), true);
			UProperty* NewProp_NewVel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewVel, PrimitiveComponent_eventSetAllPhysicsLinearVelocity_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAddToCurrent"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the linear velocity of all bodies in this component.\n\n@param NewVel                   New linear velocity to apply to physics.\n@param bAddToCurrent    If true, NewVel is added to the existing velocity of the body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetAngularDamping()
	{
		struct PrimitiveComponent_eventSetAngularDamping_Parms
		{
			float InDamping;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularDamping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetAngularDamping_Parms));
			UProperty* NewProp_InDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InDamping, PrimitiveComponent_eventSetAngularDamping_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the angular damping of this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCastShadow()
	{
		struct PrimitiveComponent_eventSetCastShadow_Parms
		{
			bool NewCastShadow;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCastShadow"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetCastShadow_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(NewCastShadow, PrimitiveComponent_eventSetCastShadow_Parms, bool);
			UProperty* NewProp_NewCastShadow = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewCastShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(NewCastShadow, PrimitiveComponent_eventSetCastShadow_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(NewCastShadow, PrimitiveComponent_eventSetCastShadow_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the value of CastShadow."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCenterOfMass()
	{
		struct PrimitiveComponent_eventSetCenterOfMass_Parms
		{
			FVector CenterOfMassOffset;
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCenterOfMass"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventSetCenterOfMass_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventSetCenterOfMass_Parms), 0x0000000000000080);
			UProperty* NewProp_CenterOfMassOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CenterOfMassOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CenterOfMassOffset, PrimitiveComponent_eventSetCenterOfMass_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the center of mass of a single body. This will offset the physx-calculated center of mass.\nNote that in the case where multiple bodies are attached together, the center of mass will be set for the entire group.\n@param CenterOfMassOffset               User specified offset for the center of mass of this object, from the calculated location.\n@param BoneName                 If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionEnabled()
	{
		struct PrimitiveComponent_eventSetCollisionEnabled_Parms
		{
			TEnumAsByte<ECollisionEnabled::Type> NewType;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCollisionEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetCollisionEnabled_Parms));
			UProperty* NewProp_NewType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewType, PrimitiveComponent_eventSetCollisionEnabled_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ECollisionEnabled());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Controls what kind of collision is enabled for this body"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionObjectType()
	{
		struct PrimitiveComponent_eventSetCollisionObjectType_Parms
		{
			TEnumAsByte<ECollisionChannel> Channel;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCollisionObjectType"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetCollisionObjectType_Parms));
			UProperty* NewProp_Channel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Channel"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Channel, PrimitiveComponent_eventSetCollisionObjectType_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ECollisionChannel());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the collision channel that this object uses when it moves\n@param      Channel     The new channel for this component to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionProfileName()
	{
		struct PrimitiveComponent_eventSetCollisionProfileName_Parms
		{
			FName InCollisionProfileName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCollisionProfileName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetCollisionProfileName_Parms));
			UProperty* NewProp_InCollisionProfileName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InCollisionProfileName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InCollisionProfileName, PrimitiveComponent_eventSetCollisionProfileName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set Collision Profile Name\nThis function is called by constructors when they set ProfileName\nThis will change current CollisionProfileName to be this, and overwrite Collision Setting\n\n@param InCollisionProfileName : New Profile Name"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToAllChannels()
	{
		struct PrimitiveComponent_eventSetCollisionResponseToAllChannels_Parms
		{
			TEnumAsByte<ECollisionResponse> NewResponse;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCollisionResponseToAllChannels"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetCollisionResponseToAllChannels_Parms));
			UProperty* NewProp_NewResponse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewResponse"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewResponse, PrimitiveComponent_eventSetCollisionResponseToAllChannels_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ECollisionResponse());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes all ResponseToChannels container for this PrimitiveComponent. to be NewResponse\n\n@param       NewResponse  What the new response should be to the supplied Channel"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToChannel()
	{
		struct PrimitiveComponent_eventSetCollisionResponseToChannel_Parms
		{
			TEnumAsByte<ECollisionChannel> Channel;
			TEnumAsByte<ECollisionResponse> NewResponse;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCollisionResponseToChannel"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetCollisionResponseToChannel_Parms));
			UProperty* NewProp_NewResponse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewResponse"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewResponse, PrimitiveComponent_eventSetCollisionResponseToChannel_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ECollisionResponse());
			UProperty* NewProp_Channel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Channel"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Channel, PrimitiveComponent_eventSetCollisionResponseToChannel_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ECollisionChannel());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes a member of the ResponseToChannels container for this PrimitiveComponent.\n\n@param       Channel      The channel to change the response of\n@param       NewResponse  What the new response should be to the supplied Channel"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetConstraintMode()
	{
		struct PrimitiveComponent_eventSetConstraintMode_Parms
		{
			TEnumAsByte<EDOFMode::Type> ConstraintMode;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetConstraintMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetConstraintMode_Parms));
			UProperty* NewProp_ConstraintMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstraintMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ConstraintMode, PrimitiveComponent_eventSetConstraintMode_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EDOFMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set Constraint Mode"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("set locked axis constraint physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the constraint mode of the component.\n@param ConstraintMode        The type of constraint to use."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCullDistance()
	{
		struct PrimitiveComponent_eventSetCullDistance_Parms
		{
			float NewCullDistance;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCullDistance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetCullDistance_Parms));
			UProperty* NewProp_NewCullDistance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewCullDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewCullDistance, PrimitiveComponent_eventSetCullDistance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LOD"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set Max Draw Distance"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the value of CullDistance.\n@param NewCullDistance - The value to assign to CullDistance."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetCustomDepthStencilValue()
	{
		struct PrimitiveComponent_eventSetCustomDepthStencilValue_Parms
		{
			int32 Value;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCustomDepthStencilValue"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetCustomDepthStencilValue_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Value, PrimitiveComponent_eventSetCustomDepthStencilValue_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the CustomDepth stencil value (0 - 255) and marks the render state dirty."));
			MetaData->SetValue(ReturnFunction, TEXT("UIMax"), TEXT("255"));
			MetaData->SetValue(ReturnFunction, TEXT("UIMin"), TEXT("0"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetEnableGravity()
	{
		struct PrimitiveComponent_eventSetEnableGravity_Parms
		{
			bool bGravityEnabled;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnableGravity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetEnableGravity_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGravityEnabled, PrimitiveComponent_eventSetEnableGravity_Parms, bool);
			UProperty* NewProp_bGravityEnabled = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bGravityEnabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGravityEnabled, PrimitiveComponent_eventSetEnableGravity_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bGravityEnabled, PrimitiveComponent_eventSetEnableGravity_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables/disables whether this component is affected by gravity. This applies only to components with bSimulatePhysics set to true."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetLinearDamping()
	{
		struct PrimitiveComponent_eventSetLinearDamping_Parms
		{
			float InDamping;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearDamping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetLinearDamping_Parms));
			UProperty* NewProp_InDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InDamping, PrimitiveComponent_eventSetLinearDamping_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the linear damping of this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetLockedAxis()
	{
		struct PrimitiveComponent_eventSetLockedAxis_Parms
		{
			TEnumAsByte<EDOFMode::Type> LockedAxis;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLockedAxis"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetLockedAxis_Parms));
			UProperty* NewProp_LockedAxis = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LockedAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LockedAxis, PrimitiveComponent_eventSetLockedAxis_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EDOFMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use SetConstraintMode instead"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("set locked axis constraint physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetMassOverrideInKg()
	{
		struct PrimitiveComponent_eventSetMassOverrideInKg_Parms
		{
			FName BoneName;
			float MassInKg;
			bool bOverrideMass;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMassOverrideInKg"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetMassOverrideInKg_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMass, PrimitiveComponent_eventSetMassOverrideInKg_Parms, bool);
			UProperty* NewProp_bOverrideMass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bOverrideMass"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMass, PrimitiveComponent_eventSetMassOverrideInKg_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bOverrideMass, PrimitiveComponent_eventSetMassOverrideInKg_Parms), sizeof(bool), true);
			UProperty* NewProp_MassInKg = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MassInKg"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MassInKg, PrimitiveComponent_eventSetMassOverrideInKg_Parms), 0x0000000000000080);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventSetMassOverrideInKg_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bOverrideMass"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_MassInKg"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Override the mass (in Kg) of a single physics body.\nNote that in the case where multiple bodies are attached together, the override mass will be set for the entire group.\nSet the Override Mass to false if you want to reset the body's mass to the auto-calculated physx mass."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetMassScale()
	{
		struct PrimitiveComponent_eventSetMassScale_Parms
		{
			FName BoneName;
			float InMassScale;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMassScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetMassScale_Parms));
			UProperty* NewProp_InMassScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InMassScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InMassScale, PrimitiveComponent_eventSetMassScale_Parms), 0x0000000000000080);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventSetMassScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_InMassScale"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the mass scale used to calculate the mass of a single physics body"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetMaterial()
	{
		struct PrimitiveComponent_eventSetMaterial_Parms
		{
			int32 ElementIndex;
			UMaterialInterface* Material;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetMaterial_Parms));
			UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, PrimitiveComponent_eventSetMaterial_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_ElementIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ElementIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ElementIndex, PrimitiveComponent_eventSetMaterial_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the material applied to an element of the mesh.\n@param ElementIndex - The element to access the material of.\n@return the material used by the indexed element of this mesh."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetNotifyRigidBodyCollision()
	{
		struct PrimitiveComponent_eventSetNotifyRigidBodyCollision_Parms
		{
			bool bNewNotifyRigidBodyCollision;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNotifyRigidBodyCollision"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetNotifyRigidBodyCollision_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewNotifyRigidBodyCollision, PrimitiveComponent_eventSetNotifyRigidBodyCollision_Parms, bool);
			UProperty* NewProp_bNewNotifyRigidBodyCollision = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewNotifyRigidBodyCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewNotifyRigidBodyCollision, PrimitiveComponent_eventSetNotifyRigidBodyCollision_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewNotifyRigidBodyCollision, PrimitiveComponent_eventSetNotifyRigidBodyCollision_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the value of bNotifyRigidBodyCollision\n@param bNewNotifyRigidBodyCollision - The value to assign to bNotifyRigidBodyCollision"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetOnlyOwnerSee()
	{
		struct PrimitiveComponent_eventSetOnlyOwnerSee_Parms
		{
			bool bNewOnlyOwnerSee;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetOnlyOwnerSee"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetOnlyOwnerSee_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewOnlyOwnerSee, PrimitiveComponent_eventSetOnlyOwnerSee_Parms, bool);
			UProperty* NewProp_bNewOnlyOwnerSee = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewOnlyOwnerSee"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewOnlyOwnerSee, PrimitiveComponent_eventSetOnlyOwnerSee_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewOnlyOwnerSee, PrimitiveComponent_eventSetOnlyOwnerSee_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the value of bOnlyOwnerSee."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetOwnerNoSee()
	{
		struct PrimitiveComponent_eventSetOwnerNoSee_Parms
		{
			bool bNewOwnerNoSee;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetOwnerNoSee"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetOwnerNoSee_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewOwnerNoSee, PrimitiveComponent_eventSetOwnerNoSee_Parms, bool);
			UProperty* NewProp_bNewOwnerNoSee = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewOwnerNoSee"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewOwnerNoSee, PrimitiveComponent_eventSetOwnerNoSee_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewOwnerNoSee, PrimitiveComponent_eventSetOwnerNoSee_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the value of bOwnerNoSee."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsAngularVelocity()
	{
		struct PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms
		{
			FVector NewAngVel;
			bool bAddToCurrent;
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPhysicsAngularVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAddToCurrent, PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms, bool);
			UProperty* NewProp_bAddToCurrent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAddToCurrent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAddToCurrent, PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAddToCurrent, PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms), sizeof(bool), true);
			UProperty* NewProp_NewAngVel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAngVel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewAngVel, PrimitiveComponent_eventSetPhysicsAngularVelocity_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAddToCurrent"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the angular velocity of a single body.\nThis should be used cautiously - it may be better to use AddTorque or AddImpulse.\n\n@param NewAngVel                New angular velocity to apply to body, in degrees per second.\n@param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of the body.\n@param BoneName                 If a SkeletalMeshComponent, name of body to modify angular velocity of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsLinearVelocity()
	{
		struct PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms
		{
			FVector NewVel;
			bool bAddToCurrent;
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPhysicsLinearVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAddToCurrent, PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms, bool);
			UProperty* NewProp_bAddToCurrent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAddToCurrent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAddToCurrent, PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAddToCurrent, PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms), sizeof(bool), true);
			UProperty* NewProp_NewVel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewVel, PrimitiveComponent_eventSetPhysicsLinearVelocity_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAddToCurrent"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the linear velocity of a single body.\nThis should be used cautiously - it may be better to use AddForce or AddImpulse.\n\n@param NewVel                   New linear velocity to apply to physics.\n@param bAddToCurrent    If true, NewVel is added to the existing velocity of the body.\n@param BoneName                 If a SkeletalMeshComponent, name of body to modify velocity of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsMaxAngularVelocity()
	{
		struct PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms
		{
			float NewMaxAngVel;
			bool bAddToCurrent;
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPhysicsMaxAngularVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAddToCurrent, PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms, bool);
			UProperty* NewProp_bAddToCurrent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAddToCurrent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAddToCurrent, PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bAddToCurrent, PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms), sizeof(bool), true);
			UProperty* NewProp_NewMaxAngVel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMaxAngVel"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewMaxAngVel, PrimitiveComponent_eventSetPhysicsMaxAngularVelocity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAddToCurrent"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the maximum angular velocity of a single body.\n\n@param NewMaxAngVel             New maximum angular velocity to apply to body, in degrees per second.\n@param bAddToCurrent    If true, NewMaxAngVel is added to the existing maximum angular velocity of the body.\n@param BoneName                 If a SkeletalMeshComponent, name of body to modify maximum angular velocity of. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetPhysMaterialOverride()
	{
		struct PrimitiveComponent_eventSetPhysMaterialOverride_Parms
		{
			UPhysicalMaterial* NewPhysMaterial;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPhysMaterialOverride"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetPhysMaterialOverride_Parms));
			UProperty* NewProp_NewPhysMaterial = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewPhysMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewPhysMaterial, PrimitiveComponent_eventSetPhysMaterialOverride_Parms), 0x0000000000000080, Z_Construct_UClass_UPhysicalMaterial_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set PhysicalMaterial Override"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the current PhysMaterialOverride for this component.\nNote that if physics is already running on this component, this will _not_ alter its mass/inertia etc,\nit will only change its surface properties like friction."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetRenderCustomDepth()
	{
		struct PrimitiveComponent_eventSetRenderCustomDepth_Parms
		{
			bool bValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetRenderCustomDepth"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetRenderCustomDepth_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bValue, PrimitiveComponent_eventSetRenderCustomDepth_Parms, bool);
			UProperty* NewProp_bValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bValue, PrimitiveComponent_eventSetRenderCustomDepth_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bValue, PrimitiveComponent_eventSetRenderCustomDepth_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the bRenderCustomDepth property and marks the render state dirty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetRenderInMainPass()
	{
		struct PrimitiveComponent_eventSetRenderInMainPass_Parms
		{
			bool bValue;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetRenderInMainPass"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetRenderInMainPass_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bValue, PrimitiveComponent_eventSetRenderInMainPass_Parms, bool);
			UProperty* NewProp_bValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bValue, PrimitiveComponent_eventSetRenderInMainPass_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bValue, PrimitiveComponent_eventSetRenderInMainPass_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets bRenderInMainPass property and marks the render state dirty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetSimulatePhysics()
	{
		struct PrimitiveComponent_eventSetSimulatePhysics_Parms
		{
			bool bSimulate;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSimulatePhysics"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventSetSimulatePhysics_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, PrimitiveComponent_eventSetSimulatePhysics_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, PrimitiveComponent_eventSetSimulatePhysics_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, PrimitiveComponent_eventSetSimulatePhysics_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets whether or not a single body should use physics simulation, or should be 'fixed' (kinematic).\n\n@param  bSimulate       New simulation state for single body"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetTranslucentSortPriority()
	{
		struct PrimitiveComponent_eventSetTranslucentSortPriority_Parms
		{
			int32 NewTranslucentSortPriority;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTranslucentSortPriority"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PrimitiveComponent_eventSetTranslucentSortPriority_Parms));
			UProperty* NewProp_NewTranslucentSortPriority = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTranslucentSortPriority"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewTranslucentSortPriority, PrimitiveComponent_eventSetTranslucentSortPriority_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Changes the value of TranslucentSortPriority."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_SetWalkableSlopeOverride()
	{
		struct PrimitiveComponent_eventSetWalkableSlopeOverride_Parms
		{
			FWalkableSlopeOverride NewOverride;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetWalkableSlopeOverride"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(PrimitiveComponent_eventSetWalkableSlopeOverride_Parms));
			UProperty* NewProp_NewOverride = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewOverride"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewOverride, PrimitiveComponent_eventSetWalkableSlopeOverride_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FWalkableSlopeOverride());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets a new slope override for this component instance."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_WakeAllRigidBodies()
	{
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WakeAllRigidBodies"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Ensure simulation is running for all bodies in this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPrimitiveComponent_WakeRigidBody()
	{
		struct PrimitiveComponent_eventWakeRigidBody_Parms
		{
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPrimitiveComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WakeRigidBody"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(PrimitiveComponent_eventWakeRigidBody_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PrimitiveComponent_eventWakeRigidBody_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_BoneName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("'Wake' physics simulation for a single body.\n@param  BoneName        If a SkeletalMeshComponent, name of body to wake. 'None' indicates root body."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister()
	{
		return UPrimitiveComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPrimitiveComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPrimitiveComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddAngularImpulse());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddForce());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddForceAtLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddImpulse());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddImpulseAtLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddRadialForce());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddRadialImpulse());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_AddTorque());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_CanCharacterStepUp());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_ClearMoveIgnoreActors());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_CopyArrayOfMoveIgnoreActors());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_CreateDynamicMaterialInstance());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetAngularDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetCenterOfMass());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetClosestPointOnCollision());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetCollisionObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetCollisionProfileName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetCollisionResponseToChannel());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetInertiaTensor());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetLinearDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetMass());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetMassScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetNumMaterials());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetOverlapInfos());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingActors());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingComponents());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsAngularVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_GetWalkableSlopeOverride());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_IgnoreActorWhenMoving());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_IsGravityEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_K2_LineTraceComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_PutRigidBodyToSleep());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_ScaleByMomentOfInertia());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetAllMassScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetAllPhysicsLinearVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetAngularDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCastShadow());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCenterOfMass());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionProfileName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToAllChannels());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToChannel());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetConstraintMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCullDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetCustomDepthStencilValue());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetEnableGravity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetLinearDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetLockedAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetMassOverrideInKg());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetMassScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetNotifyRigidBodyCollision());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetOnlyOwnerSee());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetOwnerNoSee());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsAngularVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsLinearVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsMaxAngularVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetPhysMaterialOverride());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetRenderCustomDepth());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetRenderInMainPass());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetSimulatePhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetTranslucentSortPriority());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_SetWalkableSlopeOverride());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_WakeAllRigidBodies());
				OuterClass->LinkChild(Z_Construct_UFunction_UPrimitiveComponent_WakeRigidBody());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PostPhysicsComponentTick = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PostPhysicsComponentTick"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PostPhysicsComponentTick, UPrimitiveComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FPrimitiveComponentPostPhysicsTickFunction());
				UProperty* NewProp_LODParentPrimitive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODParentPrimitive"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LODParentPrimitive, UPrimitiveComponent), 0x0000000000280008, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
				UProperty* NewProp_OnInputTouchLeave = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInputTouchLeave"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInputTouchLeave, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentEndTouchOverSignature__DelegateSignature());
				UProperty* NewProp_OnInputTouchEnter = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInputTouchEnter"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInputTouchEnter, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentBeginTouchOverSignature__DelegateSignature());
				UProperty* NewProp_OnInputTouchEnd = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInputTouchEnd"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInputTouchEnd, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentOnInputTouchEndSignature__DelegateSignature());
				UProperty* NewProp_OnInputTouchBegin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInputTouchBegin"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInputTouchBegin, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentOnInputTouchBeginSignature__DelegateSignature());
				UProperty* NewProp_OnReleased = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnReleased"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnReleased, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentOnReleasedSignature__DelegateSignature());
				UProperty* NewProp_OnClicked = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnClicked"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnClicked, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentOnClickedSignature__DelegateSignature());
				UProperty* NewProp_OnEndCursorOver = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnEndCursorOver"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnEndCursorOver, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentEndCursorOverSignature__DelegateSignature());
				UProperty* NewProp_OnBeginCursorOver = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnBeginCursorOver"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnBeginCursorOver, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentBeginCursorOverSignature__DelegateSignature());
				UProperty* NewProp_OnComponentSleep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnComponentSleep"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnComponentSleep, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentSleepSignature__DelegateSignature());
				UProperty* NewProp_OnComponentWake = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnComponentWake"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnComponentWake, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentWakeSignature__DelegateSignature());
				UProperty* NewProp_OnComponentEndOverlap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnComponentEndOverlap"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnComponentEndOverlap, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentEndOverlapSignature__DelegateSignature());
				UProperty* NewProp_OnComponentBeginOverlap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnComponentBeginOverlap"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnComponentBeginOverlap, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentBeginOverlapSignature__DelegateSignature());
				UProperty* NewProp_OnComponentHit = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnComponentHit"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnComponentHit, UPrimitiveComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentHitSignature__DelegateSignature());
				UProperty* NewProp_CanCharacterStepUpOn = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CanCharacterStepUpOn"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CanCharacterStepUpOn, UPrimitiveComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_ECanBeCharacterBase());
				UProperty* NewProp_CanBeCharacterBase = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CanBeCharacterBase"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CanBeCharacterBase_DEPRECATED, UPrimitiveComponent), 0x0000000020000000, Z_Construct_UEnum_Engine_ECanBeCharacterBase());
				UProperty* NewProp_LastRenderTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastRenderTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastRenderTime, UPrimitiveComponent), 0x0000000000002000);
				UProperty* NewProp_LastSubmitTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastSubmitTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastSubmitTime, UPrimitiveComponent), 0x0000000000002000);
				UProperty* NewProp_BoundsScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoundsScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BoundsScale, UPrimitiveComponent), 0x0000040000000001);
				UProperty* NewProp_bHasCustomNavigableGeometry = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasCustomNavigableGeometry"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(bHasCustomNavigableGeometry, UPrimitiveComponent), 0x0000080000000000, Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanEverAffectNavigation, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCanEverAffectNavigation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanEverAffectNavigation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanEverAffectNavigation, UPrimitiveComponent), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bCanEverAffectNavigation, UPrimitiveComponent), sizeof(uint8), false);
				UProperty* NewProp_BodyInstance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BodyInstance"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BodyInstance, UPrimitiveComponent), 0x0000000000000015, Z_Construct_UScriptStruct_FBodyInstance());
				UProperty* NewProp_LpvBiasMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LpvBiasMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LpvBiasMultiplier, UPrimitiveComponent), 0x0000040000000015);
				UProperty* NewProp_VisibilityId = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VisibilityId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(VisibilityId, UPrimitiveComponent), 0x0000000000000000);
				UProperty* NewProp_TranslucencySortPriority = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TranslucencySortPriority"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TranslucencySortPriority, UPrimitiveComponent), 0x0000040000000015);
				UProperty* NewProp_CustomDepthStencilValue = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomDepthStencilValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(CustomDepthStencilValue, UPrimitiveComponent), 0x0000040000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRenderCustomDepth, UPrimitiveComponent, uint8);
				UProperty* NewProp_bRenderCustomDepth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRenderCustomDepth"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRenderCustomDepth, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bRenderCustomDepth, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseEditorCompositing, UPrimitiveComponent, uint8);
				UProperty* NewProp_bUseEditorCompositing = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseEditorCompositing"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseEditorCompositing, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUseEditorCompositing, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(AlwaysLoadOnServer, UPrimitiveComponent, uint8);
				UProperty* NewProp_AlwaysLoadOnServer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AlwaysLoadOnServer"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AlwaysLoadOnServer, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(AlwaysLoadOnServer, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(AlwaysLoadOnClient, UPrimitiveComponent, uint8);
				UProperty* NewProp_AlwaysLoadOnClient = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AlwaysLoadOnClient"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AlwaysLoadOnClient, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(AlwaysLoadOnClient, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreRadialForce, UPrimitiveComponent, uint8);
				UProperty* NewProp_bIgnoreRadialForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreRadialForce"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreRadialForce, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bIgnoreRadialForce, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreRadialImpulse, UPrimitiveComponent, uint8);
				UProperty* NewProp_bIgnoreRadialImpulse = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreRadialImpulse"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreRadialImpulse, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bIgnoreRadialImpulse, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStaticLightingBuildEnqueued, UPrimitiveComponent, bool);
				UProperty* NewProp_bStaticLightingBuildEnqueued = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bStaticLightingBuildEnqueued"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStaticLightingBuildEnqueued, UPrimitiveComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bStaticLightingBuildEnqueued, UPrimitiveComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasCachedStaticLighting, UPrimitiveComponent, bool);
				UProperty* NewProp_bHasCachedStaticLighting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasCachedStaticLighting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasCachedStaticLighting, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasCachedStaticLighting, UPrimitiveComponent), sizeof(bool), true);
				UProperty* NewProp_IndirectLightingCacheQuality = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IndirectLightingCacheQuality"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(IndirectLightingCacheQuality, UPrimitiveComponent), 0x0000040000000015, Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLightAttachmentsAsGroup, UPrimitiveComponent, uint8);
				UProperty* NewProp_bLightAttachmentsAsGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLightAttachmentsAsGroup"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLightAttachmentsAsGroup, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bLightAttachmentsAsGroup, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLightAsIfStatic, UPrimitiveComponent, uint8);
				UProperty* NewProp_bLightAsIfStatic = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLightAsIfStatic"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLightAsIfStatic, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bLightAsIfStatic, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastShadowAsTwoSided, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastShadowAsTwoSided = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastShadowAsTwoSided"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastShadowAsTwoSided, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastShadowAsTwoSided, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastHiddenShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastHiddenShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastHiddenShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastHiddenShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastHiddenShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastCinematicShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastCinematicShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastCinematicShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastCinematicShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastCinematicShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastInsetShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastInsetShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastInsetShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastInsetShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastInsetShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastFarShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastFarShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastFarShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastFarShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastFarShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSelfShadowOnly, UPrimitiveComponent, uint8);
				UProperty* NewProp_bSelfShadowOnly = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSelfShadowOnly"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSelfShadowOnly, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bSelfShadowOnly, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastVolumetricTranslucentShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastVolumetricTranslucentShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastVolumetricTranslucentShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastVolumetricTranslucentShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastVolumetricTranslucentShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastStaticShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastStaticShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastStaticShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastStaticShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastStaticShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastDynamicShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCastDynamicShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastDynamicShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastDynamicShadow, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastDynamicShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAffectDistanceFieldLighting, UPrimitiveComponent, uint8);
				UProperty* NewProp_bAffectDistanceFieldLighting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAffectDistanceFieldLighting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAffectDistanceFieldLighting, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bAffectDistanceFieldLighting, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAffectDynamicIndirectLighting, UPrimitiveComponent, uint8);
				UProperty* NewProp_bAffectDynamicIndirectLighting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAffectDynamicIndirectLighting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAffectDynamicIndirectLighting, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bAffectDynamicIndirectLighting, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(CastShadow, UPrimitiveComponent, uint8);
				UProperty* NewProp_CastShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CastShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(CastShadow, UPrimitiveComponent), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(CastShadow, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasPerInstanceHitProxies, UPrimitiveComponent, uint8);
				UProperty* NewProp_bHasPerInstanceHitProxies = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasPerInstanceHitProxies"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasPerInstanceHitProxies, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasPerInstanceHitProxies, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceMipStreaming, UPrimitiveComponent, uint8);
				UProperty* NewProp_bForceMipStreaming = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceMipStreaming"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceMipStreaming, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bForceMipStreaming, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSelectable, UPrimitiveComponent, uint8);
				UProperty* NewProp_bSelectable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSelectable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSelectable, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bSelectable, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseAsOccluder, UPrimitiveComponent, uint8);
				UProperty* NewProp_bUseAsOccluder = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseAsOccluder"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseAsOccluder, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bUseAsOccluder, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTreatAsBackgroundForOcclusion, UPrimitiveComponent, uint8);
				UProperty* NewProp_bTreatAsBackgroundForOcclusion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bTreatAsBackgroundForOcclusion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTreatAsBackgroundForOcclusion, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bTreatAsBackgroundForOcclusion, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOnlyOwnerSee, UPrimitiveComponent, uint8);
				UProperty* NewProp_bOnlyOwnerSee = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOnlyOwnerSee"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOnlyOwnerSee, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bOnlyOwnerSee, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOwnerNoSee, UPrimitiveComponent, uint8);
				UProperty* NewProp_bOwnerNoSee = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOwnerNoSee"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOwnerNoSee, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bOwnerNoSee, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bReceivesDecals, UPrimitiveComponent, uint8);
				UProperty* NewProp_bReceivesDecals = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bReceivesDecals"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bReceivesDecals, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bReceivesDecals, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRenderInMainPass, UPrimitiveComponent, uint8);
				UProperty* NewProp_bRenderInMainPass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRenderInMainPass"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRenderInMainPass, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bRenderInMainPass, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasMotionBlurVelocityMeshes, UPrimitiveComponent, uint8);
				UProperty* NewProp_bHasMotionBlurVelocityMeshes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasMotionBlurVelocityMeshes"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasMotionBlurVelocityMeshes, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHasMotionBlurVelocityMeshes, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowCullDistanceVolume, UPrimitiveComponent, uint8);
				UProperty* NewProp_bAllowCullDistanceVolume = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowCullDistanceVolume"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowCullDistanceVolume, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bAllowCullDistanceVolume, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseViewOwnerDepthPriorityGroup, UPrimitiveComponent, uint8);
				UProperty* NewProp_bUseViewOwnerDepthPriorityGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseViewOwnerDepthPriorityGroup"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseViewOwnerDepthPriorityGroup, UPrimitiveComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUseViewOwnerDepthPriorityGroup, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bReturnMaterialOnMove, UPrimitiveComponent, uint8);
				UProperty* NewProp_bReturnMaterialOnMove = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bReturnMaterialOnMove"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bReturnMaterialOnMove, UPrimitiveComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bReturnMaterialOnMove, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplexOnMove, UPrimitiveComponent, uint8);
				UProperty* NewProp_bTraceComplexOnMove = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bTraceComplexOnMove"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplexOnMove, UPrimitiveComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bTraceComplexOnMove, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCheckAsyncSceneOnMove, UPrimitiveComponent, uint8);
				UProperty* NewProp_bCheckAsyncSceneOnMove = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCheckAsyncSceneOnMove"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCheckAsyncSceneOnMove, UPrimitiveComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bCheckAsyncSceneOnMove, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bMultiBodyOverlap, UPrimitiveComponent, uint8);
				UProperty* NewProp_bMultiBodyOverlap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bMultiBodyOverlap"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bMultiBodyOverlap, UPrimitiveComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bMultiBodyOverlap, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGenerateOverlapEvents, UPrimitiveComponent, uint8);
				UProperty* NewProp_bGenerateOverlapEvents = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bGenerateOverlapEvents"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGenerateOverlapEvents, UPrimitiveComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bGenerateOverlapEvents, UPrimitiveComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAlwaysCreatePhysicsState, UPrimitiveComponent, uint8);
				UProperty* NewProp_bAlwaysCreatePhysicsState = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAlwaysCreatePhysicsState"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAlwaysCreatePhysicsState, UPrimitiveComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bAlwaysCreatePhysicsState, UPrimitiveComponent), sizeof(uint8), false);
				UProperty* NewProp_ViewOwnerDepthPriorityGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ViewOwnerDepthPriorityGroup"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ViewOwnerDepthPriorityGroup, UPrimitiveComponent), 0x0000000000000000, Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup());
				UProperty* NewProp_DepthPriorityGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DepthPriorityGroup"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DepthPriorityGroup, UPrimitiveComponent), 0x0000000000000000, Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup());
				UProperty* NewProp_CachedMaxDrawDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedMaxDrawDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CachedMaxDrawDistance, UPrimitiveComponent), 0x0000040000020015);
				UProperty* NewProp_LDMaxDrawDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LDMaxDrawDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LDMaxDrawDistance, UPrimitiveComponent), 0x0000040000000015);
				UProperty* NewProp_MinDrawDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinDrawDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinDrawDistance, UPrimitiveComponent), 0x0000040000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddAngularImpulse()); // 3836876872
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddForce()); // 2040260940
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddForceAtLocation()); // 626971692
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddImpulse()); // 1736586918
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddImpulseAtLocation()); // 4204075062
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddRadialForce()); // 3144201941
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddRadialImpulse()); // 3060314265
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_AddTorque()); // 2518332469
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_CanCharacterStepUp()); // 1669291219
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_ClearMoveIgnoreActors()); // 1550101349
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_CopyArrayOfMoveIgnoreActors()); // 1993618644
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic()); // 2739878171
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial()); // 538860077
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_CreateDynamicMaterialInstance()); // 2632776658
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetAngularDamping()); // 3884216723
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetCenterOfMass()); // 3615561745
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetClosestPointOnCollision()); // 3524693194
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetCollisionObjectType()); // 2913431530
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetCollisionProfileName()); // 3775593867
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetCollisionResponseToChannel()); // 1638078689
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetInertiaTensor()); // 649627267
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetLinearDamping()); // 3987532719
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetMass()); // 1371464056
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetMassScale()); // 137807004
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetMaterial()); // 751985157
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetNumMaterials()); // 3043908216
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetOverlapInfos()); // 801295178
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingActors()); // 1121260996
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetOverlappingComponents()); // 2762171132
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsAngularVelocity()); // 1151267400
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocity()); // 1751166815
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint()); // 780909493
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_GetWalkableSlopeOverride()); // 667015595
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_IgnoreActorWhenMoving()); // 3617800480
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_IsGravityEnabled()); // 2564999089
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingActor()); // 3575116736
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_IsOverlappingComponent()); // 1736594891
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_K2_LineTraceComponent()); // 2119203357
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_PutRigidBodyToSleep()); // 4092607120
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_ScaleByMomentOfInertia()); // 1672712886
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetAllMassScale()); // 1045852633
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetAllPhysicsLinearVelocity()); // 2555092192
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetAngularDamping()); // 359321895
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCastShadow()); // 2830297730
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCenterOfMass()); // 4096090262
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionEnabled()); // 1397201488
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionObjectType()); // 954673291
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionProfileName()); // 1926310462
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToAllChannels()); // 1468514847
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCollisionResponseToChannel()); // 1229537913
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetConstraintMode()); // 3288301466
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCullDistance()); // 1404598555
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetCustomDepthStencilValue()); // 1415653157
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetEnableGravity()); // 4145911729
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetLinearDamping()); // 3624287867
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetLockedAxis()); // 2494296787
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetMassOverrideInKg()); // 669265383
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetMassScale()); // 2181030167
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetMaterial()); // 2194120077
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetNotifyRigidBodyCollision()); // 145161120
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetOnlyOwnerSee()); // 3585182025
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetOwnerNoSee()); // 1844102275
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsAngularVelocity()); // 1244486199
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsLinearVelocity()); // 466437379
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetPhysicsMaxAngularVelocity()); // 2219967368
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetPhysMaterialOverride()); // 838096094
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetRenderCustomDepth()); // 2893175469
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetRenderInMainPass()); // 424135314
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetSimulatePhysics()); // 1932832865
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetTranslucentSortPriority()); // 85569160
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_SetWalkableSlopeOverride()); // 915020479
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_WakeAllRigidBodies()); // 1377235739
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPrimitiveComponent_WakeRigidBody()); // 2369098911
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UNavRelevantInterface_NoRegister(), VTABLE_OFFSET(UPrimitiveComponent, INavRelevantInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PrimitiveComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("PrimitiveComponents are SceneComponents that contain or generate some sort of geometry, generally to be rendered or used as collision data.\nThere are several subclasses for the various types of geometry, but the most common by far are the ShapeComponents (Capsule, Sphere, Box), StaticMeshComponent, and SkeletalMeshComponent.\nShapeComponents generate geometry that is used for collision detection but are not rendered, while StaticMeshComponents and SkeletalMeshComponents contain pre-built geometry that is rendered, but can also be used for collision detection."));
				MetaData->SetValue(NewProp_PostPhysicsComponentTick, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_PostPhysicsComponentTick, TEXT("ToolTip"), TEXT("Tick function for physics ticking *"));
				MetaData->SetValue(NewProp_LODParentPrimitive, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_LODParentPrimitive, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_LODParentPrimitive, TEXT("ToolTip"), TEXT("LOD parent primitive to draw instead of this one (multiple UPrim's will point to the same LODParent )"));
				MetaData->SetValue(NewProp_OnInputTouchLeave, TEXT("Category"), TEXT("Input|Touch Input"));
				MetaData->SetValue(NewProp_OnInputTouchLeave, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnInputTouchLeave, TEXT("ToolTip"), TEXT("Event called when a finger is moved off this component when touch over events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnInputTouchEnter, TEXT("Category"), TEXT("Input|Touch Input"));
				MetaData->SetValue(NewProp_OnInputTouchEnter, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnInputTouchEnter, TEXT("ToolTip"), TEXT("Event called when a finger is moved over this component when touch over events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnInputTouchEnd, TEXT("Category"), TEXT("Input|Touch Input"));
				MetaData->SetValue(NewProp_OnInputTouchEnd, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnInputTouchEnd, TEXT("ToolTip"), TEXT("Event called when a touch input is released over this component when touch events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnInputTouchBegin, TEXT("Category"), TEXT("Input|Touch Input"));
				MetaData->SetValue(NewProp_OnInputTouchBegin, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnInputTouchBegin, TEXT("ToolTip"), TEXT("Event called when a touch input is received over this component when touch events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnReleased, TEXT("Category"), TEXT("Input|Mouse Input"));
				MetaData->SetValue(NewProp_OnReleased, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnReleased, TEXT("ToolTip"), TEXT("Event called when the left mouse button is released while the mouse is over this component click events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnClicked, TEXT("Category"), TEXT("Input|Mouse Input"));
				MetaData->SetValue(NewProp_OnClicked, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnClicked, TEXT("ToolTip"), TEXT("Event called when the left mouse button is clicked while the mouse is over this component and click events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnEndCursorOver, TEXT("Category"), TEXT("Input|Mouse Input"));
				MetaData->SetValue(NewProp_OnEndCursorOver, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnEndCursorOver, TEXT("ToolTip"), TEXT("Event called when the mouse cursor is moved off this component and mouse over events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnBeginCursorOver, TEXT("Category"), TEXT("Input|Mouse Input"));
				MetaData->SetValue(NewProp_OnBeginCursorOver, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnBeginCursorOver, TEXT("ToolTip"), TEXT("Event called when the mouse cursor is moved over this component and mouse over events are enabled in the player controller"));
				MetaData->SetValue(NewProp_OnComponentSleep, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_OnComponentSleep, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnComponentSleep, TEXT("ToolTip"), TEXT("Event called when the underlying physics objects is put to sleep"));
				MetaData->SetValue(NewProp_OnComponentWake, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_OnComponentWake, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnComponentWake, TEXT("ToolTip"), TEXT("Event called when the underlying physics objects is woken up"));
				MetaData->SetValue(NewProp_OnComponentEndOverlap, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_OnComponentEndOverlap, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnComponentEndOverlap, TEXT("ToolTip"), TEXT("Event called when something stops overlapping this component\n@note Both this component and the other one must have bGenerateOverlapEvents set to true to generate overlap events."));
				MetaData->SetValue(NewProp_OnComponentBeginOverlap, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_OnComponentBeginOverlap, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnComponentBeginOverlap, TEXT("ToolTip"), TEXT("Event called when something starts to overlaps this component, for example a player walking into a trigger.\nFor events when objects have a blocking collision, for example a player hitting a wall, see 'Hit' events.\n\n@note Both this component and the other one must have bGenerateOverlapEvents set to true to generate overlap events.\n@note When receiving an overlap from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'\nwill be adjusted to indicate force from the other object against this object."));
				MetaData->SetValue(NewProp_OnComponentHit, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_OnComponentHit, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_OnComponentHit, TEXT("ToolTip"), TEXT("Event called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with 'sweep' enabled, or physics simulation.\nFor events when objects overlap (e.g. walking into a trigger) see the 'Overlap' event.\n\n@note For collisions during physics simulation to generate hit events, 'Simulation Generates Hit Events' must be enabled for this component.\n@note When receiving a hit from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'\nwill be adjusted to indicate force from the other object against this object."));
				MetaData->SetValue(NewProp_CanCharacterStepUpOn, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_CanCharacterStepUpOn, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_CanCharacterStepUpOn, TEXT("ToolTip"), TEXT("Determine whether a Character can step up onto this component.\nThis controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.\n@see FWalkableSlopeOverride"));
				MetaData->SetValue(NewProp_CanBeCharacterBase, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_LastRenderTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_LastRenderTime, TEXT("ToolTip"), TEXT("The value of WorldSettings->TimeSeconds for the frame when this component was last rendered.  This is written\nfrom the render thread, which is up to a frame behind the game thread, so you should allow this time to\nbe at least a frame behind the game thread's world time before you consider the actor non-visible."));
				MetaData->SetValue(NewProp_LastSubmitTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_LastSubmitTime, TEXT("ToolTip"), TEXT("Last time the component was submitted for rendering (called FScene::AddPrimitive)."));
				MetaData->SetValue(NewProp_BoundsScale, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_BoundsScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_BoundsScale, TEXT("ToolTip"), TEXT("Scales the bounds of the object.\nThis is useful when using World Position Offset to animate the vertices of the object outside of its bounds.\nWarning: Increasing the bounds of an object will reduce performance and shadow quality!\nCurrently only used by StaticMeshComponent and SkeletalMeshComponent."));
				MetaData->SetValue(NewProp_BoundsScale, TEXT("UIMax"), TEXT("10.0"));
				MetaData->SetValue(NewProp_BoundsScale, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_bHasCustomNavigableGeometry, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bHasCustomNavigableGeometry, TEXT("ToolTip"), TEXT("If true then DoCustomNavigableGeometryExport will be called to collect navigable geometry of this component."));
				MetaData->SetValue(NewProp_bCanEverAffectNavigation, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bCanEverAffectNavigation, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCanEverAffectNavigation, TEXT("ToolTip"), TEXT("Whether this component can potentially influence navigation"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("ToolTip"), TEXT("Physics scene information for this component, holds a single rigid body with multiple shapes."));
				MetaData->SetValue(NewProp_LpvBiasMultiplier, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_LpvBiasMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_LpvBiasMultiplier, TEXT("ToolTip"), TEXT("Multiplier used to scale the Light Propagation Volume light injection bias, to reduce light bleeding.\nSet to 0 for no bias, 1 for default or higher for increased biasing (e.g. for\nthin geometry such as walls)"));
				MetaData->SetValue(NewProp_LpvBiasMultiplier, TEXT("UIMax"), TEXT("3.0"));
				MetaData->SetValue(NewProp_LpvBiasMultiplier, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_VisibilityId, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_VisibilityId, TEXT("ToolTip"), TEXT("Used for precomputed visibility"));
				MetaData->SetValue(NewProp_TranslucencySortPriority, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_TranslucencySortPriority, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_TranslucencySortPriority, TEXT("ToolTip"), TEXT("Translucent objects with a lower sort priority draw behind objects with a higher priority.\nTranslucent objects with the same priority are rendered from back-to-front based on their bounds origin.\n\nIgnored if the object is not translucent.  The default priority is zero.\nWarning: This should never be set to a non-default value unless you know what you are doing, as it will prevent the renderer from sorting correctly.\nIt is especially problematic on dynamic gameplay effects."));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("DisplayName"), TEXT("CustomDepth Stencil Value"));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("editcondition"), TEXT("bRenderCustomDepth"));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("ToolTip"), TEXT("Optionally write this 0-255 value to the stencil buffer in CustomDepth pass (Requires project setting or r.CustomDepth == 3)"));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("UIMax"), TEXT("255"));
				MetaData->SetValue(NewProp_CustomDepthStencilValue, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_bRenderCustomDepth, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bRenderCustomDepth, TEXT("DisplayName"), TEXT("Render CustomDepth Pass"));
				MetaData->SetValue(NewProp_bRenderCustomDepth, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bRenderCustomDepth, TEXT("ToolTip"), TEXT("If true, this component will be rendered in the CustomDepth pass (usually used for outlines)"));
				MetaData->SetValue(NewProp_bUseEditorCompositing, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bUseEditorCompositing, TEXT("ToolTip"), TEXT("Composite the drawing of this component onto the scene after post processing (only applies to editor drawing)"));
				MetaData->SetValue(NewProp_AlwaysLoadOnServer, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_AlwaysLoadOnServer, TEXT("ToolTip"), TEXT("If this is True, this component must always be loaded on servers, even if Hidden and CollisionEnabled is NoCollision"));
				MetaData->SetValue(NewProp_AlwaysLoadOnClient, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_AlwaysLoadOnClient, TEXT("ToolTip"), TEXT("If this is True, this component must always be loaded on clients, even if Hidden and CollisionEnabled is NoCollision."));
				MetaData->SetValue(NewProp_bIgnoreRadialForce, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bIgnoreRadialForce, TEXT("ToolTip"), TEXT("Will ignore radial forces applied to this component."));
				MetaData->SetValue(NewProp_bIgnoreRadialImpulse, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bIgnoreRadialImpulse, TEXT("ToolTip"), TEXT("Will ignore radial impulses applied to this component."));
				MetaData->SetValue(NewProp_bStaticLightingBuildEnqueued, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bStaticLightingBuildEnqueued, TEXT("ToolTip"), TEXT("If true, asynchronous static build lighting will be enqueued to be applied to this"));
				MetaData->SetValue(NewProp_bHasCachedStaticLighting, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_IndirectLightingCacheQuality, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_IndirectLightingCacheQuality, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_IndirectLightingCacheQuality, TEXT("ToolTip"), TEXT("Quality of indirect lighting for Movable primitives.  This has a large effect on Indirect Lighting Cache update time."));
				MetaData->SetValue(NewProp_bLightAttachmentsAsGroup, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bLightAttachmentsAsGroup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bLightAttachmentsAsGroup, TEXT("ToolTip"), TEXT("Whether to light this component and any attachments as a group.  This only has effect on the root component of an attachment tree.\nWhen enabled, attached component shadowing settings like bCastInsetShadow, bCastVolumetricTranslucentShadow, etc, will be ignored.\nThis is useful for improving performance when multiple movable components are attached together."));
				MetaData->SetValue(NewProp_bLightAsIfStatic, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bLightAsIfStatic, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bLightAsIfStatic, TEXT("ToolTip"), TEXT("Whether to light this primitive as if it were static, including generating lightmaps.\nThis only has an effect for component types that can bake lighting, like static mesh components.\nThis is useful for moving meshes that don't change significantly."));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("DisplayName"), TEXT("Shadow Two Sided"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("ToolTip"), TEXT("Whether this primitive should cast dynamic shadows as if it were a two sided material."));
				MetaData->SetValue(NewProp_bCastHiddenShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastHiddenShadow, TEXT("DisplayName"), TEXT("Hidden Shadow"));
				MetaData->SetValue(NewProp_bCastHiddenShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastHiddenShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastHiddenShadow, TEXT("ToolTip"), TEXT("If true, the primitive will cast shadows even if bHidden is true.\nControls whether the primitive should cast shadows when hidden.\nThis flag is only used if CastShadow is true."));
				MetaData->SetValue(NewProp_bCastCinematicShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastCinematicShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastCinematicShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastCinematicShadow, TEXT("ToolTip"), TEXT("Whether this component should cast shadows from lights that have bCastShadowsFromCinematicObjectsOnly enabled.\nThis is useful for characters in a cinematic with special cinematic lights, where the cost of shadowmap rendering of the environment is undesired."));
				MetaData->SetValue(NewProp_bCastInsetShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastInsetShadow, TEXT("DisplayName"), TEXT("Dynamic Inset Shadow"));
				MetaData->SetValue(NewProp_bCastInsetShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastInsetShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastInsetShadow, TEXT("ToolTip"), TEXT("Whether this component should create a per-object shadow that gives higher effective shadow resolution.\nUseful for cinematic character shadowing. Assumed to be enabled if bSelfShadowOnly is enabled."));
				MetaData->SetValue(NewProp_bCastFarShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastFarShadow, TEXT("DisplayName"), TEXT("Far Shadow"));
				MetaData->SetValue(NewProp_bCastFarShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastFarShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastFarShadow, TEXT("ToolTip"), TEXT("When enabled, the component will be rendering into the far shadow cascades (only for directional lights)."));
				MetaData->SetValue(NewProp_bSelfShadowOnly, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bSelfShadowOnly, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bSelfShadowOnly, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bSelfShadowOnly, TEXT("ToolTip"), TEXT("When enabled, the component will only cast a shadow on itself and not other components in the world.  This is especially useful for first person weapons, and forces bCastInsetShadow to be enabled."));
				MetaData->SetValue(NewProp_bCastVolumetricTranslucentShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastVolumetricTranslucentShadow, TEXT("DisplayName"), TEXT("Volumetric Translucent Shadow"));
				MetaData->SetValue(NewProp_bCastVolumetricTranslucentShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastVolumetricTranslucentShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastVolumetricTranslucentShadow, TEXT("ToolTip"), TEXT("Whether the object should cast a volumetric translucent shadow.\nVolumetric translucent shadows are useful for primitives with smoothly changing opacity like particles representing a volume,\nBut have artifacts when used on highly opaque surfaces."));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("DisplayName"), TEXT("Static Shadow"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("ToolTip"), TEXT("Whether the object should cast a static shadow from shadow casting lights.  This flag is only used if CastShadow is true."));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("DisplayName"), TEXT("Dynamic Shadow"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("ToolTip"), TEXT("Controls whether the primitive should cast shadows in the case of non precomputed shadowing.  This flag is only used if CastShadow is true. *"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("ToolTip"), TEXT("Controls whether the primitive should affect dynamic distance field lighting methods.  This flag is only used if CastShadow is true. *"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("ToolTip"), TEXT("Controls whether the primitive should inject light into the Light Propagation Volume.  This flag is only used if CastShadow is true. *"));
				MetaData->SetValue(NewProp_CastShadow, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_CastShadow, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_CastShadow, TEXT("ToolTip"), TEXT("Controls whether the primitive component should cast a shadow or not.\n\nThis flag is ignored (no shadows will be generated) if all materials on this component have an Unlit shading model."));
				MetaData->SetValue(NewProp_bHasPerInstanceHitProxies, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bHasPerInstanceHitProxies, TEXT("ToolTip"), TEXT("If true a hit-proxy will be generated for each instance of instanced static meshes"));
				MetaData->SetValue(NewProp_bForceMipStreaming, TEXT("Category"), TEXT("TextureStreaming"));
				MetaData->SetValue(NewProp_bForceMipStreaming, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bForceMipStreaming, TEXT("ToolTip"), TEXT("If true, forces mips for textures used by this component to be resident when this component's level is loaded."));
				MetaData->SetValue(NewProp_bSelectable, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bSelectable, TEXT("ToolTip"), TEXT("If this is True, this component can be selected in the editor."));
				MetaData->SetValue(NewProp_bUseAsOccluder, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bUseAsOccluder, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bUseAsOccluder, TEXT("ToolTip"), TEXT("Whether to render the primitive in the depth only pass.\nThis should generally be true for all objects, and let the renderer make decisions about whether to render objects in the depth only pass.\n@todo - if any rendering features rely on a complete depth only pass, this variable needs to go away."));
				MetaData->SetValue(NewProp_bTreatAsBackgroundForOcclusion, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bTreatAsBackgroundForOcclusion, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bTreatAsBackgroundForOcclusion, TEXT("ToolTip"), TEXT("Treat this primitive as part of the background for occlusion purposes. This can be used as an optimization to reduce the cost of rendering skyboxes, large ground planes that are part of the vista, etc."));
				MetaData->SetValue(NewProp_bOnlyOwnerSee, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bOnlyOwnerSee, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bOnlyOwnerSee, TEXT("ToolTip"), TEXT("If this is True, this component will only be visible when the view actor is the component's owner, directly or indirectly."));
				MetaData->SetValue(NewProp_bOwnerNoSee, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bOwnerNoSee, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bOwnerNoSee, TEXT("ToolTip"), TEXT("If this is True, this component won't be visible when the view actor is the component's owner, directly or indirectly."));
				MetaData->SetValue(NewProp_bReceivesDecals, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bReceivesDecals, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bReceivesDecals, TEXT("ToolTip"), TEXT("Whether the primitive receives decals."));
				MetaData->SetValue(NewProp_bRenderInMainPass, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bRenderInMainPass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bRenderInMainPass, TEXT("ToolTip"), TEXT("If true, this component will be rendered in the main pass (z prepass, basepass, transparency)"));
				MetaData->SetValue(NewProp_bHasMotionBlurVelocityMeshes, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bHasMotionBlurVelocityMeshes, TEXT("ToolTip"), TEXT("true if the primitive has motion blur velocity meshes"));
				MetaData->SetValue(NewProp_bAllowCullDistanceVolume, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_bAllowCullDistanceVolume, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bAllowCullDistanceVolume, TEXT("ToolTip"), TEXT("Whether to accept cull distance volumes to modify cached cull distance."));
				MetaData->SetValue(NewProp_bUseViewOwnerDepthPriorityGroup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bUseViewOwnerDepthPriorityGroup, TEXT("ToolTip"), TEXT("True if the primitive should be rendered using ViewOwnerDepthPriorityGroup if viewed by its owner."));
				MetaData->SetValue(NewProp_bReturnMaterialOnMove, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bReturnMaterialOnMove, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bReturnMaterialOnMove, TEXT("ToolTip"), TEXT("If true, component sweeps will return the material in their hit result.\n@see MoveComponent(), FHitResult"));
				MetaData->SetValue(NewProp_bTraceComplexOnMove, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bTraceComplexOnMove, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bTraceComplexOnMove, TEXT("ToolTip"), TEXT("If true, component sweeps with this component should trace against complex collision during movement (for example, each triangle of a mesh).\nIf false, collision will be resolved against simple collision bounds instead.\n@see MoveComponent()"));
				MetaData->SetValue(NewProp_bCheckAsyncSceneOnMove, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bCheckAsyncSceneOnMove, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bCheckAsyncSceneOnMove, TEXT("ToolTip"), TEXT("If true, this component will look for collisions on both physic scenes during movement.\nOnly required if the asynchronous physics scene is enabled and has geometry in it, and you wish to test for collisions with objects in that scene.\n@see MoveComponent()"));
				MetaData->SetValue(NewProp_bMultiBodyOverlap, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bMultiBodyOverlap, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bMultiBodyOverlap, TEXT("ToolTip"), TEXT("If true, this component will generate individual overlaps for each overlapping physics body if it is a multi-body component. When false, this component will\ngenerate only one overlap, regardless of how many physics bodies it has and how many of them are overlapping another component/body. This flag has no\ninfluence on single body components."));
				MetaData->SetValue(NewProp_bGenerateOverlapEvents, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bGenerateOverlapEvents, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bGenerateOverlapEvents, TEXT("ToolTip"), TEXT("If true, this component will generate overlap events when it is overlapping other components (eg Begin Overlap).\nBoth components (this and the other) must have this enabled for overlap events to occur.\n\n@see [Overlap Events](https://docs.unrealengine.com/latest/INT/Engine/Physics/Collision/index.html#overlapandgenerateoverlapevents)\n@see UpdateOverlaps(), BeginComponentOverlap(), EndComponentOverlap()"));
				MetaData->SetValue(NewProp_bAlwaysCreatePhysicsState, TEXT("Category"), TEXT("Collision"));
				MetaData->SetValue(NewProp_bAlwaysCreatePhysicsState, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_bAlwaysCreatePhysicsState, TEXT("ToolTip"), TEXT("Indicates if we'd like to create physics state all the time (for collision and simulation).\nIf you set this to false, it still will create physics state if collision or simulation activated.\nThis can help performance if you'd like to avoid overhead of creating physics state when triggers"));
				MetaData->SetValue(NewProp_ViewOwnerDepthPriorityGroup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_ViewOwnerDepthPriorityGroup, TEXT("ToolTip"), TEXT("The scene depth priority group to draw the primitive in, if it's being viewed by its owner."));
				MetaData->SetValue(NewProp_DepthPriorityGroup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_DepthPriorityGroup, TEXT("ToolTip"), TEXT("The scene depth priority group to draw the primitive in."));
				MetaData->SetValue(NewProp_CachedMaxDrawDistance, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_CachedMaxDrawDistance, TEXT("DisplayName"), TEXT("Current Max Draw Distance"));
				MetaData->SetValue(NewProp_CachedMaxDrawDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_CachedMaxDrawDistance, TEXT("ToolTip"), TEXT("The distance to cull this primitive at.\nA CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance."));
				MetaData->SetValue(NewProp_LDMaxDrawDistance, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_LDMaxDrawDistance, TEXT("DisplayName"), TEXT("Desired Max Draw Distance"));
				MetaData->SetValue(NewProp_LDMaxDrawDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_LDMaxDrawDistance, TEXT("ToolTip"), TEXT("Max draw distance exposed to LDs. The real max draw distance is the min (disregarding 0) of this and volumes affecting this object."));
				MetaData->SetValue(NewProp_MinDrawDistance, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_MinDrawDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PrimitiveComponent.h"));
				MetaData->SetValue(NewProp_MinDrawDistance, TEXT("ToolTip"), TEXT("The minimum distance at which the primitive should be rendered,\nmeasured in world space units from the center of the primitive's bounding sphere to the camera position."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPrimitiveComponent(Z_Construct_UClass_UPrimitiveComponent, TEXT("UPrimitiveComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPrimitiveComponent);
	UFunction* Z_Construct_UFunction_UMeshComponent_GetMaterials()
	{
		struct MeshComponent_eventGetMaterials_Parms
		{
			TArray<UMaterialInterface*> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMaterials"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MeshComponent_eventGetMaterials_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, MeshComponent_eventGetMaterials_Parms), 0x0000000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Mesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMeshComponent_NoRegister()
	{
		return UMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UMeshComponent_GetMaterials());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OverrideMaterials = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OverrideMaterials"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OverrideMaterials, UMeshComponent), 0x0000040000000001);
				UProperty* NewProp_OverrideMaterials_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OverrideMaterials, TEXT("OverrideMaterials"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UMaterialInterface_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMeshComponent_GetMaterials()); // 658501963
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/MeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("MeshComponent is an abstract base for any component that is an instance of a renderable collection of triangles.\n\n@see UStaticMeshComponent\n@see USkeletalMeshComponent"));
				MetaData->SetValue(NewProp_OverrideMaterials, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_OverrideMaterials, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MeshComponent.h"));
				MetaData->SetValue(NewProp_OverrideMaterials, TEXT("ToolTip"), TEXT("Material overrides."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMeshComponent(Z_Construct_UClass_UMeshComponent, TEXT("UMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMeshComponent);
	UEnum* Z_Construct_UEnum_Engine_EBoneSpaces()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EBoneSpaces_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EBoneSpaces"), 0, Get_Z_Construct_UEnum_Engine_EBoneSpaces_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBoneSpaces"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneSpaces::WorldSpace")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneSpaces::ComponentSpace")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBoneSpaces::EBoneSpaces_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ComponentSpace.DisplayName"), TEXT("Component Space"));
			MetaData->SetValue(ReturnEnum, TEXT("ComponentSpace.ToolTip"), TEXT("Set position of bone in components reference frame."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Values for specifying bone space."));
			MetaData->SetValue(ReturnEnum, TEXT("WorldSpace.DisplayName"), TEXT("World Space"));
			MetaData->SetValue(ReturnEnum, TEXT("WorldSpace.ToolTip"), TEXT("Set absolute position of bone in world space."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EBoneSpaces_CRC() { return 475607531U; }
	UEnum* Z_Construct_UEnum_Engine_EMeshComponentUpdateFlag()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EMeshComponentUpdateFlag_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EMeshComponentUpdateFlag"), 0, Get_Z_Construct_UEnum_Engine_EMeshComponentUpdateFlag_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EMeshComponentUpdateFlag"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMeshComponentUpdateFlag::AlwaysTickPoseAndRefreshBones")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMeshComponentUpdateFlag::AlwaysTickPose")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMeshComponentUpdateFlag::OnlyTickPoseWhenRendered")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMeshComponentUpdateFlag::EMeshComponentUpdateFlag_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AlwaysTickPose.ToolTip"), TEXT("Always Tick, but Refresh BoneTransforms only when rendered."));
			MetaData->SetValue(ReturnEnum, TEXT("AlwaysTickPoseAndRefreshBones.ToolTip"), TEXT("Always Tick and Refresh BoneTransforms whether rendered or not."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("OnlyTickPoseWhenRendered.ToolTip"), TEXT("Tick only when rendered, and it will only RefreshBoneTransforms when rendered."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Skinned Mesh Update Flag based on rendered or not."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EMeshComponentUpdateFlag_CRC() { return 2333711055U; }
	UEnum* Z_Construct_UEnum_Engine_EPhysBodyOp()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EPhysBodyOp_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EPhysBodyOp"), 0, Get_Z_Construct_UEnum_Engine_EPhysBodyOp_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EPhysBodyOp"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PBO_None")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PBO_Term")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PBO_Disable")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PBO_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("PBO_Disable.ToolTip"), TEXT("Disable collision - it will enable collision when unhidden."));
			MetaData->SetValue(ReturnEnum, TEXT("PBO_None.ToolTip"), TEXT("Don't do anything."));
			MetaData->SetValue(ReturnEnum, TEXT("PBO_Term.ToolTip"), TEXT("Terminate - if you terminate, you won't be able to re-init when unhidden."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("PhysicsBody options when bone is hidden"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EPhysBodyOp_CRC() { return 140540865U; }
	UEnum* Z_Construct_UEnum_Engine_EBoneVisibilityStatus()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EBoneVisibilityStatus_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EBoneVisibilityStatus"), 0, Get_Z_Construct_UEnum_Engine_EBoneVisibilityStatus_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBoneVisibilityStatus"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("BVS_HiddenByParent")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("BVS_Visible")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("BVS_ExplicitlyHidden")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("BVS_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BVS_ExplicitlyHidden.ToolTip"), TEXT("Bone is hidden directly."));
			MetaData->SetValue(ReturnEnum, TEXT("BVS_HiddenByParent.ToolTip"), TEXT("Bone is hidden because it's parent is hidden."));
			MetaData->SetValue(ReturnEnum, TEXT("BVS_Visible.ToolTip"), TEXT("Bone is visible."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("The valid BoneVisibilityStates values; A bone is only visible if it is *exactly* 1"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EBoneVisibilityStatus_CRC() { return 1300894573U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSkelMeshComponentLODInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSkelMeshComponentLODInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SkelMeshComponentLODInfo"), sizeof(FSkelMeshComponentLODInfo), Get_Z_Construct_UScriptStruct_FSkelMeshComponentLODInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkelMeshComponentLODInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSkelMeshComponentLODInfo>, EStructFlags(0x00000001));
			UProperty* NewProp_HiddenMaterials = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("HiddenMaterials"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(HiddenMaterials, FSkelMeshComponentLODInfo), 0x0000000000000000);
			UProperty* NewProp_HiddenMaterials_Inner = new(EC_InternalUseOnlyConstructor, NewProp_HiddenMaterials, TEXT("HiddenMaterials"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, 0, sizeof(bool), true);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("LOD specific setup for the skeletal mesh component."));
			MetaData->SetValue(NewProp_HiddenMaterials, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(NewProp_HiddenMaterials, TEXT("ToolTip"), TEXT("Material corresponds to section. To show/hide each section, use this."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSkelMeshComponentLODInfo_CRC() { return 1142515641U; }
	UScriptStruct* Z_Construct_UScriptStruct_FActiveVertexAnim()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FActiveVertexAnim_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ActiveVertexAnim"), sizeof(FActiveVertexAnim), Get_Z_Construct_UScriptStruct_FActiveVertexAnim_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ActiveVertexAnim"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FActiveVertexAnim>, EStructFlags(0x00000001));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, FActiveVertexAnim), 0x0000000000000000);
			UProperty* NewProp_Weight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Weight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Weight, FActiveVertexAnim), 0x0000000000000000);
			UProperty* NewProp_VertAnim = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VertAnim"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VertAnim, FActiveVertexAnim), 0x0000000000000000, Z_Construct_UClass_UVertexAnimBase_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct used to indicate one active vertex animation that should be applied to this USkeletalMesh when rendered."));
			MetaData->SetValue(NewProp_Time, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(NewProp_Time, TEXT("ToolTip"), TEXT("Time to evaluate the animation at."));
			MetaData->SetValue(NewProp_Weight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(NewProp_Weight, TEXT("ToolTip"), TEXT("Strength of the vertex animation, between 0.0 and 1.0."));
			MetaData->SetValue(NewProp_VertAnim, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(NewProp_VertAnim, TEXT("ToolTip"), TEXT("The animation that we want to apply."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FActiveVertexAnim_CRC() { return 3487389723U; }
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_BoneIsChildOf()
	{
		struct SkinnedMeshComponent_eventBoneIsChildOf_Parms
		{
			FName BoneName;
			FName ParentBoneName;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoneIsChildOf"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkinnedMeshComponent_eventBoneIsChildOf_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, SkinnedMeshComponent_eventBoneIsChildOf_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, SkinnedMeshComponent_eventBoneIsChildOf_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, SkinnedMeshComponent_eventBoneIsChildOf_Parms), sizeof(bool), true);
			UProperty* NewProp_ParentBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ParentBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParentBoneName, SkinnedMeshComponent_eventBoneIsChildOf_Parms), 0x0000000000000080);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventBoneIsChildOf_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tests if BoneName is child of (or equal to) ParentBoneName.\n\n@param BoneName Name of the bone\n@param ParentBone Name to check\n\n@return true if child (strictly, not same). false otherwise\nNote - will return false if ChildBoneIndex is the same as ParentBoneIndex ie. must be strictly a child."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetBoneIndex()
	{
		struct SkinnedMeshComponent_eventGetBoneIndex_Parms
		{
			FName BoneName;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneIndex"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkinnedMeshComponent_eventGetBoneIndex_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, SkinnedMeshComponent_eventGetBoneIndex_Parms), 0x0000000000000580);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventGetBoneIndex_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Find the index of bone by name. Looks in the current SkeletalMesh being used by this SkeletalMeshComponent.\n\n@param BoneName Name of bone to look up\n\n@return Index of the named bone in the current SkeletalMesh. Will return INDEX_NONE if bone not found.\n\n@see USkeletalMesh::GetBoneIndex."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetBoneName()
	{
		struct SkinnedMeshComponent_eventGetBoneName_Parms
		{
			int32 BoneIndex;
			FName ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkinnedMeshComponent_eventGetBoneName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ReturnValue, SkinnedMeshComponent_eventGetBoneName_Parms), 0x0000000000000580);
			UProperty* NewProp_BoneIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(BoneIndex, SkinnedMeshComponent_eventGetBoneName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get Bone Name from index\n@param BoneIndex Index of the bone\n\n@return the name of the bone at the specified index"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetParentBone()
	{
		struct SkinnedMeshComponent_eventGetParentBone_Parms
		{
			FName BoneName;
			FName ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetParentBone"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkinnedMeshComponent_eventGetParentBone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ReturnValue, SkinnedMeshComponent_eventGetParentBone_Parms), 0x0000000000000580);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventGetParentBone_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get Parent Bone of the input bone\n\n@param BoneName Name of the bone\n\n@return the name of the parent bone for the specified bone. Returns 'None' if the bone does not exist or it is the root bone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_GetSocketBoneName()
	{
		struct SkinnedMeshComponent_eventGetSocketBoneName_Parms
		{
			FName InSocketName;
			FName ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSocketBoneName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkinnedMeshComponent_eventGetSocketBoneName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ReturnValue, SkinnedMeshComponent_eventGetSocketBoneName_Parms), 0x0000000000000580);
			UProperty* NewProp_InSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSocketName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InSocketName, SkinnedMeshComponent_eventGetSocketBoneName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns bone name linked to a given named socket on the skeletal mesh component.\nIf you're unsure to deal with sockets or bones names, you can use this function to filter through, and always return the bone name.\n\n@param       bone name or socket name\n\n@return      bone name"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_HideBoneByName()
	{
		struct SkinnedMeshComponent_eventHideBoneByName_Parms
		{
			FName BoneName;
			TEnumAsByte<EPhysBodyOp> PhysBodyOption;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HideBoneByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkinnedMeshComponent_eventHideBoneByName_Parms));
			UProperty* NewProp_PhysBodyOption = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PhysBodyOption"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PhysBodyOption, SkinnedMeshComponent_eventHideBoneByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EPhysBodyOp());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventHideBoneByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Hides the specified bone with name.  Currently this just enforces a scale of 0 for the hidden bones.\nCompoared to HideBone By Index - This keeps track of list of bones and update when LOD changes\n\n@param  BoneName            Name of bone to hide\n@param  PhysBodyOption          Option for physics bodies that attach to the bones to be hidden"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_IsBoneHiddenByName()
	{
		struct SkinnedMeshComponent_eventIsBoneHiddenByName_Parms
		{
			FName BoneName;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsBoneHiddenByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkinnedMeshComponent_eventIsBoneHiddenByName_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, SkinnedMeshComponent_eventIsBoneHiddenByName_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, SkinnedMeshComponent_eventIsBoneHiddenByName_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, SkinnedMeshComponent_eventIsBoneHiddenByName_Parms), sizeof(bool), true);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventIsBoneHiddenByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Determines if the specified bone is hidden.\n\n@param  BoneName            Name of bone to check\n\n@return true if hidden"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_SetMasterPoseComponent()
	{
		struct SkinnedMeshComponent_eventSetMasterPoseComponent_Parms
		{
			USkinnedMeshComponent* NewMasterBoneComponent;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMasterPoseComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkinnedMeshComponent_eventSetMasterPoseComponent_Parms));
			UProperty* NewProp_NewMasterBoneComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMasterBoneComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewMasterBoneComponent, SkinnedMeshComponent_eventSetMasterPoseComponent_Parms), 0x0000000000080080, Z_Construct_UClass_USkinnedMeshComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set MasterPoseComponent for this component\n\n@param NewMasterBoneComponent New MasterPoseComponent"));
			MetaData->SetValue(NewProp_NewMasterBoneComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_SetPhysicsAsset()
	{
		struct SkinnedMeshComponent_eventSetPhysicsAsset_Parms
		{
			UPhysicsAsset* NewPhysicsAsset;
			bool bForceReInit;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPhysicsAsset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(SkinnedMeshComponent_eventSetPhysicsAsset_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceReInit, SkinnedMeshComponent_eventSetPhysicsAsset_Parms, bool);
			UProperty* NewProp_bForceReInit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForceReInit"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceReInit, SkinnedMeshComponent_eventSetPhysicsAsset_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bForceReInit, SkinnedMeshComponent_eventSetPhysicsAsset_Parms), sizeof(bool), true);
			UProperty* NewProp_NewPhysicsAsset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewPhysicsAsset"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewPhysicsAsset, SkinnedMeshComponent_eventSetPhysicsAsset_Parms), 0x0000000000000080, Z_Construct_UClass_UPhysicsAsset_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bForceReInit"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Override the Physics Asset of the mesh. It uses SkeletalMesh.PhysicsAsset, but if you'd like to override use this function\n\n@param       NewPhysicsAsset New PhysicsAsset\n@param       bForceReInit    Force reinitialize"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_SetSkeletalMesh()
	{
		struct SkinnedMeshComponent_eventSetSkeletalMesh_Parms
		{
			USkeletalMesh* NewMesh;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSkeletalMesh"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(SkinnedMeshComponent_eventSetSkeletalMesh_Parms));
			UProperty* NewProp_NewMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewMesh, SkinnedMeshComponent_eventSetSkeletalMesh_Parms), 0x0000000000000080, Z_Construct_UClass_USkeletalMesh_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the SkeletalMesh that is rendered for this Component. Will re-initialize the animation tree etc.\n\n@param NewMesh New mesh to set for this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_TransformFromBoneSpace()
	{
		struct SkinnedMeshComponent_eventTransformFromBoneSpace_Parms
		{
			FName BoneName;
			FVector InPosition;
			FRotator InRotation;
			FVector OutPosition;
			FRotator OutRotation;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TransformFromBoneSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SkinnedMeshComponent_eventTransformFromBoneSpace_Parms));
			UProperty* NewProp_OutRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutRotation, SkinnedMeshComponent_eventTransformFromBoneSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_OutPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutPosition, SkinnedMeshComponent_eventTransformFromBoneSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InRotation, SkinnedMeshComponent_eventTransformFromBoneSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_InPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InPosition, SkinnedMeshComponent_eventTransformFromBoneSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventTransformFromBoneSpace_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Transform a location/rotation in bone relative space to world space.\n\n@param BoneName Name of bone\n@param InPosition Input position\n@param InRotation Input rotation\n@param OutPosition (out) Transformed position\n@param OutRotation (out) Transformed rotation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_TransformToBoneSpace()
	{
		struct SkinnedMeshComponent_eventTransformToBoneSpace_Parms
		{
			FName BoneName;
			FVector InPosition;
			FRotator InRotation;
			FVector OutPosition;
			FRotator OutRotation;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TransformToBoneSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(SkinnedMeshComponent_eventTransformToBoneSpace_Parms));
			UProperty* NewProp_OutRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutRotation, SkinnedMeshComponent_eventTransformToBoneSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_OutPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutPosition, SkinnedMeshComponent_eventTransformToBoneSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InRotation, SkinnedMeshComponent_eventTransformToBoneSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_InPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InPosition, SkinnedMeshComponent_eventTransformToBoneSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventTransformToBoneSpace_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Transform a location/rotation from world space to bone relative space.\nThis is handy if you know the location in world space for a bone attachment, as AttachComponent takes location/rotation in bone-relative space.\n\n@param BoneName Name of bone\n@param InPosition Input position\n@param InRotation Input rotation\n@param OutPosition (out) Transformed position\n@param OutRotation (out) Transformed rotation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkinnedMeshComponent_UnHideBoneByName()
	{
		struct SkinnedMeshComponent_eventUnHideBoneByName_Parms
		{
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_USkinnedMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UnHideBoneByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkinnedMeshComponent_eventUnHideBoneByName_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, SkinnedMeshComponent_eventUnHideBoneByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkinnedMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("UnHide the specified bone with name.  Currently this just enforces a scale of 0 for the hidden bones.\nCompoared to HideBone By Index - This keeps track of list of bones and update when LOD changes\n@param  BoneName            Name of bone to unhide"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkinnedMeshComponent_NoRegister()
	{
		return USkinnedMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USkinnedMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USkinnedMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_BoneIsChildOf());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_GetBoneIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_GetBoneName());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_GetParentBone());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_GetSocketBoneName());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_HideBoneByName());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_IsBoneHiddenByName());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_SetMasterPoseComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_SetPhysicsAsset());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_SetSkeletalMesh());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_TransformFromBoneSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_TransformToBoneSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_USkinnedMeshComponent_UnHideBoneByName());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisplayDebugUpdateRateOptimizations, USkinnedMeshComponent, bool);
				UProperty* NewProp_bDisplayDebugUpdateRateOptimizations = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisplayDebugUpdateRateOptimizations"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisplayDebugUpdateRateOptimizations, USkinnedMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bDisplayDebugUpdateRateOptimizations, USkinnedMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableUpdateRateOptimizations, USkinnedMeshComponent, bool);
				UProperty* NewProp_bEnableUpdateRateOptimizations = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableUpdateRateOptimizations"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableUpdateRateOptimizations, USkinnedMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bEnableUpdateRateOptimizations, USkinnedMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCachedLocalBoundsUpToDate, USkinnedMeshComponent, bool);
				UProperty* NewProp_bCachedLocalBoundsUpToDate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCachedLocalBoundsUpToDate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCachedLocalBoundsUpToDate, USkinnedMeshComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bCachedLocalBoundsUpToDate, USkinnedMeshComponent), sizeof(bool), true);
				UProperty* NewProp_CachedLocalBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedLocalBounds"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CachedLocalBounds, USkinnedMeshComponent), 0x0000080000002000, Z_Construct_UScriptStruct_FBoxSphereBounds());
				UProperty* NewProp_CustomSortAlternateIndexMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomSortAlternateIndexMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CustomSortAlternateIndexMode, USkinnedMeshComponent), 0x0000000000002000);
				UProperty* NewProp_ProgressiveDrawingFraction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProgressiveDrawingFraction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ProgressiveDrawingFraction, USkinnedMeshComponent), 0x0000000000002000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRecentlyRendered, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bRecentlyRendered = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRecentlyRendered"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRecentlyRendered, USkinnedMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bRecentlyRendered, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanHighlightSelectedSections, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bCanHighlightSelectedSections = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanHighlightSelectedSections"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanHighlightSelectedSections, USkinnedMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bCanHighlightSelectedSections, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceMeshObjectUpdate, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bForceMeshObjectUpdate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceMeshObjectUpdate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceMeshObjectUpdate, USkinnedMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bForceMeshObjectUpdate, USkinnedMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_MeshComponentUpdateFlag = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshComponentUpdateFlag"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(MeshComponentUpdateFlag, USkinnedMeshComponent), 0x0000040000000005, Z_Construct_UEnum_Engine_EMeshComponentUpdateFlag());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConsiderAllBodiesForBounds, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bConsiderAllBodiesForBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bConsiderAllBodiesForBounds"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConsiderAllBodiesForBounds, USkinnedMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bConsiderAllBodiesForBounds, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bComponentUseFixedSkelBounds, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bComponentUseFixedSkelBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bComponentUseFixedSkelBounds"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bComponentUseFixedSkelBounds, USkinnedMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bComponentUseFixedSkelBounds, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPerBoneMotionBlur, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bPerBoneMotionBlur = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPerBoneMotionBlur"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPerBoneMotionBlur, USkinnedMeshComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bPerBoneMotionBlur, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHideSkin, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bHideSkin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHideSkin"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHideSkin, USkinnedMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bHideSkin, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableMorphTarget, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bDisableMorphTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableMorphTarget"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableMorphTarget, USkinnedMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDisableMorphTarget, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisplayBones, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bDisplayBones = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisplayBones"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisplayBones, USkinnedMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDisplayBones, USkinnedMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceWireframe, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bForceWireframe = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceWireframe"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceWireframe, USkinnedMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bForceWireframe, USkinnedMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_WireframeColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WireframeColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WireframeColor, USkinnedMeshComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FColor());
				UProperty* NewProp_StreamingDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StreamingDistanceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StreamingDistanceMultiplier, USkinnedMeshComponent), 0x0000040000000005);
				UProperty* NewProp_LODInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODInfo"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LODInfo, USkinnedMeshComponent), 0x0000000000002000);
				UProperty* NewProp_LODInfo_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LODInfo, TEXT("LODInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FSkelMeshComponentLODInfo());
				UProperty* NewProp_MaxDistanceFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxDistanceFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxDistanceFactor, USkinnedMeshComponent), 0x0000000000000000);
				UProperty* NewProp_OldPredictedLODLevel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OldPredictedLODLevel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OldPredictedLODLevel, USkinnedMeshComponent), 0x0000000000000000);
				UProperty* NewProp_PredictedLODLevel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PredictedLODLevel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PredictedLODLevel, USkinnedMeshComponent), 0x0000000000000000);
				UProperty* NewProp_MinLodModel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinLodModel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MinLodModel, USkinnedMeshComponent), 0x0000040000000015);
				UProperty* NewProp_ForcedLodModel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ForcedLodModel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ForcedLodModel, USkinnedMeshComponent), 0x0000040000000015);
				UProperty* NewProp_PhysicsAssetOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PhysicsAssetOverride"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PhysicsAssetOverride, USkinnedMeshComponent), 0x0000040000000015, Z_Construct_UClass_UPhysicsAsset_NoRegister());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SectionIndexPreview = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SectionIndexPreview"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SectionIndexPreview, USkinnedMeshComponent), 0x0000000800002000);
				UProperty* NewProp_ChunkIndexPreview = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkIndexPreview"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ChunkIndexPreview, USkinnedMeshComponent), 0x0000000800002000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_ActiveVertexAnims = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActiveVertexAnims"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ActiveVertexAnims, USkinnedMeshComponent), 0x0000000000002000);
				UProperty* NewProp_ActiveVertexAnims_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActiveVertexAnims, TEXT("ActiveVertexAnims"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FActiveVertexAnim());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseBoundsFromMasterPoseComponent, USkinnedMeshComponent, uint8);
				UProperty* NewProp_bUseBoundsFromMasterPoseComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseBoundsFromMasterPoseComponent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseBoundsFromMasterPoseComponent, USkinnedMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUseBoundsFromMasterPoseComponent, USkinnedMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_MasterPoseComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MasterPoseComponent"), RF_Public|RF_Transient|RF_Native) UWeakObjectProperty(CPP_PROPERTY_BASE(MasterPoseComponent, USkinnedMeshComponent), 0x000400000008001c, Z_Construct_UClass_USkinnedMeshComponent_NoRegister());
				UProperty* NewProp_SkeletalMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkeletalMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SkeletalMesh, USkinnedMeshComponent), 0x0000000000000015, Z_Construct_UClass_USkeletalMesh_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_BoneIsChildOf()); // 3296379598
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_GetBoneIndex()); // 3799921940
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_GetBoneName()); // 2946958167
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_GetParentBone()); // 3232809116
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_GetSocketBoneName()); // 1426354904
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_HideBoneByName()); // 3461666596
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_IsBoneHiddenByName()); // 365843304
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_SetMasterPoseComponent()); // 605457303
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_SetPhysicsAsset()); // 1885133423
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_SetSkeletalMesh()); // 1986639800
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_TransformFromBoneSpace()); // 1031394197
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_TransformToBoneSpace()); // 906672998
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkinnedMeshComponent_UnHideBoneByName()); // 3087427953
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Skinned mesh component that supports bone skinned mesh rendering.\nThis class does not support animation.\n\n@see USkeletalMeshComponent"));
				MetaData->SetValue(NewProp_bDisplayDebugUpdateRateOptimizations, TEXT("Category"), TEXT("Optimization"));
				MetaData->SetValue(NewProp_bDisplayDebugUpdateRateOptimizations, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bDisplayDebugUpdateRateOptimizations, TEXT("ToolTip"), TEXT("Enable on screen debugging of update rate optimization.\nRed = Skipping 0 frames, Green = skipping 1 frame, Blue = skipping 2 frames, black = skipping more than 2 frames.\n@todo: turn this into a console command."));
				MetaData->SetValue(NewProp_bEnableUpdateRateOptimizations, TEXT("Category"), TEXT("Optimization"));
				MetaData->SetValue(NewProp_bEnableUpdateRateOptimizations, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bEnableUpdateRateOptimizations, TEXT("ToolTip"), TEXT("if TRUE, Owner will determine how often animation will be updated and evaluated. See AnimUpdateRateTick()\nThis allows to skip frames for performance. (For example based on visibility and size on screen)."));
				MetaData->SetValue(NewProp_bCachedLocalBoundsUpToDate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bCachedLocalBoundsUpToDate, TEXT("ToolTip"), TEXT("true when CachedLocalBounds is up to date."));
				MetaData->SetValue(NewProp_CachedLocalBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_CachedLocalBounds, TEXT("ToolTip"), TEXT("LocalBounds cached, so they're computed just once."));
				MetaData->SetValue(NewProp_CustomSortAlternateIndexMode, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_CustomSortAlternateIndexMode, TEXT("ToolTip"), TEXT("Editor only. Used for manually selecting the alternate indices for\nTRISORT_CustomLeftRight sections."));
				MetaData->SetValue(NewProp_ProgressiveDrawingFraction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_ProgressiveDrawingFraction, TEXT("ToolTip"), TEXT("Editor only. Used for visualizing drawing order in Animset Viewer. If < 1.0,\nonly the specified fraction of triangles will be rendered"));
				MetaData->SetValue(NewProp_bRecentlyRendered, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bRecentlyRendered, TEXT("ToolTip"), TEXT("true if mesh has been recently rendered, false otherwise"));
				MetaData->SetValue(NewProp_bCanHighlightSelectedSections, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bCanHighlightSelectedSections, TEXT("ToolTip"), TEXT("Whether or not we can highlight selected sections - this should really only be done in the editor"));
				MetaData->SetValue(NewProp_bForceMeshObjectUpdate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bForceMeshObjectUpdate, TEXT("ToolTip"), TEXT("If true, UpdateTransform will always result in a call to MeshObject->Update."));
				MetaData->SetValue(NewProp_MeshComponentUpdateFlag, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_MeshComponentUpdateFlag, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_MeshComponentUpdateFlag, TEXT("ToolTip"), TEXT("This is update frequency flag even when our Owner has not been rendered recently\n\nSMU_AlwaysTickPoseAndRefreshBones,                   // Always Tick and Refresh BoneTransforms whether rendered or not\nSMU_AlwaysTickPose,                                                  // Always Tick, but Refresh BoneTransforms only when rendered\nSMU_OnlyTickPoseWhenRendered,                                // Tick only when rendered, and it will only RefreshBoneTransforms when rendered"));
				MetaData->SetValue(NewProp_bConsiderAllBodiesForBounds, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bConsiderAllBodiesForBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bConsiderAllBodiesForBounds, TEXT("ToolTip"), TEXT("If true, when updating bounds from a PhysicsAsset, consider _all_ BodySetups, not just those flagged with bConsiderForBounds."));
				MetaData->SetValue(NewProp_bComponentUseFixedSkelBounds, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bComponentUseFixedSkelBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bComponentUseFixedSkelBounds, TEXT("ToolTip"), TEXT("When true, skip using the physics asset etc. and always use the fixed bounds defined in the SkeletalMesh."));
				MetaData->SetValue(NewProp_bPerBoneMotionBlur, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bPerBoneMotionBlur, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bPerBoneMotionBlur, TEXT("ToolTip"), TEXT("If true, use per-bone motion blur on this skeletal mesh (requires additional rendering, can be disabled to save performance)."));
				MetaData->SetValue(NewProp_bHideSkin, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bHideSkin, TEXT("ToolTip"), TEXT("Don't bother rendering the skin."));
				MetaData->SetValue(NewProp_bDisableMorphTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bDisableMorphTarget, TEXT("ToolTip"), TEXT("Disable Morphtarget for this component."));
				MetaData->SetValue(NewProp_bDisplayBones, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bDisplayBones, TEXT("ToolTip"), TEXT("Draw the skeleton hierarchy for this skel mesh."));
				MetaData->SetValue(NewProp_bForceWireframe, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bForceWireframe, TEXT("ToolTip"), TEXT("Forces the mesh to draw in wireframe mode."));
				MetaData->SetValue(NewProp_WireframeColor, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_WireframeColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_WireframeColor, TEXT("ToolTip"), TEXT("Wireframe color"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ToolTip"), TEXT("Allows adjusting the desired streaming distance of streaming textures that uses UV 0.\n1.0 is the default, whereas a higher value makes the textures stream in sooner from far away.\nA lower value (0.0-1.0) makes the textures stream in later (you have to be closer).\nValue can be < 0 (from legcay content, or code changes)"));
				MetaData->SetValue(NewProp_LODInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_LODInfo, TEXT("ToolTip"), TEXT("LOD array info. Each index will correspond to the LOD index *"));
				MetaData->SetValue(NewProp_MaxDistanceFactor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_MaxDistanceFactor, TEXT("ToolTip"), TEXT("High (best) DistanceFactor that was desired for rendering this USkeletalMesh last frame. Represents how big this mesh was in screen space"));
				MetaData->SetValue(NewProp_OldPredictedLODLevel, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_OldPredictedLODLevel, TEXT("ToolTip"), TEXT("LOD level from previous frame, so we can detect changes in LOD to recalc required bones."));
				MetaData->SetValue(NewProp_PredictedLODLevel, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_PredictedLODLevel, TEXT("ToolTip"), TEXT("Best LOD that was 'predicted' by UpdateSkelPose.\nThis is what bones were updated based on, so we do not allow rendering at a better LOD than this."));
				MetaData->SetValue(NewProp_MinLodModel, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_MinLodModel, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_MinLodModel, TEXT("ToolTip"), TEXT("This is the min LOD that this component will use.  (e.g. if set to 2 then only 2+ LOD Models will be used.) This is useful to set on\nmeshes which are known to be a certain distance away and still want to have better LODs when zoomed in on them."));
				MetaData->SetValue(NewProp_ForcedLodModel, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_ForcedLodModel, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_ForcedLodModel, TEXT("ToolTip"), TEXT("If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1)."));
				MetaData->SetValue(NewProp_PhysicsAssetOverride, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_PhysicsAssetOverride, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_PhysicsAssetOverride, TEXT("ToolTip"), TEXT("PhysicsAsset is set in SkeletalMesh by default, but you can override with this value"));
				MetaData->SetValue(NewProp_SectionIndexPreview, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_SectionIndexPreview, TEXT("ToolTip"), TEXT("Index of the section to preview... If set to -1, all section will be rendered"));
				MetaData->SetValue(NewProp_ChunkIndexPreview, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_ChunkIndexPreview, TEXT("ToolTip"), TEXT("Index of the chunk to preview... If set to -1, all chunks will be rendered"));
				MetaData->SetValue(NewProp_ActiveVertexAnims, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_ActiveVertexAnims, TEXT("ToolTip"), TEXT("Array indicating all active vertex animations. This array is updated inside RefreshBoneTransforms based on the Anim Blueprint."));
				MetaData->SetValue(NewProp_bUseBoundsFromMasterPoseComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_bUseBoundsFromMasterPoseComponent, TEXT("ToolTip"), TEXT("When true, we will just using the bounds from our MasterPoseComponent.  This is useful for when we have a Mesh Parented\nto the main SkelMesh (e.g. outline mesh or a full body overdraw effect that is toggled) that is always going to be the same\nbounds as parent.  We want to do no calculations in that case."));
				MetaData->SetValue(NewProp_MasterPoseComponent, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_MasterPoseComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_MasterPoseComponent, TEXT("ToolTip"), TEXT("If set, this SkeletalMeshComponent will not use its SpaceBase for bone transform, but will\nuse the SpaceBases array in the MasterPoseComponent. This is used when constructing a character using multiple skeletal meshes sharing the same\nskeleton within the same Actor."));
				MetaData->SetValue(NewProp_SkeletalMesh, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_SkeletalMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkinnedMeshComponent.h"));
				MetaData->SetValue(NewProp_SkeletalMesh, TEXT("ToolTip"), TEXT("The skeletal mesh used by this component."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkinnedMeshComponent(Z_Construct_UClass_USkinnedMeshComponent, TEXT("USkinnedMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkinnedMeshComponent);
	UEnum* Z_Construct_UEnum_Engine_EAngularDriveMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAngularDriveMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAngularDriveMode"), 0, Get_Z_Construct_UEnum_Engine_EAngularDriveMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAngularDriveMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAngularDriveMode::SLERP")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAngularDriveMode::TwistAndSwing")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAngularDriveMode::EAngularDriveMode_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(ReturnEnum, TEXT("SLERP.ToolTip"), TEXT("Follows the shortest arc between a pair of anuglar configurations (Ignored if any angular limits/locks are used)."));
			MetaData->SetValue(ReturnEnum, TEXT("TwistAndSwing.ToolTip"), TEXT("Path is decomposed into twist and swing. Doesn't follow shortest arc and may have gimbal lock. (Works with angular limits/locks.)"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAngularDriveMode_CRC() { return 983277393U; }
	UEnum* Z_Construct_UEnum_Engine_EConstraintFrame()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EConstraintFrame_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EConstraintFrame"), 0, Get_Z_Construct_UEnum_Engine_EConstraintFrame_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EConstraintFrame"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EConstraintFrame::Frame1")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EConstraintFrame::Frame2")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EConstraintFrame::EConstraintFrame_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enum to indicate which frame we want."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EConstraintFrame_CRC() { return 337425864U; }
	UEnum* Z_Construct_UEnum_Engine_ELinearConstraintMotion()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ELinearConstraintMotion_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ELinearConstraintMotion"), 0, Get_Z_Construct_UEnum_Engine_ELinearConstraintMotion_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ELinearConstraintMotion"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LCM_Free")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LCM_Limited")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LCM_Locked")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LCM_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("LCM_Free.DisplayName"), TEXT("Free"));
			MetaData->SetValue(ReturnEnum, TEXT("LCM_Free.ToolTip"), TEXT("No constraint against this axis."));
			MetaData->SetValue(ReturnEnum, TEXT("LCM_Limited.DisplayName"), TEXT("Limited"));
			MetaData->SetValue(ReturnEnum, TEXT("LCM_Limited.ToolTip"), TEXT("Limited freedom along this axis."));
			MetaData->SetValue(ReturnEnum, TEXT("LCM_Locked.DisplayName"), TEXT("Locked"));
			MetaData->SetValue(ReturnEnum, TEXT("LCM_Locked.ToolTip"), TEXT("Fully constraint against this axis."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("LINEAR DOF"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ELinearConstraintMotion_CRC() { return 774375087U; }
	UScriptStruct* Z_Construct_UScriptStruct_FConstraintInstance()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FConstraintInstance_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ConstraintInstance"), sizeof(FConstraintInstance), Get_Z_Construct_UScriptStruct_FConstraintInstance_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstraintInstance"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FConstraintInstance>, EStructFlags(0x00000205));
			UProperty* NewProp_AngularDriveForceLimit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularDriveForceLimit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularDriveForceLimit, FConstraintInstance), 0x0000000000000015);
			UProperty* NewProp_AngularDriveDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularDriveDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularDriveDamping, FConstraintInstance), 0x0000000000000015);
			UProperty* NewProp_AngularDriveSpring = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularDriveSpring"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularDriveSpring, FConstraintInstance), 0x0000000000000015);
			UProperty* NewProp_AngularVelocityTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularVelocityTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AngularVelocityTarget, FConstraintInstance), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AngularOrientationTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularOrientationTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AngularOrientationTarget, FConstraintInstance), 0x0000000000000015, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_AngularDriveMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularDriveMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(AngularDriveMode, FConstraintInstance), 0x0000000000000015, Z_Construct_UEnum_Engine_EAngularDriveMode());
			UProperty* NewProp_AngularPositionTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularPositionTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AngularPositionTarget_DEPRECATED, FConstraintInstance), 0x0000000020000000, Z_Construct_UScriptStruct_FQuat());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAngularVelocityDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bAngularVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAngularVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAngularVelocityDrive, FConstraintInstance), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAngularVelocityDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableTwistDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bEnableTwistDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEnableTwistDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableTwistDrive, FConstraintInstance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bEnableTwistDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableSwingDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bEnableSwingDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEnableSwingDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableSwingDrive, FConstraintInstance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bEnableSwingDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAngularOrientationDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bAngularOrientationDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAngularOrientationDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAngularOrientationDrive, FConstraintInstance), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAngularOrientationDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAngularSlerpDrive_DEPRECATED, FConstraintInstance, uint8);
			UProperty* NewProp_bAngularSlerpDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAngularSlerpDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAngularSlerpDrive_DEPRECATED, FConstraintInstance), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bAngularSlerpDrive_DEPRECATED, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTwistVelocityDrive_DEPRECATED, FConstraintInstance, uint8);
			UProperty* NewProp_bTwistVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bTwistVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTwistVelocityDrive_DEPRECATED, FConstraintInstance), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bTwistVelocityDrive_DEPRECATED, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTwistPositionDrive_DEPRECATED, FConstraintInstance, uint8);
			UProperty* NewProp_bTwistPositionDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bTwistPositionDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTwistPositionDrive_DEPRECATED, FConstraintInstance), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bTwistPositionDrive_DEPRECATED, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSwingVelocityDrive_DEPRECATED, FConstraintInstance, uint8);
			UProperty* NewProp_bSwingVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSwingVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSwingVelocityDrive_DEPRECATED, FConstraintInstance), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bSwingVelocityDrive_DEPRECATED, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSwingPositionDrive_DEPRECATED, FConstraintInstance, uint8);
			UProperty* NewProp_bSwingPositionDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSwingPositionDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSwingPositionDrive_DEPRECATED, FConstraintInstance), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bSwingPositionDrive_DEPRECATED, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_LinearDriveForceLimit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearDriveForceLimit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearDriveForceLimit, FConstraintInstance), 0x0000000000000015);
			UProperty* NewProp_LinearDriveDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearDriveDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearDriveDamping, FConstraintInstance), 0x0000000000000015);
			UProperty* NewProp_LinearDriveSpring = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearDriveSpring"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearDriveSpring, FConstraintInstance), 0x0000000000000015);
			UProperty* NewProp_LinearVelocityTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearVelocityTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LinearVelocityTarget, FConstraintInstance), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LinearPositionTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearPositionTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LinearPositionTarget, FConstraintInstance), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearVelocityDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearVelocityDrive, FConstraintInstance), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bLinearVelocityDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearPositionDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearPositionDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearPositionDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearPositionDrive, FConstraintInstance), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bLinearPositionDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearZVelocityDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearZVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearZVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearZVelocityDrive, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearZVelocityDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearZPositionDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearZPositionDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearZPositionDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearZPositionDrive, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearZPositionDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearYVelocityDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearYVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearYVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearYVelocityDrive, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearYVelocityDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearYPositionDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearYPositionDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearYPositionDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearYPositionDrive, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearYPositionDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearXVelocityDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearXVelocityDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearXVelocityDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearXVelocityDrive, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearXVelocityDrive, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearXPositionDrive, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearXPositionDrive = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearXPositionDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearXPositionDrive, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearXPositionDrive, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_AngularBreakThreshold = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularBreakThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularBreakThreshold, FConstraintInstance), 0x0000040000000001);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAngularBreakable, FConstraintInstance, uint8);
			UProperty* NewProp_bAngularBreakable = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAngularBreakable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAngularBreakable, FConstraintInstance), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bAngularBreakable, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_AngularRotationOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularRotationOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AngularRotationOffset, FConstraintInstance), 0x0000000000000001, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_TwistLimitDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TwistLimitDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TwistLimitDamping, FConstraintInstance), 0x0000040000000001);
			UProperty* NewProp_TwistLimitStiffness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TwistLimitStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TwistLimitStiffness, FConstraintInstance), 0x0000040000000001);
			UProperty* NewProp_SwingLimitDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SwingLimitDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SwingLimitDamping, FConstraintInstance), 0x0000040000000001);
			UProperty* NewProp_SwingLimitStiffness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SwingLimitStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SwingLimitStiffness, FConstraintInstance), 0x0000040000000001);
			UProperty* NewProp_Swing2LimitAngle = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Swing2LimitAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Swing2LimitAngle, FConstraintInstance), 0x0000000000000001);
			UProperty* NewProp_TwistLimitAngle = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TwistLimitAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TwistLimitAngle, FConstraintInstance), 0x0000000000000001);
			UProperty* NewProp_Swing1LimitAngle = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Swing1LimitAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Swing1LimitAngle, FConstraintInstance), 0x0000000000000001);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTwistLimitSoft, FConstraintInstance, uint8);
			UProperty* NewProp_bTwistLimitSoft = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bTwistLimitSoft"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTwistLimitSoft, FConstraintInstance), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bTwistLimitSoft, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSwingLimitSoft, FConstraintInstance, uint8);
			UProperty* NewProp_bSwingLimitSoft = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSwingLimitSoft"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSwingLimitSoft, FConstraintInstance), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bSwingLimitSoft, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_AngularSwing2Motion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularSwing2Motion"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(AngularSwing2Motion, FConstraintInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_EAngularConstraintMotion());
			UProperty* NewProp_AngularTwistMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularTwistMotion"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(AngularTwistMotion, FConstraintInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_EAngularConstraintMotion());
			UProperty* NewProp_AngularSwing1Motion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AngularSwing1Motion"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(AngularSwing1Motion, FConstraintInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_EAngularConstraintMotion());
			UProperty* NewProp_LinearBreakThreshold = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearBreakThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearBreakThreshold, FConstraintInstance), 0x0000040000000001);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearBreakable, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearBreakable = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearBreakable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearBreakable, FConstraintInstance), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearBreakable, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_LinearLimitDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearLimitDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearLimitDamping, FConstraintInstance), 0x0000040000000001);
			UProperty* NewProp_LinearLimitStiffness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearLimitStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearLimitStiffness, FConstraintInstance), 0x0000040000000001);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinearLimitSoft, FConstraintInstance, uint8);
			UProperty* NewProp_bLinearLimitSoft = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLinearLimitSoft"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinearLimitSoft, FConstraintInstance), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bLinearLimitSoft, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_LinearLimitSize = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearLimitSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearLimitSize, FConstraintInstance), 0x0000000000000001);
			UProperty* NewProp_LinearZMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearZMotion"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LinearZMotion, FConstraintInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_ELinearConstraintMotion());
			UProperty* NewProp_LinearYMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearYMotion"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LinearYMotion, FConstraintInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_ELinearConstraintMotion());
			UProperty* NewProp_LinearXMotion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearXMotion"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LinearXMotion, FConstraintInstance), 0x0000000000000001, Z_Construct_UEnum_Engine_ELinearConstraintMotion());
			UProperty* NewProp_ProjectionAngularTolerance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ProjectionAngularTolerance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ProjectionAngularTolerance, FConstraintInstance), 0x0000000000000001);
			UProperty* NewProp_ProjectionLinearTolerance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ProjectionLinearTolerance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ProjectionLinearTolerance, FConstraintInstance), 0x0000000000000001);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableProjection, FConstraintInstance, uint8);
			UProperty* NewProp_bEnableProjection = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEnableProjection"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableProjection, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bEnableProjection, FConstraintInstance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableCollision, FConstraintInstance, uint8);
			UProperty* NewProp_bDisableCollision = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bDisableCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableCollision, FConstraintInstance), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bDisableCollision, FConstraintInstance), sizeof(uint8), false);
			UProperty* NewProp_SecAxis2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SecAxis2"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SecAxis2, FConstraintInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PriAxis2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PriAxis2"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PriAxis2, FConstraintInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Pos2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Pos2"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Pos2, FConstraintInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_SecAxis1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SecAxis1"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SecAxis1, FConstraintInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PriAxis1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PriAxis1"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PriAxis1, FConstraintInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Pos1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Pos1"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Pos1, FConstraintInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ConstraintBone2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ConstraintBone2"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ConstraintBone2, FConstraintInstance), 0x0000000000000001);
			UProperty* NewProp_ConstraintBone1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ConstraintBone1"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ConstraintBone1, FConstraintInstance), 0x0000000000000001);
			UProperty* NewProp_JointName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("JointName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(JointName, FConstraintInstance), 0x0000000000020001);
			UProperty* NewProp_OwnerComponent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OwnerComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OwnerComponent, FConstraintInstance), 0x0000000000080008, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Container for a physics representation of an object."));
			MetaData->SetValue(NewProp_AngularDriveForceLimit, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_AngularDriveForceLimit, TEXT("DisplayName"), TEXT("Max Angular Force"));
			MetaData->SetValue(NewProp_AngularDriveForceLimit, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularDriveForceLimit, TEXT("ToolTip"), TEXT("Limit to the force the angular drive can apply."));
			MetaData->SetValue(NewProp_AngularDriveDamping, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_AngularDriveDamping, TEXT("DisplayName"), TEXT("Angular Velocity Strength"));
			MetaData->SetValue(NewProp_AngularDriveDamping, TEXT("editcondition"), TEXT("bAngularVelocityDrive"));
			MetaData->SetValue(NewProp_AngularDriveDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularDriveDamping, TEXT("ToolTip"), TEXT("Damping value to apply to the for angular drive."));
			MetaData->SetValue(NewProp_AngularDriveSpring, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_AngularDriveSpring, TEXT("DisplayName"), TEXT("Angular Position Strength"));
			MetaData->SetValue(NewProp_AngularDriveSpring, TEXT("editcondition"), TEXT("bAngularOrientationDrive"));
			MetaData->SetValue(NewProp_AngularDriveSpring, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularDriveSpring, TEXT("ToolTip"), TEXT("Spring value to apply to the for angular drive."));
			MetaData->SetValue(NewProp_AngularVelocityTarget, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_AngularVelocityTarget, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularVelocityTarget, TEXT("ToolTip"), TEXT("Target velocity for the angular drive."));
			MetaData->SetValue(NewProp_AngularOrientationTarget, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_AngularOrientationTarget, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularOrientationTarget, TEXT("ToolTip"), TEXT("Target orientation for the angular drive."));
			MetaData->SetValue(NewProp_AngularDriveMode, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_AngularDriveMode, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularDriveMode, TEXT("ToolTip"), TEXT("The way rotation paths are estimated"));
			MetaData->SetValue(NewProp_AngularPositionTarget, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bAngularVelocityDrive, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_bAngularVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bAngularVelocityDrive, TEXT("ToolTip"), TEXT("Enables the angular drive towards a target velocity."));
			MetaData->SetValue(NewProp_bEnableTwistDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bEnableTwistDrive, TEXT("ToolTip"), TEXT("Enables the swing drive. Only relevant when in twist and swing mode"));
			MetaData->SetValue(NewProp_bEnableSwingDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bEnableSwingDrive, TEXT("ToolTip"), TEXT("Enables the swing drive. Only relevant when in twist and swing mode"));
			MetaData->SetValue(NewProp_bAngularOrientationDrive, TEXT("Category"), TEXT("AngularMotor"));
			MetaData->SetValue(NewProp_bAngularOrientationDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bAngularOrientationDrive, TEXT("ToolTip"), TEXT("Enables the angular drive towards a target orientation."));
			MetaData->SetValue(NewProp_bAngularSlerpDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bTwistVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bTwistPositionDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bSwingVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bSwingPositionDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearDriveForceLimit, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_LinearDriveForceLimit, TEXT("DisplayName"), TEXT("Max Linear Force"));
			MetaData->SetValue(NewProp_LinearDriveForceLimit, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearDriveForceLimit, TEXT("ToolTip"), TEXT("Limit to the force the linear drive can apply."));
			MetaData->SetValue(NewProp_LinearDriveDamping, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_LinearDriveDamping, TEXT("DisplayName"), TEXT("Linear Velocity Strength"));
			MetaData->SetValue(NewProp_LinearDriveDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearDriveDamping, TEXT("ToolTip"), TEXT("Damping to apply to the for linear drive."));
			MetaData->SetValue(NewProp_LinearDriveSpring, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_LinearDriveSpring, TEXT("DisplayName"), TEXT("Linear Position Strength"));
			MetaData->SetValue(NewProp_LinearDriveSpring, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearDriveSpring, TEXT("ToolTip"), TEXT("Spring to apply to the for linear drive."));
			MetaData->SetValue(NewProp_LinearVelocityTarget, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_LinearVelocityTarget, TEXT("editcondition"), TEXT("bLinearVelocityDrive"));
			MetaData->SetValue(NewProp_LinearVelocityTarget, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearVelocityTarget, TEXT("ToolTip"), TEXT("Target velocity the linear drive."));
			MetaData->SetValue(NewProp_LinearPositionTarget, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_LinearPositionTarget, TEXT("editcondition"), TEXT("bLinearPositionDrive"));
			MetaData->SetValue(NewProp_LinearPositionTarget, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearPositionTarget, TEXT("ToolTip"), TEXT("Target position the linear drive. Only the components that are enabled are used."));
			MetaData->SetValue(NewProp_bLinearVelocityDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearVelocityDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear velocity drive."));
			MetaData->SetValue(NewProp_bLinearPositionDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearPositionDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearPositionDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear position drive."));
			MetaData->SetValue(NewProp_bLinearZVelocityDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearZVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearZVelocityDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear velocity drive along the z axis."));
			MetaData->SetValue(NewProp_bLinearZPositionDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearZPositionDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearZPositionDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear position drive along the z axis."));
			MetaData->SetValue(NewProp_bLinearYVelocityDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearYVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearYVelocityDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear velocity drive along the y axis."));
			MetaData->SetValue(NewProp_bLinearYPositionDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearYPositionDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearYPositionDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear position drive along the y axis."));
			MetaData->SetValue(NewProp_bLinearXVelocityDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearXVelocityDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearXVelocityDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear velocity drive along the x axis."));
			MetaData->SetValue(NewProp_bLinearXPositionDrive, TEXT("Category"), TEXT("LinearMotor"));
			MetaData->SetValue(NewProp_bLinearXPositionDrive, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearXPositionDrive, TEXT("ToolTip"), TEXT("Enables/Disables linear position drive along the x axis."));
			MetaData->SetValue(NewProp_AngularBreakThreshold, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_AngularBreakThreshold, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_AngularBreakThreshold, TEXT("editcondition"), TEXT("bAngularBreakable"));
			MetaData->SetValue(NewProp_AngularBreakThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularBreakThreshold, TEXT("ToolTip"), TEXT("Angular force needed to break the joint."));
			MetaData->SetValue(NewProp_bAngularBreakable, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_bAngularBreakable, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bAngularBreakable, TEXT("ToolTip"), TEXT("Whether it is possible to break the joint with angular force."));
			MetaData->SetValue(NewProp_AngularRotationOffset, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_AngularRotationOffset, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularRotationOffset, TEXT("ToolTip"), TEXT("Specifies the angular offset between the two frames of reference. By default limit goes from (-Angle, +Angle)\nThis allows you to bias the limit for swing1 swing2 and twist."));
			MetaData->SetValue(NewProp_TwistLimitDamping, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_TwistLimitDamping, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_TwistLimitDamping, TEXT("editcondition"), TEXT("bTwistLimitSoft"));
			MetaData->SetValue(NewProp_TwistLimitDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_TwistLimitDamping, TEXT("ToolTip"), TEXT("Damping of the twist limit constraint if soft limit is used for twist motions."));
			MetaData->SetValue(NewProp_TwistLimitStiffness, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_TwistLimitStiffness, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_TwistLimitStiffness, TEXT("editcondition"), TEXT("bTwistLimitSoft"));
			MetaData->SetValue(NewProp_TwistLimitStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_TwistLimitStiffness, TEXT("ToolTip"), TEXT("Stiffness of the twist limit constraint if soft limit is used for twist motions."));
			MetaData->SetValue(NewProp_SwingLimitDamping, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_SwingLimitDamping, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_SwingLimitDamping, TEXT("editcondition"), TEXT("bSwingLimitSoft"));
			MetaData->SetValue(NewProp_SwingLimitDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_SwingLimitDamping, TEXT("ToolTip"), TEXT("Damping of the swing limit constraint if soft limit is used for swing motions."));
			MetaData->SetValue(NewProp_SwingLimitStiffness, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_SwingLimitStiffness, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_SwingLimitStiffness, TEXT("editcondition"), TEXT("bSwingLimitSoft"));
			MetaData->SetValue(NewProp_SwingLimitStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_SwingLimitStiffness, TEXT("ToolTip"), TEXT("Stiffness of the swing limit constraint if soft limit is used for swing motions."));
			MetaData->SetValue(NewProp_Swing2LimitAngle, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_Swing2LimitAngle, TEXT("ClampMax"), TEXT("180.0"));
			MetaData->SetValue(NewProp_Swing2LimitAngle, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Swing2LimitAngle, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_Swing2LimitAngle, TEXT("ToolTip"), TEXT("Used if swing motion along the z axis is limited. The limit angle is specified in degrees and should be\n      between 0 and 180."));
			MetaData->SetValue(NewProp_TwistLimitAngle, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_TwistLimitAngle, TEXT("ClampMax"), TEXT("180.0"));
			MetaData->SetValue(NewProp_TwistLimitAngle, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_TwistLimitAngle, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_TwistLimitAngle, TEXT("ToolTip"), TEXT("Used if twist motion along the x axis is limited. The limit angle is specified in degrees and should be\n              between 0 and 180."));
			MetaData->SetValue(NewProp_Swing1LimitAngle, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_Swing1LimitAngle, TEXT("ClampMax"), TEXT("180.0"));
			MetaData->SetValue(NewProp_Swing1LimitAngle, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Swing1LimitAngle, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_Swing1LimitAngle, TEXT("ToolTip"), TEXT("Used if swing motion along the y axis is limited. The limit angle is specified in degrees and should be\n              between 0 and 180."));
			MetaData->SetValue(NewProp_bTwistLimitSoft, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_bTwistLimitSoft, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bTwistLimitSoft, TEXT("ToolTip"), TEXT("Whether we want to use soft limits for twist motions instead of hard limits. With enabled\n              soft limit, a constraint is used instead of hard-capping the motion."));
			MetaData->SetValue(NewProp_bSwingLimitSoft, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_bSwingLimitSoft, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bSwingLimitSoft, TEXT("ToolTip"), TEXT("Whether we want to use soft limits for swing motions instead of hard limits. With enabled\n              soft limit, a constraint is used instead of hard-capping the motion."));
			MetaData->SetValue(NewProp_AngularSwing2Motion, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_AngularSwing2Motion, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularSwing2Motion, TEXT("ToolTip"), TEXT("Indicates whether rotation about the Y axis is allowed, blocked, or limited. If limited, the\n              AngularLimit property will be used to determine the range of motion. See EAngularConstraintMotion."));
			MetaData->SetValue(NewProp_AngularTwistMotion, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_AngularTwistMotion, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularTwistMotion, TEXT("ToolTip"), TEXT("Indicates whether rotation about the the X axis is allowed, blocked, or limited. If limited, the\n              AngularLimit property will be used to determine the range of motion. See EAngularConstraintMotion."));
			MetaData->SetValue(NewProp_AngularSwing1Motion, TEXT("Category"), TEXT("Angular"));
			MetaData->SetValue(NewProp_AngularSwing1Motion, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_AngularSwing1Motion, TEXT("ToolTip"), TEXT("Indicates whether rotation about the Z axis is allowed, blocked, or limited. If limited, the\n              AngularLimit property will be used to determine the range of motion. See EAngularConstraintMotion."));
			MetaData->SetValue(NewProp_LinearBreakThreshold, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearBreakThreshold, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_LinearBreakThreshold, TEXT("editcondition"), TEXT("bLinearBreakable"));
			MetaData->SetValue(NewProp_LinearBreakThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearBreakThreshold, TEXT("ToolTip"), TEXT("Force needed to break the joint."));
			MetaData->SetValue(NewProp_bLinearBreakable, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_bLinearBreakable, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearBreakable, TEXT("ToolTip"), TEXT("Defines whether the joint is breakable or not."));
			MetaData->SetValue(NewProp_LinearLimitDamping, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearLimitDamping, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_LinearLimitDamping, TEXT("editcondition"), TEXT("bLinearLimitSoft"));
			MetaData->SetValue(NewProp_LinearLimitDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearLimitDamping, TEXT("ToolTip"), TEXT("Damping of the linear soft limit constraint. Only used, when bLinearLimitSoft is true."));
			MetaData->SetValue(NewProp_LinearLimitStiffness, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearLimitStiffness, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_LinearLimitStiffness, TEXT("editcondition"), TEXT("bLinearLimitSoft"));
			MetaData->SetValue(NewProp_LinearLimitStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearLimitStiffness, TEXT("ToolTip"), TEXT("Stiffness of the linear soft limit constraint. Only used, when bLinearLimitSoft is true."));
			MetaData->SetValue(NewProp_bLinearLimitSoft, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_bLinearLimitSoft, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bLinearLimitSoft, TEXT("ToolTip"), TEXT("Whether we want to use soft limits instead of hard limits. With enabled soft limit, a constraint is used\n              instead of hard-capping the motion."));
			MetaData->SetValue(NewProp_LinearLimitSize, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearLimitSize, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_LinearLimitSize, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearLimitSize, TEXT("ToolTip"), TEXT("The limiting extent in world untis of the linear motion for limitied motion axes."));
			MetaData->SetValue(NewProp_LinearZMotion, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearZMotion, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearZMotion, TEXT("ToolTip"), TEXT("Indicates whether linear motion along the z axis is allowed, blocked or limited. If limited, the LinearLimit property will be used\n              to determine if a motion is allowed. See ELinearConstraintMotion."));
			MetaData->SetValue(NewProp_LinearYMotion, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearYMotion, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearYMotion, TEXT("ToolTip"), TEXT("Indicates whether linear motion along the y axis is allowed, blocked or limited. If limited, the LinearLimit property will be used\n              to determine if a motion is allowed. See ELinearConstraintMotion."));
			MetaData->SetValue(NewProp_LinearXMotion, TEXT("Category"), TEXT("Linear"));
			MetaData->SetValue(NewProp_LinearXMotion, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_LinearXMotion, TEXT("ToolTip"), TEXT("Indicates whether linear motion along the x axis is allowed, blocked or limited. If limited, the LinearLimit property will be used\n              to determine if a motion is allowed. See ELinearConstraintMotion."));
			MetaData->SetValue(NewProp_ProjectionAngularTolerance, TEXT("Category"), TEXT("Projection"));
			MetaData->SetValue(NewProp_ProjectionAngularTolerance, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_ProjectionAngularTolerance, TEXT("editcondition"), TEXT("bEnableProjection"));
			MetaData->SetValue(NewProp_ProjectionAngularTolerance, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_ProjectionAngularTolerance, TEXT("ToolTip"), TEXT("Angular tolerance value in world units. If the distance error exceeds this tolarance limit, the body will be projected."));
			MetaData->SetValue(NewProp_ProjectionLinearTolerance, TEXT("Category"), TEXT("Projection"));
			MetaData->SetValue(NewProp_ProjectionLinearTolerance, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_ProjectionLinearTolerance, TEXT("editcondition"), TEXT("bEnableProjection"));
			MetaData->SetValue(NewProp_ProjectionLinearTolerance, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_ProjectionLinearTolerance, TEXT("ToolTip"), TEXT("Linear tolerance value in world units. If the distance error exceeds this tolarance limit, the body will be projected."));
			MetaData->SetValue(NewProp_bEnableProjection, TEXT("Category"), TEXT("Projection"));
			MetaData->SetValue(NewProp_bEnableProjection, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bEnableProjection, TEXT("ToolTip"), TEXT("If distance error between bodies exceeds 0.1 units, or rotation error exceeds 10 degrees, body will be projected to fix this.\nFor example a chain spinning too fast will have its elements appear detached due to velocity, this will project all bodies so they still appear attached to each other."));
			MetaData->SetValue(NewProp_bDisableCollision, TEXT("Category"), TEXT("Constraint"));
			MetaData->SetValue(NewProp_bDisableCollision, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_bDisableCollision, TEXT("ToolTip"), TEXT("Disable collision between bodies joined by this constraint."));
			MetaData->SetValue(NewProp_SecAxis2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_SecAxis2, TEXT("ToolTip"), TEXT("Seconday axis in Body2 reference frame. Orthogonal to PriAxis2."));
			MetaData->SetValue(NewProp_PriAxis2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_PriAxis2, TEXT("ToolTip"), TEXT("Primary (twist) axis in Body2 reference frame."));
			MetaData->SetValue(NewProp_Pos2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_Pos2, TEXT("ToolTip"), TEXT("Location of constraint in Body2 reference frame."));
			MetaData->SetValue(NewProp_SecAxis1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_SecAxis1, TEXT("ToolTip"), TEXT("Seconday axis in Body1 reference frame. Orthogonal to PriAxis1."));
			MetaData->SetValue(NewProp_PriAxis1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_PriAxis1, TEXT("ToolTip"), TEXT("Primary (twist) axis in Body1 reference frame."));
			MetaData->SetValue(NewProp_Pos1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_Pos1, TEXT("ToolTip"), TEXT("Location of constraint in Body1 reference frame."));
			MetaData->SetValue(NewProp_ConstraintBone2, TEXT("Category"), TEXT("Constraint"));
			MetaData->SetValue(NewProp_ConstraintBone2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_ConstraintBone2, TEXT("ToolTip"), TEXT("Name of second bone (body) that this constraint is connecting.\nThis will be the 'parent' bone in a PhysicsAset."));
			MetaData->SetValue(NewProp_ConstraintBone1, TEXT("Category"), TEXT("Constraint"));
			MetaData->SetValue(NewProp_ConstraintBone1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_ConstraintBone1, TEXT("ToolTip"), TEXT("Name of first bone (body) that this constraint is connecting.\nThis will be the 'child' bone in a PhysicsAsset."));
			MetaData->SetValue(NewProp_JointName, TEXT("Category"), TEXT("Constraint"));
			MetaData->SetValue(NewProp_JointName, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_JointName, TEXT("ToolTip"), TEXT("Name of bone that this joint is associated with."));
			MetaData->SetValue(NewProp_OwnerComponent, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_OwnerComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/ConstraintInstance.h"));
			MetaData->SetValue(NewProp_OwnerComponent, TEXT("ToolTip"), TEXT("The component that created this instance."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FConstraintInstance_CRC() { return 3879574769U; }
	UFunction* Z_Construct_UDelegateFunction_Engine_ConstraintBrokenSignature__DelegateSignature()
	{
		struct _Script_Engine_eventConstraintBrokenSignature_Parms
		{
			int32 ConstraintIndex;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstraintBrokenSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventConstraintBrokenSignature_Parms));
			UProperty* NewProp_ConstraintIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstraintIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ConstraintIndex, _Script_Engine_eventConstraintBrokenSignature_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Dynamic delegate to use by components that want to route the broken-event into blueprints"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_BreakConstraint()
	{
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BreakConstraint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Break this constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetConstraintForce()
	{
		struct PhysicsConstraintComponent_eventGetConstraintForce_Parms
		{
			FVector OutLinearForce;
			FVector OutAngularForce;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetConstraintForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventGetConstraintForce_Parms));
			UProperty* NewProp_OutAngularForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutAngularForce"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutAngularForce, PhysicsConstraintComponent_eventGetConstraintForce_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OutLinearForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutLinearForce"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutLinearForce, PhysicsConstraintComponent_eventGetConstraintForce_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Retrieve the constraint force most recently applied to maintain this constraint. Returns 0 forces if the constraint is not initialized or broken."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing1()
	{
		struct PhysicsConstraintComponent_eventGetCurrentSwing1_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentSwing1"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(PhysicsConstraintComponent_eventGetCurrentSwing1_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsConstraintComponent_eventGetCurrentSwing1_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the current Swing1 of the constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing2()
	{
		struct PhysicsConstraintComponent_eventGetCurrentSwing2_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentSwing2"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(PhysicsConstraintComponent_eventGetCurrentSwing2_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsConstraintComponent_eventGetCurrentSwing2_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the current Swing2 of the constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentTwist()
	{
		struct PhysicsConstraintComponent_eventGetCurrentTwist_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentTwist"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(PhysicsConstraintComponent_eventGetCurrentTwist_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsConstraintComponent_eventGetCurrentTwist_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the current Angular Twist of the constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularDriveParams()
	{
		struct PhysicsConstraintComponent_eventSetAngularDriveParams_Parms
		{
			float InSpring;
			float InDamping;
			float InForceLimit;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularDriveParams"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularDriveParams_Parms));
			UProperty* NewProp_InForceLimit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InForceLimit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InForceLimit, PhysicsConstraintComponent_eventSetAngularDriveParams_Parms), 0x0000000000000080);
			UProperty* NewProp_InDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InDamping, PhysicsConstraintComponent_eventSetAngularDriveParams_Parms), 0x0000000000000080);
			UProperty* NewProp_InSpring = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSpring"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InSpring, PhysicsConstraintComponent_eventSetAngularDriveParams_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the drive params for the angular drive.\n    @param InSpring         Spring force for the drive\n    @param InDamping        Damping of the drive\n    @param InForceLimit     Max force applied by the drive"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationDrive()
	{
		struct PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms
		{
			bool bEnableSwingDrive;
			bool bEnableTwistDrive;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularOrientationDrive"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableTwistDrive, PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms, bool);
			UProperty* NewProp_bEnableTwistDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableTwistDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableTwistDrive, PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableTwistDrive, PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableSwingDrive, PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms, bool);
			UProperty* NewProp_bEnableSwingDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableSwingDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableSwingDrive, PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableSwingDrive, PhysicsConstraintComponent_eventSetAngularOrientationDrive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables/Disables angular orientation drive\n\n    @param bEnableSwingDrive        Indicates whether the drive for the swing axis should be enabled\n    @param bEnableTwistDrive        Indicates whether the drive for the twist axis should be enabled"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationTarget()
	{
		struct PhysicsConstraintComponent_eventSetAngularOrientationTarget_Parms
		{
			FRotator InPosTarget;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularOrientationTarget"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularOrientationTarget_Parms));
			UProperty* NewProp_InPosTarget = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPosTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InPosTarget, PhysicsConstraintComponent_eventSetAngularOrientationTarget_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the target orientation for the angular drive.\n    @param InPosTarget              Target orientation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing1Limit()
	{
		struct PhysicsConstraintComponent_eventSetAngularSwing1Limit_Parms
		{
			TEnumAsByte<EAngularConstraintMotion> MotionType;
			float Swing1LimitAngle;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularSwing1Limit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularSwing1Limit_Parms));
			UProperty* NewProp_Swing1LimitAngle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Swing1LimitAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Swing1LimitAngle, PhysicsConstraintComponent_eventSetAngularSwing1Limit_Parms), 0x0000000000000080);
			UProperty* NewProp_MotionType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MotionType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(MotionType, PhysicsConstraintComponent_eventSetAngularSwing1Limit_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EAngularConstraintMotion());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the Angular Swing1 Motion Type\n     @param ConstraintType   New Constraint Type\n     @param Swing1LimitAngle Size of limit in degrees"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing2Limit()
	{
		struct PhysicsConstraintComponent_eventSetAngularSwing2Limit_Parms
		{
			TEnumAsByte<EAngularConstraintMotion> MotionType;
			float Swing2LimitAngle;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularSwing2Limit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularSwing2Limit_Parms));
			UProperty* NewProp_Swing2LimitAngle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Swing2LimitAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Swing2LimitAngle, PhysicsConstraintComponent_eventSetAngularSwing2Limit_Parms), 0x0000000000000080);
			UProperty* NewProp_MotionType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MotionType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(MotionType, PhysicsConstraintComponent_eventSetAngularSwing2Limit_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EAngularConstraintMotion());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the Angular Swing2 Motion Type\n     @param ConstraintType   New Constraint Type\n     @param Swing2LimitAngle Size of limit in degrees"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularTwistLimit()
	{
		struct PhysicsConstraintComponent_eventSetAngularTwistLimit_Parms
		{
			TEnumAsByte<EAngularConstraintMotion> ConstraintType;
			float TwistLimitAngle;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularTwistLimit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularTwistLimit_Parms));
			UProperty* NewProp_TwistLimitAngle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TwistLimitAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TwistLimitAngle, PhysicsConstraintComponent_eventSetAngularTwistLimit_Parms), 0x0000000000000080);
			UProperty* NewProp_ConstraintType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstraintType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ConstraintType, PhysicsConstraintComponent_eventSetAngularTwistLimit_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EAngularConstraintMotion());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the Angular Twist Motion Type\n     @param ConstraintType   New Constraint Type\n     @param TwistLimitAngle  Size of limit in degrees"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityDrive()
	{
		struct PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms
		{
			bool bEnableSwingDrive;
			bool bEnableTwistDrive;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularVelocityDrive"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableTwistDrive, PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableTwistDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableTwistDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableTwistDrive, PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableTwistDrive, PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableSwingDrive, PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableSwingDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableSwingDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableSwingDrive, PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableSwingDrive, PhysicsConstraintComponent_eventSetAngularVelocityDrive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables/Disables angular velocity drive\n\n    @param bEnableSwingDrive        Indicates whether the drive for the swing axis should be enabled\n    @param bEnableTwistDrive        Indicates whether the drive for the twit axis should be enabled"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityTarget()
	{
		struct PhysicsConstraintComponent_eventSetAngularVelocityTarget_Parms
		{
			FVector InVelTarget;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularVelocityTarget"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetAngularVelocityTarget_Parms));
			UProperty* NewProp_InVelTarget = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InVelTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InVelTarget, PhysicsConstraintComponent_eventSetAngularVelocityTarget_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the target velocity for the angular drive.\n    @param InVelTarget              Target velocity"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstrainedComponents()
	{
		struct PhysicsConstraintComponent_eventSetConstrainedComponents_Parms
		{
			UPrimitiveComponent* Component1;
			FName BoneName1;
			UPrimitiveComponent* Component2;
			FName BoneName2;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetConstrainedComponents"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetConstrainedComponents_Parms));
			UProperty* NewProp_BoneName2 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName2"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName2, PhysicsConstraintComponent_eventSetConstrainedComponents_Parms), 0x0000000000000080);
			UProperty* NewProp_Component2 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Component2"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Component2, PhysicsConstraintComponent_eventSetConstrainedComponents_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_BoneName1 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName1"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName1, PhysicsConstraintComponent_eventSetConstrainedComponents_Parms), 0x0000000000000080);
			UProperty* NewProp_Component1 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Component1"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Component1, PhysicsConstraintComponent_eventSetConstrainedComponents_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Directly specify component to connect. Will update frames based on current position."));
			MetaData->SetValue(NewProp_Component2, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_Component1, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceFrame()
	{
		struct PhysicsConstraintComponent_eventSetConstraintReferenceFrame_Parms
		{
			TEnumAsByte<EConstraintFrame::Type> Frame;
			FTransform RefFrame;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetConstraintReferenceFrame"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetConstraintReferenceFrame_Parms));
			UProperty* NewProp_RefFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("RefFrame"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RefFrame, PhysicsConstraintComponent_eventSetConstraintReferenceFrame_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Frame, PhysicsConstraintComponent_eventSetConstraintReferenceFrame_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EConstraintFrame());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Pass in reference frame in. If the constraint is currently active, this will set its active local pose. Otherwise the change will take affect in InitConstraint."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceOrientation()
	{
		struct PhysicsConstraintComponent_eventSetConstraintReferenceOrientation_Parms
		{
			TEnumAsByte<EConstraintFrame::Type> Frame;
			FVector PriAxis;
			FVector SecAxis;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetConstraintReferenceOrientation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetConstraintReferenceOrientation_Parms));
			UProperty* NewProp_SecAxis = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SecAxis"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SecAxis, PhysicsConstraintComponent_eventSetConstraintReferenceOrientation_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PriAxis = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PriAxis"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PriAxis, PhysicsConstraintComponent_eventSetConstraintReferenceOrientation_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Frame, PhysicsConstraintComponent_eventSetConstraintReferenceOrientation_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EConstraintFrame());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Pass in reference orientation in (maintains reference position). If the constraint is currently active, this will set its active local pose. Otherwise the change will take affect in InitConstraint."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferencePosition()
	{
		struct PhysicsConstraintComponent_eventSetConstraintReferencePosition_Parms
		{
			TEnumAsByte<EConstraintFrame::Type> Frame;
			FVector RefPosition;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetConstraintReferencePosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetConstraintReferencePosition_Parms));
			UProperty* NewProp_RefPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("RefPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RefPosition, PhysicsConstraintComponent_eventSetConstraintReferencePosition_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Frame, PhysicsConstraintComponent_eventSetConstraintReferencePosition_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EConstraintFrame());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Pass in reference position in (maintains reference orientation). If the constraint is currently active, this will set its active local pose. Otherwise the change will take affect in InitConstraint."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetDisableCollision()
	{
		struct PhysicsConstraintComponent_eventSetDisableCollision_Parms
		{
			bool bDisableCollision;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDisableCollision"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetDisableCollision_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableCollision, PhysicsConstraintComponent_eventSetDisableCollision_Parms, bool);
			UProperty* NewProp_bDisableCollision = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bDisableCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableCollision, PhysicsConstraintComponent_eventSetDisableCollision_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bDisableCollision, PhysicsConstraintComponent_eventSetDisableCollision_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If true, the collision between the two rigid bodies of the constraint will be disabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearDriveParams()
	{
		struct PhysicsConstraintComponent_eventSetLinearDriveParams_Parms
		{
			float InSpring;
			float InDamping;
			float InForceLimit;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearDriveParams"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearDriveParams_Parms));
			UProperty* NewProp_InForceLimit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InForceLimit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InForceLimit, PhysicsConstraintComponent_eventSetLinearDriveParams_Parms), 0x0000000000000080);
			UProperty* NewProp_InDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InDamping, PhysicsConstraintComponent_eventSetLinearDriveParams_Parms), 0x0000000000000080);
			UProperty* NewProp_InSpring = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSpring"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InSpring, PhysicsConstraintComponent_eventSetLinearDriveParams_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the drive params for the linear drive.\n    @param InSpring         Spring force for the drive\n    @param InDamping        Damping of the drive\n    @param InForceLimit     Max force applied by the drive"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionDrive()
	{
		struct PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms
		{
			bool bEnableDriveX;
			bool bEnableDriveY;
			bool bEnableDriveZ;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearPositionDrive"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableDriveZ, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms, bool);
			UProperty* NewProp_bEnableDriveZ = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableDriveZ"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableDriveZ, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableDriveZ, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableDriveY, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms, bool);
			UProperty* NewProp_bEnableDriveY = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableDriveY"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableDriveY, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableDriveY, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableDriveX, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms, bool);
			UProperty* NewProp_bEnableDriveX = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableDriveX"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableDriveX, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableDriveX, PhysicsConstraintComponent_eventSetLinearPositionDrive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables/Disables linear position drive\n\n    @param bEnableDriveX    Indicates whether the drive for the X-Axis should be enabled\n    @param bEnableDriveY    Indicates whether the drive for the Y-Axis should be enabled\n    @param bEnableDriveZ    Indicates whether the drive for the Z-Axis should be enabled"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionTarget()
	{
		struct PhysicsConstraintComponent_eventSetLinearPositionTarget_Parms
		{
			FVector InPosTarget;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearPositionTarget"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearPositionTarget_Parms));
			UProperty* NewProp_InPosTarget = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPosTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InPosTarget, PhysicsConstraintComponent_eventSetLinearPositionTarget_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the target position for the linear drive.\n    @param InPosTarget              Target position"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityDrive()
	{
		struct PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms
		{
			bool bEnableDriveX;
			bool bEnableDriveY;
			bool bEnableDriveZ;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearVelocityDrive"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableDriveZ, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableDriveZ = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableDriveZ"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableDriveZ, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableDriveZ, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableDriveY, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableDriveY = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableDriveY"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableDriveY, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableDriveY, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableDriveX, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableDriveX = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableDriveX"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableDriveX, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableDriveX, PhysicsConstraintComponent_eventSetLinearVelocityDrive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables/Disables linear position drive\n\n    @param bEnableDriveX    Indicates whether the drive for the X-Axis should be enabled\n    @param bEnableDriveY    Indicates whether the drive for the Y-Axis should be enabled\n    @param bEnableDriveZ    Indicates whether the drive for the Z-Axis should be enabled"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityTarget()
	{
		struct PhysicsConstraintComponent_eventSetLinearVelocityTarget_Parms
		{
			FVector InVelTarget;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearVelocityTarget"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearVelocityTarget_Parms));
			UProperty* NewProp_InVelTarget = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InVelTarget"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InVelTarget, PhysicsConstraintComponent_eventSetLinearVelocityTarget_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the target velocity for the linear drive.\n    @param InVelTarget              Target velocity"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearXLimit()
	{
		struct PhysicsConstraintComponent_eventSetLinearXLimit_Parms
		{
			TEnumAsByte<ELinearConstraintMotion> ConstraintType;
			float LimitSize;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearXLimit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearXLimit_Parms));
			UProperty* NewProp_LimitSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LimitSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LimitSize, PhysicsConstraintComponent_eventSetLinearXLimit_Parms), 0x0000000000000080);
			UProperty* NewProp_ConstraintType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstraintType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ConstraintType, PhysicsConstraintComponent_eventSetLinearXLimit_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ELinearConstraintMotion());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the LinearX Motion Type\n     @param ConstraintType   New Constraint Type\n     @param LimitSize                Size of limit"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearYLimit()
	{
		struct PhysicsConstraintComponent_eventSetLinearYLimit_Parms
		{
			TEnumAsByte<ELinearConstraintMotion> ConstraintType;
			float LimitSize;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearYLimit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearYLimit_Parms));
			UProperty* NewProp_LimitSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LimitSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LimitSize, PhysicsConstraintComponent_eventSetLinearYLimit_Parms), 0x0000000000000080);
			UProperty* NewProp_ConstraintType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstraintType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ConstraintType, PhysicsConstraintComponent_eventSetLinearYLimit_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ELinearConstraintMotion());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the LinearY Motion Type\n     @param ConstraintType   New Constraint Type\n     @param LimitSize                Size of limit"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearZLimit()
	{
		struct PhysicsConstraintComponent_eventSetLinearZLimit_Parms
		{
			TEnumAsByte<ELinearConstraintMotion> ConstraintType;
			float LimitSize;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsConstraintComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearZLimit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsConstraintComponent_eventSetLinearZLimit_Parms));
			UProperty* NewProp_LimitSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LimitSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LimitSize, PhysicsConstraintComponent_eventSetLinearZLimit_Parms), 0x0000000000000080);
			UProperty* NewProp_ConstraintType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstraintType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ConstraintType, PhysicsConstraintComponent_eventSetLinearZLimit_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ELinearConstraintMotion());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsConstraint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the LinearZ Motion Type\n     @param ConstraintType   New Constraint Type\n     @param LimitSize                Size of limit"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPhysicsConstraintComponent_NoRegister()
	{
		return UPhysicsConstraintComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPhysicsConstraintComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPhysicsConstraintComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_BreakConstraint());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_GetConstraintForce());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing1());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing2());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentTwist());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularDriveParams());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationDrive());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing1Limit());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing2Limit());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularTwistLimit());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityDrive());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstrainedComponents());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceFrame());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceOrientation());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferencePosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetDisableCollision());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearDriveParams());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionDrive());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityDrive());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearXLimit());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearYLimit());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearZLimit());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ConstraintInstance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintInstance"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ConstraintInstance, UPhysicsConstraintComponent), 0x0000008000000001, Z_Construct_UScriptStruct_FConstraintInstance());
				UProperty* NewProp_OnConstraintBroken = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnConstraintBroken"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnConstraintBroken, UPhysicsConstraintComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ConstraintBrokenSignature__DelegateSignature());
				UProperty* NewProp_ConstraintSetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintSetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ConstraintSetup_DEPRECATED, UPhysicsConstraintComponent), 0x0002000020080008, Z_Construct_UClass_UPhysicsConstraintTemplate_NoRegister());
				UProperty* NewProp_ComponentName2 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ComponentName2"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ComponentName2, UPhysicsConstraintComponent), 0x0000000000000001, Z_Construct_UScriptStruct_FConstrainComponentPropName());
				UProperty* NewProp_ConstraintActor2 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintActor2"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ConstraintActor2, UPhysicsConstraintComponent), 0x0000000000000801, Z_Construct_UClass_AActor_NoRegister());
				UProperty* NewProp_ComponentName1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ComponentName1"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ComponentName1, UPhysicsConstraintComponent), 0x0000000000000001, Z_Construct_UScriptStruct_FConstrainComponentPropName());
				UProperty* NewProp_ConstraintActor1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ConstraintActor1"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ConstraintActor1, UPhysicsConstraintComponent), 0x0000000000000801, Z_Construct_UClass_AActor_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_BreakConstraint()); // 2661178600
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_GetConstraintForce()); // 850548934
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing1()); // 2670410975
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentSwing2()); // 3477733400
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_GetCurrentTwist()); // 2814364059
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularDriveParams()); // 926751898
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationDrive()); // 2993599408
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularOrientationTarget()); // 2364982629
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing1Limit()); // 1836919819
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularSwing2Limit()); // 17967021
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularTwistLimit()); // 1268265147
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityDrive()); // 608474689
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetAngularVelocityTarget()); // 579861439
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstrainedComponents()); // 2127923366
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceFrame()); // 835300773
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferenceOrientation()); // 4009858003
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetConstraintReferencePosition()); // 1539250497
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetDisableCollision()); // 631928725
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearDriveParams()); // 595003736
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionDrive()); // 14777871
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearPositionTarget()); // 1169724912
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityDrive()); // 1156399008
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearVelocityTarget()); // 581032796
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearXLimit()); // 364962651
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearYLimit()); // 3940179553
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsConstraintComponent_SetLinearZLimit()); // 4013196440
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Activation Components|Activation Physics Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Physics|Components|PhysicsConstraint"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("This is effectively a joint that allows you to connect 2 rigid bodies together. You can create different types of joints using the various parameters of this component."));
				MetaData->SetValue(NewProp_ConstraintInstance, TEXT("Category"), TEXT("ConstraintComponent"));
				MetaData->SetValue(NewProp_ConstraintInstance, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_ConstraintInstance, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_ConstraintInstance, TEXT("ToolTip"), TEXT("All constraint settings"));
				MetaData->SetValue(NewProp_OnConstraintBroken, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_OnConstraintBroken, TEXT("ToolTip"), TEXT("Notification when constraint is broken."));
				MetaData->SetValue(NewProp_ConstraintSetup, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ConstraintSetup, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_ComponentName2, TEXT("Category"), TEXT("Constraint"));
				MetaData->SetValue(NewProp_ComponentName2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_ComponentName2, TEXT("ToolTip"), TEXT("Name of second component property to constrain. If Actor2 is NULL, will look within Owner.\nIf this is NULL, will use RootComponent of Actor2"));
				MetaData->SetValue(NewProp_ConstraintActor2, TEXT("Category"), TEXT("Constraint"));
				MetaData->SetValue(NewProp_ConstraintActor2, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_ConstraintActor2, TEXT("ToolTip"), TEXT("Pointer to second Actor to constrain."));
				MetaData->SetValue(NewProp_ComponentName1, TEXT("Category"), TEXT("Constraint"));
				MetaData->SetValue(NewProp_ComponentName1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_ComponentName1, TEXT("ToolTip"), TEXT("Name of first component property to constrain. If Actor1 is NULL, will look within Owner.\nIf this is NULL, will use RootComponent of Actor1"));
				MetaData->SetValue(NewProp_ConstraintActor1, TEXT("Category"), TEXT("Constraint"));
				MetaData->SetValue(NewProp_ConstraintActor1, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsConstraintComponent.h"));
				MetaData->SetValue(NewProp_ConstraintActor1, TEXT("ToolTip"), TEXT("Pointer to first Actor to constrain."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPhysicsConstraintComponent(Z_Construct_UClass_UPhysicsConstraintComponent, TEXT("UPhysicsConstraintComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPhysicsConstraintComponent);
	UEnum* Z_Construct_UEnum_Engine_EAnimLinkMethod()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAnimLinkMethod_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAnimLinkMethod"), 0, Get_Z_Construct_UEnum_Engine_EAnimLinkMethod_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAnimLinkMethod"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimLinkMethod::Absolute")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimLinkMethod::Relative")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimLinkMethod::Proportional")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimLinkMethod::EAnimLinkMethod_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("Absolute.ToolTip"), TEXT("Element stays at a specific time without moving."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Proportional.ToolTip"), TEXT("Element moves with its segment and will stay at a certain proportion through the segment."));
			MetaData->SetValue(ReturnEnum, TEXT("Relative.ToolTip"), TEXT("Element moves with its segment, but not when the segment changes size."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Supported types of time for a linked element"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAnimLinkMethod_CRC() { return 3011885192U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimLinkableElement()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimLinkableElement_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimLinkableElement"), sizeof(FAnimLinkableElement), Get_Z_Construct_UScriptStruct_FAnimLinkableElement_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimLinkableElement"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimLinkableElement>, EStructFlags(0x00000001));
			UProperty* NewProp_LinkedSequence = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinkedSequence"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LinkedSequence, FAnimLinkableElement), 0x00000c0000020001, Z_Construct_UClass_UAnimSequenceBase_NoRegister());
			UProperty* NewProp_LinkValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinkValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinkValue, FAnimLinkableElement), 0x0000080000000000);
			UProperty* NewProp_SegmentLength = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SegmentLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SegmentLength, FAnimLinkableElement), 0x0000080000000000);
			UProperty* NewProp_SegmentBeginTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SegmentBeginTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SegmentBeginTime, FAnimLinkableElement), 0x0000080000000000);
			UProperty* NewProp_CachedLinkMethod = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CachedLinkMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CachedLinkMethod, FAnimLinkableElement), 0x0000080000000000, Z_Construct_UEnum_Engine_EAnimLinkMethod());
			UProperty* NewProp_LinkMethod = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinkMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LinkMethod, FAnimLinkableElement), 0x0000080000000001, Z_Construct_UEnum_Engine_EAnimLinkMethod());
			UProperty* NewProp_SegmentIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SegmentIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SegmentIndex, FAnimLinkableElement), 0x0000080000000000);
			UProperty* NewProp_SlotIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SlotIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SlotIndex, FAnimLinkableElement), 0x0000080000000001);
			UProperty* NewProp_LinkedMontage = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinkedMontage"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LinkedMontage, FAnimLinkableElement), 0x0000080000000000, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Used to describe an element that can be linked to a segment in a montage or sequence.\n   Usage:\n           Inherit from FAnimLinkableElement and make sure to call LinkMontage or LinkSequence\n           both on creation and on loading the element. From there SetTime and GetTime should be\n           used to control where this element is in the montage or sequence.\n\n           For more advanced usage, see this implementation used in FAnimNotifyEvent where\n           we have a secondary link to handle a duration\n           @see FAnimNotifyEvent"));
			MetaData->SetValue(NewProp_LinkedSequence, TEXT("Category"), TEXT("AnimLink"));
			MetaData->SetValue(NewProp_LinkedSequence, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_LinkedSequence, TEXT("ToolTip"), TEXT("The Animation Sequence that this montage element will link to, when the sequence changes\nin either length or rate; the element will correctly place itself in relation to the sequence"));
			MetaData->SetValue(NewProp_LinkValue, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_LinkValue, TEXT("ToolTip"), TEXT("The time of this montage. This will differ depending upon the method we are using to link the time for this element"));
			MetaData->SetValue(NewProp_SegmentLength, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_SegmentLength, TEXT("ToolTip"), TEXT("The absolute length of our currently linked segment"));
			MetaData->SetValue(NewProp_SegmentBeginTime, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_SegmentBeginTime, TEXT("ToolTip"), TEXT("The absolute time in the montage that our currently linked segment begins"));
			MetaData->SetValue(NewProp_CachedLinkMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_CachedLinkMethod, TEXT("ToolTip"), TEXT("Cached link method used to transform the time when LinkMethod changes, always relates to the currently stored time"));
			MetaData->SetValue(NewProp_LinkMethod, TEXT("Category"), TEXT("AnimLink"));
			MetaData->SetValue(NewProp_LinkMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_LinkMethod, TEXT("ToolTip"), TEXT("The method we are using to calculate our times"));
			MetaData->SetValue(NewProp_SegmentIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_SegmentIndex, TEXT("ToolTip"), TEXT("The index of the segment we are linked to within the slot we are using"));
			MetaData->SetValue(NewProp_SlotIndex, TEXT("Category"), TEXT("AnimLink"));
			MetaData->SetValue(NewProp_SlotIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_SlotIndex, TEXT("ToolTip"), TEXT("The slot index we are currently using within LinkedMontage"));
			MetaData->SetValue(NewProp_LinkedMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimLinkableElement.h"));
			MetaData->SetValue(NewProp_LinkedMontage, TEXT("ToolTip"), TEXT("The montage that this element is currently linked to"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimLinkableElement_CRC() { return 2279681508U; }
	UEnum* Z_Construct_UEnum_Engine_ECurveBlendOption()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ECurveBlendOption_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ECurveBlendOption"), 0, Get_Z_Construct_UEnum_Engine_ECurveBlendOption_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ECurveBlendOption"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECurveBlendOption::MaxWeight")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECurveBlendOption::NormalizeByWeight")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECurveBlendOption::BlendByWeight")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ECurveBlendOption::ECurveBlendOption_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlendByWeight.ToolTip"), TEXT("Blend By Weight without normalizing"));
			MetaData->SetValue(ReturnEnum, TEXT("MaxWeight.ToolTip"), TEXT("Find Max Weight of curve and use that weight."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("NormalizeByWeight.ToolTip"), TEXT("Normalize By Sum of Weight and use it to blend."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ECurveBlendOption_CRC() { return 3714861560U; }
	UEnum* Z_Construct_UEnum_Engine_EAdditiveAnimationType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAdditiveAnimationType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAdditiveAnimationType"), 0, Get_Z_Construct_UEnum_Engine_EAdditiveAnimationType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdditiveAnimationType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("AAT_None")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("AAT_LocalSpaceBase")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("AAT_RotationOffsetMeshSpace")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("AAT_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AAT_LocalSpaceBase.DisplayName"), TEXT("Local Space"));
			MetaData->SetValue(ReturnEnum, TEXT("AAT_LocalSpaceBase.ToolTip"), TEXT("Create Additive from LocalSpace Base."));
			MetaData->SetValue(ReturnEnum, TEXT("AAT_None.DisplayName"), TEXT("No additive"));
			MetaData->SetValue(ReturnEnum, TEXT("AAT_None.ToolTip"), TEXT("No additive."));
			MetaData->SetValue(ReturnEnum, TEXT("AAT_RotationOffsetMeshSpace.DisplayName"), TEXT("Mesh Space"));
			MetaData->SetValue(ReturnEnum, TEXT("AAT_RotationOffsetMeshSpace.ToolTip"), TEXT("Create Additive from MeshSpace Rotation Only, Translation still will be LocalSpace."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Indicates whether an animation is additive, and what kind."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAdditiveAnimationType_CRC() { return 3937618710U; }
	UEnum* Z_Construct_UEnum_Engine_ENotifyFilterType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ENotifyFilterType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ENotifyFilterType"), 0, Get_Z_Construct_UEnum_Engine_ENotifyFilterType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ENotifyFilterType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ENotifyFilterType::NoFiltering")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ENotifyFilterType::LOD")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ENotifyFilterType::ENotifyFilterType_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("LOD.ToolTip"), TEXT("Filter By Skeletal Mesh LOD."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("NoFiltering.ToolTip"), TEXT("No filtering."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Filtering method for deciding whether to trigger a notify."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ENotifyFilterType_CRC() { return 3844722101U; }
	UEnum* Z_Construct_UEnum_Engine_EMontageNotifyTickType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EMontageNotifyTickType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EMontageNotifyTickType"), 0, Get_Z_Construct_UEnum_Engine_EMontageNotifyTickType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EMontageNotifyTickType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMontageNotifyTickType::Queued")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMontageNotifyTickType::BranchingPoint")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EMontageNotifyTickType::EMontageNotifyTickType_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BranchingPoint.ToolTip"), TEXT("Trigger notifies as they are encountered (Slower). Suitable for changing sections or montage position."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Queued.ToolTip"), TEXT("Queue notifies, and trigger them at the end of the evaluation phase (faster). Not suitable for changing sections or montage position."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Ticking method for AnimNotifies in AnimMontages."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EMontageNotifyTickType_CRC() { return 4098719251U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimNotifyTrack()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimNotifyTrack_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimNotifyTrack"), sizeof(FAnimNotifyTrack), Get_Z_Construct_UScriptStruct_FAnimNotifyTrack_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimNotifyTrack"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimNotifyTrack>, EStructFlags(0x00000001));
			UProperty* NewProp_TrackColor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TrackColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TrackColor, FAnimNotifyTrack), 0x0000000000000000, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_TrackName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TrackName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(TrackName, FAnimNotifyTrack), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Keyframe position data for one track.  Pos(i) occurs at Time(i).  Pos.Num() always equals Time.Num()."));
			MetaData->SetValue(NewProp_TrackColor, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_TrackName, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimNotifyTrack_CRC() { return 3167379037U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimNotifyEvent()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimNotifyEvent_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimNotifyEvent"), sizeof(FAnimNotifyEvent), Get_Z_Construct_UScriptStruct_FAnimNotifyEvent_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimNotifyEvent"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FAnimLinkableElement(), new UScriptStruct::TCppStructOps<FAnimNotifyEvent>, EStructFlags(0x00000005));
			UProperty* NewProp_TrackIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TrackIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TrackIndex, FAnimNotifyEvent), 0x0000000000000000);
#if WITH_EDITORONLY_DATA
			UProperty* NewProp_NotifyColor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NotifyColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NotifyColor, FAnimNotifyEvent), 0x0000000800000000, Z_Construct_UScriptStruct_FColor());
#endif // WITH_EDITORONLY_DATA
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTriggerOnDedicatedServer, FAnimNotifyEvent, bool);
			UProperty* NewProp_bTriggerOnDedicatedServer = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bTriggerOnDedicatedServer"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTriggerOnDedicatedServer, FAnimNotifyEvent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bTriggerOnDedicatedServer, FAnimNotifyEvent), sizeof(bool), true);
			UProperty* NewProp_NotifyFilterLOD = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NotifyFilterLOD"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NotifyFilterLOD, FAnimNotifyEvent), 0x0000000000000005);
			UProperty* NewProp_NotifyFilterType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NotifyFilterType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NotifyFilterType, FAnimNotifyEvent), 0x0000000000000005, Z_Construct_UEnum_Engine_ENotifyFilterType());
			UProperty* NewProp_NotifyTriggerChance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NotifyTriggerChance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NotifyTriggerChance, FAnimNotifyEvent), 0x0000000000000005);
			UProperty* NewProp_MontageTickType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MontageTickType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(MontageTickType, FAnimNotifyEvent), 0x0000000000000005, Z_Construct_UEnum_Engine_EMontageNotifyTickType());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConvertedFromBranchingPoint, FAnimNotifyEvent, bool);
			UProperty* NewProp_bConvertedFromBranchingPoint = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bConvertedFromBranchingPoint"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConvertedFromBranchingPoint, FAnimNotifyEvent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bConvertedFromBranchingPoint, FAnimNotifyEvent), sizeof(bool), true);
			UProperty* NewProp_EndLink = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndLink"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndLink, FAnimNotifyEvent), 0x0000000000000000, Z_Construct_UScriptStruct_FAnimLinkableElement());
			UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Duration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Duration, FAnimNotifyEvent), 0x0000000000000000);
			UProperty* NewProp_NotifyStateClass = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NotifyStateClass"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NotifyStateClass, FAnimNotifyEvent), 0x000200000008000d, Z_Construct_UClass_UAnimNotifyState_NoRegister());
			UProperty* NewProp_Notify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Notify"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Notify, FAnimNotifyEvent), 0x000200000008000d, Z_Construct_UClass_UAnimNotify_NoRegister());
			UProperty* NewProp_NotifyName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NotifyName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(NotifyName, FAnimNotifyEvent), 0x0000000000000015);
			UProperty* NewProp_TriggerWeightThreshold = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TriggerWeightThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TriggerWeightThreshold, FAnimNotifyEvent), 0x0000000000000005);
			UProperty* NewProp_EndTriggerTimeOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndTriggerTimeOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(EndTriggerTimeOffset, FAnimNotifyEvent), 0x0000000000000000);
			UProperty* NewProp_TriggerTimeOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TriggerTimeOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TriggerTimeOffset, FAnimNotifyEvent), 0x0000000000000000);
			UProperty* NewProp_DisplayTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DisplayTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DisplayTime_DEPRECATED, FAnimNotifyEvent), 0x0000000020000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Triggers an animation notify.  Each AnimNotifyEvent contains an AnimNotify object\nwhich has its Notify method called and passed to the animation."));
			MetaData->SetValue(NewProp_TrackIndex, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_TrackIndex, TEXT("ToolTip"), TEXT("'Track' that the notify exists on, used for visual placement in editor and sorting priority in runtime"));
			MetaData->SetValue(NewProp_NotifyColor, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_NotifyColor, TEXT("ToolTip"), TEXT("Color of Notify in editor"));
			MetaData->SetValue(NewProp_bTriggerOnDedicatedServer, TEXT("Category"), TEXT("AnimNotifyTriggerSettings"));
			MetaData->SetValue(NewProp_bTriggerOnDedicatedServer, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_bTriggerOnDedicatedServer, TEXT("ToolTip"), TEXT("If disabled this notify will be skipped on dedicated servers"));
			MetaData->SetValue(NewProp_NotifyFilterLOD, TEXT("Category"), TEXT("AnimNotifyTriggerSettings"));
			MetaData->SetValue(NewProp_NotifyFilterLOD, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_NotifyFilterLOD, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_NotifyFilterLOD, TEXT("ToolTip"), TEXT("LOD to start filtering this notify from."));
			MetaData->SetValue(NewProp_NotifyFilterType, TEXT("Category"), TEXT("AnimNotifyTriggerSettings"));
			MetaData->SetValue(NewProp_NotifyFilterType, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_NotifyFilterType, TEXT("ToolTip"), TEXT("Defines a method for filtering notifies (stopping them triggering) e.g. by looking at the meshes current LOD"));
			MetaData->SetValue(NewProp_NotifyTriggerChance, TEXT("Category"), TEXT("AnimNotifyTriggerSettings"));
			MetaData->SetValue(NewProp_NotifyTriggerChance, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_NotifyTriggerChance, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_NotifyTriggerChance, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_NotifyTriggerChance, TEXT("ToolTip"), TEXT("Defines the chance of of this notify triggering, 0 = No Chance, 1 = Always triggers"));
			MetaData->SetValue(NewProp_MontageTickType, TEXT("Category"), TEXT("AnimNotifyEvent"));
			MetaData->SetValue(NewProp_MontageTickType, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_bConvertedFromBranchingPoint, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_bConvertedFromBranchingPoint, TEXT("ToolTip"), TEXT("If TRUE, this notify has been converted from an old BranchingPoint."));
			MetaData->SetValue(NewProp_EndLink, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_EndLink, TEXT("ToolTip"), TEXT("Linkable element to use for the end handle representing a notify state duration"));
			MetaData->SetValue(NewProp_Duration, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_NotifyStateClass, TEXT("Category"), TEXT("AnimNotifyEvent"));
			MetaData->SetValue(NewProp_NotifyStateClass, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_NotifyStateClass, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_Notify, TEXT("Category"), TEXT("AnimNotifyEvent"));
			MetaData->SetValue(NewProp_Notify, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_Notify, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_NotifyName, TEXT("Category"), TEXT("AnimNotifyEvent"));
			MetaData->SetValue(NewProp_NotifyName, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_TriggerWeightThreshold, TEXT("Category"), TEXT("AnimNotifyEvent"));
			MetaData->SetValue(NewProp_TriggerWeightThreshold, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_EndTriggerTimeOffset, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_EndTriggerTimeOffset, TEXT("ToolTip"), TEXT("An offset similar to TriggerTimeOffset but used for the end scrub handle of a notify state's duration"));
			MetaData->SetValue(NewProp_TriggerTimeOffset, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_TriggerTimeOffset, TEXT("ToolTip"), TEXT("An offset from the DisplayTime to the actual time we will trigger the notify, as we cannot always trigger it exactly at the time the user wants"));
			MetaData->SetValue(NewProp_DisplayTime, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimTypes.h"));
			MetaData->SetValue(NewProp_DisplayTime, TEXT("ToolTip"), TEXT("The user requested time for this notify"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimNotifyEvent_CRC() { return 3390295172U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRawCurveTracks()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FRawCurveTracks_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("RawCurveTracks"), sizeof(FRawCurveTracks), Get_Z_Construct_UScriptStruct_FRawCurveTracks_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RawCurveTracks"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRawCurveTracks>, EStructFlags(0x00000001));
#if WITH_EDITORONLY_DATA
			UProperty* NewProp_TransformCurves = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TransformCurves"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(TransformCurves, FRawCurveTracks), 0x0000000800000000);
			UProperty* NewProp_TransformCurves_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TransformCurves, TEXT("TransformCurves"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000, Z_Construct_UScriptStruct_FTransformCurve());
			UProperty* NewProp_VectorCurves = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VectorCurves"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(VectorCurves, FRawCurveTracks), 0x0000000800002000);
			UProperty* NewProp_VectorCurves_Inner = new(EC_InternalUseOnlyConstructor, NewProp_VectorCurves, TEXT("VectorCurves"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000, Z_Construct_UScriptStruct_FVectorCurve());
#endif // WITH_EDITORONLY_DATA
			UProperty* NewProp_FloatCurves = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatCurves"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(FloatCurves, FRawCurveTracks), 0x0000000000000000);
			UProperty* NewProp_FloatCurves_Inner = new(EC_InternalUseOnlyConstructor, NewProp_FloatCurves, TEXT("FloatCurves"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FFloatCurve());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Raw Curve data for serialization"));
			MetaData->SetValue(NewProp_TransformCurves, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_TransformCurves, TEXT("ToolTip"), TEXT("@note : TransformCurves are used to edit additive animation in editor."));
			MetaData->SetValue(NewProp_VectorCurves, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_VectorCurves, TEXT("ToolTip"), TEXT("@note : Currently VectorCurves are not evaluated or used for anything else but transient data for modifying bone track\n                     Note that it doesn't have UPROPERTY tag yet. In the future, we'd like this to be serialized, but not for now"));
			MetaData->SetValue(NewProp_FloatCurves, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRawCurveTracks_CRC() { return 3854284384U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTransformCurve()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTransformCurve_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TransformCurve"), sizeof(FTransformCurve), Get_Z_Construct_UScriptStruct_FTransformCurve_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TransformCurve"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FAnimCurveBase(), new UScriptStruct::TCppStructOps<FTransformCurve>, EStructFlags(0x00000001));
			UProperty* NewProp_ScaleCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ScaleCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ScaleCurve, FTransformCurve), 0x0000000000000000, Z_Construct_UScriptStruct_FVectorCurve());
			UProperty* NewProp_RotationCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RotationCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RotationCurve, FTransformCurve), 0x0000000000000000, Z_Construct_UScriptStruct_FVectorCurve());
			UProperty* NewProp_TranslationCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TranslationCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TranslationCurve, FTransformCurve), 0x0000000000000000, Z_Construct_UScriptStruct_FVectorCurve());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_ScaleCurve, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_RotationCurve, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_RotationCurve, TEXT("ToolTip"), TEXT("Rotation curve - right now we use euler because quat also doesn't provide linear interpolation - curve editor can't handle quat interpolation\nIf you hit gimbal lock, you should add extra key to fix it. This will cause gimbal lock.\n@TODO: Eventually we'll need FRotationCurve that would contain rotation curve - that will interpolate as slerp or as quaternion"));
			MetaData->SetValue(NewProp_TranslationCurve, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_TranslationCurve, TEXT("ToolTip"), TEXT("Curve data for each transform."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTransformCurve_CRC() { return 3345248445U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVectorCurve()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FVectorCurve_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("VectorCurve"), sizeof(FVectorCurve), Get_Z_Construct_UScriptStruct_FVectorCurve_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VectorCurve"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FAnimCurveBase(), new UScriptStruct::TCppStructOps<FVectorCurve>, EStructFlags(0x00000001));
			UProperty* NewProp_FloatCurves = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatCurves"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FloatCurves, FVectorCurve), 0x0000000000000000, Z_Construct_UScriptStruct_FRichCurve());
			NewProp_FloatCurves->ArrayDim = CPP_ARRAY_DIM(FloatCurves, FVectorCurve);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_FloatCurves, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_FloatCurves, TEXT("ToolTip"), TEXT("Curve data for float."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVectorCurve_CRC() { return 4271869574U; }
	UScriptStruct* Z_Construct_UScriptStruct_FFloatCurve()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FFloatCurve_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("FloatCurve"), sizeof(FFloatCurve), Get_Z_Construct_UScriptStruct_FFloatCurve_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FloatCurve"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FAnimCurveBase(), new UScriptStruct::TCppStructOps<FFloatCurve>, EStructFlags(0x00000001));
			UProperty* NewProp_FloatCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FloatCurve, FFloatCurve), 0x0000000000000000, Z_Construct_UScriptStruct_FRichCurve());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_FloatCurve, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_FloatCurve, TEXT("ToolTip"), TEXT("Curve data for float."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFloatCurve_CRC() { return 1891629078U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimCurveBase()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimCurveBase_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimCurveBase"), sizeof(FAnimCurveBase), Get_Z_Construct_UScriptStruct_FAnimCurveBase_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimCurveBase"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimCurveBase>, EStructFlags(0x00000001));
			UProperty* NewProp_CurveTypeFlags = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CurveTypeFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(CurveTypeFlags, FAnimCurveBase), 0x0000000000000000);
			UProperty* NewProp_LastObservedName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LastObservedName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(LastObservedName, FAnimCurveBase), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Float curve data for one track"));
			MetaData->SetValue(NewProp_CurveTypeFlags, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_CurveTypeFlags, TEXT("ToolTip"), TEXT("Curve Type Flags"));
			MetaData->SetValue(NewProp_LastObservedName, TEXT("ModuleRelativePath"), TEXT("Public/Animation/AnimCurveTypes.h"));
			MetaData->SetValue(NewProp_LastObservedName, TEXT("ToolTip"), TEXT("Last observed name of the curve. We store this so we can recover from situations that\nmean the skeleton doesn't have a mapped name for our UID (such as a user saving the an\nanimation but not the skeleton)."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimCurveBase_CRC() { return 762340583U; }
	UEnum* Z_Construct_UEnum_Engine_EAnimationMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAnimationMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAnimationMode"), 0, Get_Z_Construct_UEnum_Engine_EAnimationMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAnimationMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimationMode::AnimationBlueprint")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimationMode::AnimationSingleNode")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAnimationMode::EAnimationMode_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AnimationBlueprint.DisplayName"), TEXT("Use Animation Blueprint"));
			MetaData->SetValue(ReturnEnum, TEXT("AnimationSingleNode.DisplayName"), TEXT("Use Animation Asset"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAnimationMode_CRC() { return 3336089562U; }
	UEnum* Z_Construct_UEnum_Engine_EKinematicBonesUpdateToPhysics()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EKinematicBonesUpdateToPhysics_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EKinematicBonesUpdateToPhysics"), 0, Get_Z_Construct_UEnum_Engine_EKinematicBonesUpdateToPhysics_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EKinematicBonesUpdateToPhysics"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EKinematicBonesUpdateToPhysics::SkipSimulatingBones")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EKinematicBonesUpdateToPhysics::SkipAllBones")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EKinematicBonesUpdateToPhysics::EKinematicBonesUpdateToPhysics_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("SkipAllBones.ToolTip"), TEXT("Skip physics update from kinematic changes."));
			MetaData->SetValue(ReturnEnum, TEXT("SkipSimulatingBones.ToolTip"), TEXT("Update any bones that are not simulating."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("This enum defines how you'd like to update bones to physics world.\n      If bone is simulating, you don't have to waste time on updating bone transform from kinematic.\n      But also sometimes you don't like fixed bones to be updated by animation data."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EKinematicBonesUpdateToPhysics_CRC() { return 4242070203U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSkeletalMeshComponentPreClothTickFunction()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSkeletalMeshComponentPreClothTickFunction_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SkeletalMeshComponentPreClothTickFunction"), sizeof(FSkeletalMeshComponentPreClothTickFunction), Get_Z_Construct_UScriptStruct_FSkeletalMeshComponentPreClothTickFunction_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SkeletalMeshComponentPreClothTickFunction"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FTickFunction(), new UScriptStruct::TCppStructOps<FSkeletalMeshComponentPreClothTickFunction>, EStructFlags(0x00000001));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Tick function that prepares for cloth tick"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSkeletalMeshComponentPreClothTickFunction_CRC() { return 2141860291U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSingleAnimationPlayData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSingleAnimationPlayData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SingleAnimationPlayData"), sizeof(FSingleAnimationPlayData), Get_Z_Construct_UScriptStruct_FSingleAnimationPlayData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SingleAnimationPlayData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSingleAnimationPlayData>, EStructFlags(0x00000001));
			UProperty* NewProp_SavedPlayRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SavedPlayRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SavedPlayRate, FSingleAnimationPlayData), 0x0000040000000005);
			UProperty* NewProp_SavedPosition = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SavedPosition"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SavedPosition, FSingleAnimationPlayData), 0x0000000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSavedPlaying, FSingleAnimationPlayData, uint8);
			UProperty* NewProp_bSavedPlaying = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSavedPlaying"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSavedPlaying, FSingleAnimationPlayData), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bSavedPlaying, FSingleAnimationPlayData), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSavedLooping, FSingleAnimationPlayData, uint8);
			UProperty* NewProp_bSavedLooping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSavedLooping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSavedLooping, FSingleAnimationPlayData), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bSavedLooping, FSingleAnimationPlayData), sizeof(uint8), false);
			UProperty* NewProp_VertexAnimToPlay = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VertexAnimToPlay"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VertexAnimToPlay, FSingleAnimationPlayData), 0x0000000000000000, Z_Construct_UClass_UVertexAnimation_NoRegister());
			UProperty* NewProp_AnimToPlay = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimToPlay"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimToPlay, FSingleAnimationPlayData), 0x0000000000000005, Z_Construct_UClass_UAnimationAsset_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_SavedPlayRate, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(NewProp_SavedPlayRate, TEXT("DisplayName"), TEXT("PlayRate"));
			MetaData->SetValue(NewProp_SavedPlayRate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_SavedPlayRate, TEXT("ToolTip"), TEXT("Default setting for play rate of SequenceToPlay to play."));
			MetaData->SetValue(NewProp_SavedPosition, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(NewProp_SavedPosition, TEXT("DisplayName"), TEXT("Initial Position"));
			MetaData->SetValue(NewProp_SavedPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_SavedPosition, TEXT("ToolTip"), TEXT("Default setting for position of SequenceToPlay to play."));
			MetaData->SetValue(NewProp_bSavedPlaying, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(NewProp_bSavedPlaying, TEXT("DisplayName"), TEXT("Playing"));
			MetaData->SetValue(NewProp_bSavedPlaying, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_bSavedPlaying, TEXT("ToolTip"), TEXT("Default setting for playing for SequenceToPlay. This is not current state of playing."));
			MetaData->SetValue(NewProp_bSavedLooping, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(NewProp_bSavedLooping, TEXT("DisplayName"), TEXT("Looping"));
			MetaData->SetValue(NewProp_bSavedLooping, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_bSavedLooping, TEXT("ToolTip"), TEXT("Default setting for looping for SequenceToPlay. This is not current state of looping."));
			MetaData->SetValue(NewProp_VertexAnimToPlay, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_VertexAnimToPlay, TEXT("ToolTip"), TEXT("@fixme : until we properly support it I'm commenting out editable property part\nThe default sequence to play on this skeletal mesh\nEditAnywhere, BlueprintReadWrite, Category=Animation)"));
			MetaData->SetValue(NewProp_AnimToPlay, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(NewProp_AnimToPlay, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(NewProp_AnimToPlay, TEXT("ToolTip"), TEXT("@todo in the future, we should make this one UObject\nand have detail customization to display different things\nThe default sequence to play on this skeletal mesh"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSingleAnimationPlayData_CRC() { return 2911876602U; }
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight()
	{
		struct SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms
		{
			FName InBoneName;
			float AddPhysicsBlendWeight;
			bool bSkipCustomPhysicsType;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AccumulateAllBodiesBelowPhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipCustomPhysicsType, SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms, bool);
			UProperty* NewProp_bSkipCustomPhysicsType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSkipCustomPhysicsType"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipCustomPhysicsType, SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSkipCustomPhysicsType, SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms), sizeof(bool), true);
			UProperty* NewProp_AddPhysicsBlendWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AddPhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AddPhysicsBlendWeight, SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms), 0x0000000000000080);
			UProperty* NewProp_InBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InBoneName, SkeletalMeshComponent_eventAccumulateAllBodiesBelowPhysicsBlendWeight_Parms), 0x0000000008000182);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSkipCustomPhysicsType"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Accumulate AddPhysicsBlendWeight to physics blendweight for all of the bones below passed in bone to be simulated"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_BindClothToMasterPoseComponent()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BindClothToMasterPoseComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If this component has a valid MasterPoseComponent then this function makes cloth items on the slave component\ntake the transforms of the cloth items on the master component instead of simulating separately.\n@Note This will FORCE any cloth actor on the master component to simulate in local space. Also\nThe meshes used in the components must be identical for the cloth to bind correctly"));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ClearMorphTargets()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClearMorphTargets"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clear all Morph Target that are set to this mesh"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleport()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ForceClothNextUpdateTeleport"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Used to indicate we should force 'teleport' during the next call to UpdateClothState,\nThis will transform positions and velocities and thus keep the simulation state, just translate it to a new pose."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ForceClothNextUpdateTeleportAndReset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Used to indicate we should force 'teleport and reset' during the next call to UpdateClothState.\nThis can be used to reset it from a bad state or by a teleport where the old state is not important anymore."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetAnimationMode()
	{
		struct SkeletalMeshComponent_eventGetAnimationMode_Parms
		{
			TEnumAsByte<EAnimationMode::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAnimationMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkeletalMeshComponent_eventGetAnimationMode_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMeshComponent_eventGetAnimationMode_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_EAnimationMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetAnimInstance()
	{
		struct SkeletalMeshComponent_eventGetAnimInstance_Parms
		{
			UAnimInstance* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAnimInstance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkeletalMeshComponent_eventGetAnimInstance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMeshComponent_eventGetAnimInstance_Parms), 0x0000000000000580, Z_Construct_UClass_UAnimInstance_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("AnimBlueprint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the animation instance that is driving the class (if available). This is typically an instance of\nthe class set as AnimBlueprintGeneratedClass (generated by an animation blueprint)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetClothMaxDistanceScale()
	{
		struct SkeletalMeshComponent_eventGetClothMaxDistanceScale_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetClothMaxDistanceScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventGetClothMaxDistanceScale_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMeshComponent_eventGetClothMaxDistanceScale_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get/Set the max distance scale of clothing mesh vertices"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetMorphTarget()
	{
		struct SkeletalMeshComponent_eventGetMorphTarget_Parms
		{
			FName MorphTargetName;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMorphTarget"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkeletalMeshComponent_eventGetMorphTarget_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMeshComponent_eventGetMorphTarget_Parms), 0x0000000000000580);
			UProperty* NewProp_MorphTargetName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MorphTargetName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(MorphTargetName, SkeletalMeshComponent_eventGetMorphTarget_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get Morph target with given name"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetPlayRate()
	{
		struct SkeletalMeshComponent_eventGetPlayRate_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlayRate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkeletalMeshComponent_eventGetPlayRate_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMeshComponent_eventGetPlayRate_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_GetPosition()
	{
		struct SkeletalMeshComponent_eventGetPosition_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkeletalMeshComponent_eventGetPosition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SkeletalMeshComponent_eventGetPosition_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_IsPlaying()
	{
		struct SkeletalMeshComponent_eventIsPlaying_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsPlaying"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SkeletalMeshComponent_eventIsPlaying_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, SkeletalMeshComponent_eventIsPlaying_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, SkeletalMeshComponent_eventIsPlaying_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, SkeletalMeshComponent_eventIsPlaying_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_Play()
	{
		struct SkeletalMeshComponent_eventPlay_Parms
		{
			bool bLooping;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Play"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventPlay_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLooping, SkeletalMeshComponent_eventPlay_Parms, bool);
			UProperty* NewProp_bLooping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bLooping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLooping, SkeletalMeshComponent_eventPlay_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bLooping, SkeletalMeshComponent_eventPlay_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_PlayAnimation()
	{
		struct SkeletalMeshComponent_eventPlayAnimation_Parms
		{
			UAnimationAsset* NewAnimToPlay;
			bool bLooping;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayAnimation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventPlayAnimation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLooping, SkeletalMeshComponent_eventPlayAnimation_Parms, bool);
			UProperty* NewProp_bLooping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bLooping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLooping, SkeletalMeshComponent_eventPlayAnimation_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bLooping, SkeletalMeshComponent_eventPlayAnimation_Parms), sizeof(bool), true);
			UProperty* NewProp_NewAnimToPlay = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAnimToPlay"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewAnimToPlay, SkeletalMeshComponent_eventPlayAnimation_Parms), 0x0000000000000080, Z_Construct_UClass_UAnimationAsset_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ResetAllBodiesSimulatePhysics()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ResetAllBodiesSimulatePhysics"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Allows you to reset bodies Simulate state based on where bUsePhysics is set to true in the BodySetup."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_ResetClothTeleportMode()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ResetClothTeleportMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Reset the teleport mode of a next update to 'Continuous'"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight()
	{
		struct SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms
		{
			FName InBoneName;
			float PhysicsBlendWeight;
			bool bSkipCustomPhysicsType;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllBodiesBelowPhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms, bool);
			UProperty* NewProp_bSkipCustomPhysicsType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSkipCustomPhysicsType"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms), sizeof(bool), true);
			UProperty* NewProp_PhysicsBlendWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PhysicsBlendWeight, SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms), 0x0000000000000080);
			UProperty* NewProp_InBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InBoneName, SkeletalMeshComponent_eventSetAllBodiesBelowPhysicsBlendWeight_Parms), 0x0000000008000182);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSkipCustomPhysicsType"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set all of the bones below passed in bone to be simulated"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics()
	{
		struct SkeletalMeshComponent_eventSetAllBodiesBelowSimulatePhysics_Parms
		{
			FName InBoneName;
			bool bNewSimulate;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllBodiesBelowSimulatePhysics"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(SkeletalMeshComponent_eventSetAllBodiesBelowSimulatePhysics_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewSimulate, SkeletalMeshComponent_eventSetAllBodiesBelowSimulatePhysics_Parms, bool);
			UProperty* NewProp_bNewSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewSimulate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewSimulate, SkeletalMeshComponent_eventSetAllBodiesBelowSimulatePhysics_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewSimulate, SkeletalMeshComponent_eventSetAllBodiesBelowSimulatePhysics_Parms), sizeof(bool), true);
			UProperty* NewProp_InBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InBoneName, SkeletalMeshComponent_eventSetAllBodiesBelowSimulatePhysics_Parms), 0x0000000008000182);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set all of the bones below passed in bone to be simulated"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight()
	{
		struct SkeletalMeshComponent_eventSetAllBodiesPhysicsBlendWeight_Parms
		{
			float PhysicsBlendWeight;
			bool bSkipCustomPhysicsType;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllBodiesPhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAllBodiesPhysicsBlendWeight_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllBodiesPhysicsBlendWeight_Parms, bool);
			UProperty* NewProp_bSkipCustomPhysicsType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSkipCustomPhysicsType"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllBodiesPhysicsBlendWeight_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllBodiesPhysicsBlendWeight_Parms), sizeof(bool), true);
			UProperty* NewProp_PhysicsBlendWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PhysicsBlendWeight, SkeletalMeshComponent_eventSetAllBodiesPhysicsBlendWeight_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSkipCustomPhysicsType"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesSimulatePhysics()
	{
		struct SkeletalMeshComponent_eventSetAllBodiesSimulatePhysics_Parms
		{
			bool bNewSimulate;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllBodiesSimulatePhysics"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAllBodiesSimulatePhysics_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewSimulate, SkeletalMeshComponent_eventSetAllBodiesSimulatePhysics_Parms, bool);
			UProperty* NewProp_bNewSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewSimulate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewSimulate, SkeletalMeshComponent_eventSetAllBodiesSimulatePhysics_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewSimulate, SkeletalMeshComponent_eventSetAllBodiesSimulatePhysics_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set bSimulatePhysics to true for all bone bodies. Does not change the component bSimulatePhysics flag."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularDriveParams()
	{
		struct SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms
		{
			float InSpring;
			float InDamping;
			float InForceLimit;
			bool bSkipCustomPhysicsType;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllMotorsAngularDriveParams"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms, bool);
			UProperty* NewProp_bSkipCustomPhysicsType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSkipCustomPhysicsType"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms), sizeof(bool), true);
			UProperty* NewProp_InForceLimit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InForceLimit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InForceLimit, SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms), 0x0000000000000080);
			UProperty* NewProp_InDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InDamping, SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms), 0x0000000000000080);
			UProperty* NewProp_InSpring = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSpring"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InSpring, SkeletalMeshComponent_eventSetAllMotorsAngularDriveParams_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSkipCustomPhysicsType"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set Angular Drive motors params for all constraint instances"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularPositionDrive()
	{
		struct SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms
		{
			bool bEnableSwingDrive;
			bool bEnableTwistDrive;
			bool bSkipCustomPhysicsType;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllMotorsAngularPositionDrive"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms, bool);
			UProperty* NewProp_bSkipCustomPhysicsType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSkipCustomPhysicsType"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableTwistDrive, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms, bool);
			UProperty* NewProp_bEnableTwistDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableTwistDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableTwistDrive, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableTwistDrive, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableSwingDrive, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms, bool);
			UProperty* NewProp_bEnableSwingDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableSwingDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableSwingDrive, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableSwingDrive, SkeletalMeshComponent_eventSetAllMotorsAngularPositionDrive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSkipCustomPhysicsType"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enable or Disable AngularPositionDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive()
	{
		struct SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms
		{
			bool bEnableSwingDrive;
			bool bEnableTwistDrive;
			bool bSkipCustomPhysicsType;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAllMotorsAngularVelocityDrive"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms, bool);
			UProperty* NewProp_bSkipCustomPhysicsType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSkipCustomPhysicsType"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSkipCustomPhysicsType, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableTwistDrive, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableTwistDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableTwistDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableTwistDrive, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableTwistDrive, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableSwingDrive, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms, bool);
			UProperty* NewProp_bEnableSwingDrive = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnableSwingDrive"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableSwingDrive, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnableSwingDrive, SkeletalMeshComponent_eventSetAllMotorsAngularVelocityDrive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSkipCustomPhysicsType"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enable or Disable AngularVelocityDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAnimation()
	{
		struct SkeletalMeshComponent_eventSetAnimation_Parms
		{
			UAnimationAsset* NewAnimToPlay;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAnimation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAnimation_Parms));
			UProperty* NewProp_NewAnimToPlay = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAnimToPlay"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewAnimToPlay, SkeletalMeshComponent_eventSetAnimation_Parms), 0x0000000000000080, Z_Construct_UClass_UAnimationAsset_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAnimationMode()
	{
		struct SkeletalMeshComponent_eventSetAnimationMode_Parms
		{
			TEnumAsByte<EAnimationMode::Type> InAnimationMode;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAnimationMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAnimationMode_Parms));
			UProperty* NewProp_InAnimationMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAnimationMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(InAnimationMode, SkeletalMeshComponent_eventSetAnimationMode_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EAnimationMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Below are the interface to control animation when animation mode, not blueprint mode *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetAnimInstanceClass()
	{
		struct SkeletalMeshComponent_eventSetAnimInstanceClass_Parms
		{
			UClass* NewClass;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAnimInstanceClass"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetAnimInstanceClass_Parms));
			UProperty* NewProp_NewClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(NewClass, SkeletalMeshComponent_eventSetAnimInstanceClass_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("AnimBlueprint"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetClothMaxDistanceScale()
	{
		struct SkeletalMeshComponent_eventSetClothMaxDistanceScale_Parms
		{
			float Scale;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetClothMaxDistanceScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetClothMaxDistanceScale_Parms));
			UProperty* NewProp_Scale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Scale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scale, SkeletalMeshComponent_eventSetClothMaxDistanceScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetEnablePhysicsBlending()
	{
		struct SkeletalMeshComponent_eventSetEnablePhysicsBlending_Parms
		{
			bool bNewBlendPhysics;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnablePhysicsBlending"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetEnablePhysicsBlending_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewBlendPhysics, SkeletalMeshComponent_eventSetEnablePhysicsBlending_Parms, bool);
			UProperty* NewProp_bNewBlendPhysics = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewBlendPhysics"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewBlendPhysics, SkeletalMeshComponent_eventSetEnablePhysicsBlending_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewBlendPhysics, SkeletalMeshComponent_eventSetEnablePhysicsBlending_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Disable physics blending of bones *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetMorphTarget()
	{
		struct SkeletalMeshComponent_eventSetMorphTarget_Parms
		{
			FName MorphTargetName;
			float Value;
			bool bRemoveZeroWeight;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMorphTarget"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetMorphTarget_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRemoveZeroWeight, SkeletalMeshComponent_eventSetMorphTarget_Parms, bool);
			UProperty* NewProp_bRemoveZeroWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bRemoveZeroWeight"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRemoveZeroWeight, SkeletalMeshComponent_eventSetMorphTarget_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bRemoveZeroWeight, SkeletalMeshComponent_eventSetMorphTarget_Parms), sizeof(bool), true);
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, SkeletalMeshComponent_eventSetMorphTarget_Parms), 0x0000000000000080);
			UProperty* NewProp_MorphTargetName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MorphTargetName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(MorphTargetName, SkeletalMeshComponent_eventSetMorphTarget_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bRemoveZeroWeight"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set Morph Target with Name and Value(0-1)\n\n@param bRemoveZeroWeight : Used by editor code when it should stay in the active list with zero weight"));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetPhysicsBlendWeight()
	{
		struct SkeletalMeshComponent_eventSetPhysicsBlendWeight_Parms
		{
			float PhysicsBlendWeight;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetPhysicsBlendWeight_Parms));
			UProperty* NewProp_PhysicsBlendWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PhysicsBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PhysicsBlendWeight, SkeletalMeshComponent_eventSetPhysicsBlendWeight_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("This is global set up for setting physics blend weight\nThis does multiple things automatically\nIf PhysicsBlendWeight == 1.f, it will enable Simulation, and if PhysicsBlendWeight == 0.f, it will disable Simulation.\nAlso it will respect each body's setup, so if the body is fixed, it won't simulate. Vice versa\nSo if you'd like all bodies to change manually, do not use this function, but SetAllBodiesPhysicsBlendWeight"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetPlayRate()
	{
		struct SkeletalMeshComponent_eventSetPlayRate_Parms
		{
			float Rate;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlayRate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetPlayRate_Parms));
			UProperty* NewProp_Rate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Rate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Rate, SkeletalMeshComponent_eventSetPlayRate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_SetPosition()
	{
		struct SkeletalMeshComponent_eventSetPosition_Parms
		{
			float InPos;
			bool bFireNotifies;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventSetPosition_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFireNotifies, SkeletalMeshComponent_eventSetPosition_Parms, bool);
			UProperty* NewProp_bFireNotifies = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFireNotifies"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFireNotifies, SkeletalMeshComponent_eventSetPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFireNotifies, SkeletalMeshComponent_eventSetPosition_Parms), sizeof(bool), true);
			UProperty* NewProp_InPos = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPos"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InPos, SkeletalMeshComponent_eventSetPosition_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bFireNotifies"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_Stop()
	{
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Stop"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkeletalMeshComponent_UnbindClothFromMasterPoseComponent()
	{
		struct SkeletalMeshComponent_eventUnbindClothFromMasterPoseComponent_Parms
		{
			bool bRestoreSimulationSpace;
		};
		UObject* Outer=Z_Construct_UClass_USkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UnbindClothFromMasterPoseComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkeletalMeshComponent_eventUnbindClothFromMasterPoseComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRestoreSimulationSpace, SkeletalMeshComponent_eventUnbindClothFromMasterPoseComponent_Parms, bool);
			UProperty* NewProp_bRestoreSimulationSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bRestoreSimulationSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRestoreSimulationSpace, SkeletalMeshComponent_eventUnbindClothFromMasterPoseComponent_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bRestoreSimulationSpace, SkeletalMeshComponent_eventUnbindClothFromMasterPoseComponent_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|SkeletalMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bRestoreSimulationSpace"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If this component has a valid MasterPoseComponent and has previously had its cloth bound to the\nMCP, this function will unbind the cloth and resume simulation.\n@param bRestoreSimulationSpace if true and the master pose cloth was originally simulating in world\nspace, we will restore this setting. This will cause the master component to reset which may be\nundesirable."));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkeletalMeshComponent_NoRegister()
	{
		return USkeletalMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USkeletalMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USkinnedMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USkeletalMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_BindClothToMasterPoseComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_ClearMorphTargets());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleport());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_GetAnimationMode());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_GetAnimInstance());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_GetClothMaxDistanceScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_GetMorphTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_GetPlayRate());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_GetPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_IsPlaying());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_Play());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_PlayAnimation());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_ResetAllBodiesSimulatePhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_ResetClothTeleportMode());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesSimulatePhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularDriveParams());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularPositionDrive());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAnimation());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAnimationMode());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetAnimInstanceClass());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetClothMaxDistanceScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetEnablePhysicsBlending());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetMorphTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetPhysicsBlendWeight());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetPlayRate());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_SetPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_Stop());
				OuterClass->LinkChild(Z_Construct_UFunction_USkeletalMeshComponent_UnbindClothFromMasterPoseComponent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LastPoseTickTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastPoseTickTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastPoseTickTime, USkeletalMeshComponent), 0x0000000000002000);
				UProperty* NewProp_DefaultPlayRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultPlayRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DefaultPlayRate_DEPRECATED, USkeletalMeshComponent), 0x0000000020000000);
				UProperty* NewProp_DefaultPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultPosition"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DefaultPosition_DEPRECATED, USkeletalMeshComponent), 0x0000000020000000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDefaultPlaying_DEPRECATED, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bDefaultPlaying = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDefaultPlaying"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDefaultPlaying_DEPRECATED, USkeletalMeshComponent), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bDefaultPlaying_DEPRECATED, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDefaultLooping_DEPRECATED, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bDefaultLooping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDefaultLooping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDefaultLooping_DEPRECATED, USkeletalMeshComponent), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bDefaultLooping_DEPRECATED, USkeletalMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_AnimToPlay = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimToPlay"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimToPlay_DEPRECATED, USkeletalMeshComponent), 0x0000000020000000, Z_Construct_UClass_UAnimationAsset_NoRegister());
				UProperty* NewProp_SequenceToPlay = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SequenceToPlay"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SequenceToPlay_DEPRECATED, USkeletalMeshComponent), 0x0000000020000000, Z_Construct_UClass_UAnimSequence_NoRegister());
				UProperty* NewProp_OnConstraintBroken = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnConstraintBroken"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnConstraintBroken, USkeletalMeshComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ConstraintBrokenSignature__DelegateSignature());
				UProperty* NewProp_RagdollAggregateThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RagdollAggregateThreshold"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(RagdollAggregateThreshold, USkeletalMeshComponent), 0x0000000000000000);
				UProperty* NewProp_LineCheckBoundsScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LineCheckBoundsScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LineCheckBoundsScale, USkeletalMeshComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableLineCheckWithBounds, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bEnableLineCheckWithBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableLineCheckWithBounds"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableLineCheckWithBounds, USkeletalMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bEnableLineCheckWithBounds, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAnimTreeInitialised, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bAnimTreeInitialised = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAnimTreeInitialised"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAnimTreeInitialised, USkeletalMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bAnimTreeInitialised, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRequiredBonesUpToDate, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bRequiredBonesUpToDate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRequiredBonesUpToDate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRequiredBonesUpToDate, USkeletalMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bRequiredBonesUpToDate, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowPrePhysBones, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bShowPrePhysBones = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowPrePhysBones"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowPrePhysBones, USkeletalMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bShowPrePhysBones, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOldForceRefPose, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bOldForceRefPose = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOldForceRefPose"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOldForceRefPose, USkeletalMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOldForceRefPose, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceRefpose, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bForceRefpose = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceRefpose"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceRefpose, USkeletalMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bForceRefpose, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutonomousTickPose, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bAutonomousTickPose = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutonomousTickPose"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutonomousTickPose, USkeletalMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bAutonomousTickPose, USkeletalMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_BodySetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BodySetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(BodySetup, USkeletalMeshComponent), 0x0000000000002000, Z_Construct_UClass_UBodySetup_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnablePerPolyCollision, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bEnablePerPolyCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnablePerPolyCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnablePerPolyCollision, USkeletalMeshComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bEnablePerPolyCollision, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPauseAnims, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bPauseAnims = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPauseAnims"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPauseAnims, USkeletalMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bPauseAnims, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNoSkeletonUpdate, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bNoSkeletonUpdate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNoSkeletonUpdate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNoSkeletonUpdate, USkeletalMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bNoSkeletonUpdate, USkeletalMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_RootBoneTranslation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RootBoneTranslation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RootBoneTranslation, USkeletalMeshComponent), 0x0000000000002000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_ClothBlendWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClothBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ClothBlendWeight, USkeletalMeshComponent), 0x0000000000000005);
				UProperty* NewProp_TeleportRotationThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TeleportRotationThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TeleportRotationThreshold, USkeletalMeshComponent), 0x0000000000000005);
				UProperty* NewProp_TeleportDistanceThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TeleportDistanceThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TeleportDistanceThreshold, USkeletalMeshComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bResetAfterTeleport, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bResetAfterTeleport = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bResetAfterTeleport"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bResetAfterTeleport, USkeletalMeshComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bResetAfterTeleport, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClothMorphTarget, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bClothMorphTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bClothMorphTarget"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClothMorphTarget, USkeletalMeshComponent), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bClothMorphTarget, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLocalSpaceSimulation, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bLocalSpaceSimulation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLocalSpaceSimulation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLocalSpaceSimulation, USkeletalMeshComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bLocalSpaceSimulation, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCollideWithAttachedChildren, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bCollideWithAttachedChildren = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCollideWithAttachedChildren"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCollideWithAttachedChildren, USkeletalMeshComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bCollideWithAttachedChildren, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCollideWithEnvironment, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bCollideWithEnvironment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCollideWithEnvironment"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCollideWithEnvironment, USkeletalMeshComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bCollideWithEnvironment, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableClothSimulation, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bDisableClothSimulation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableClothSimulation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableClothSimulation, USkeletalMeshComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bDisableClothSimulation, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateJointsFromAnimation, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bUpdateJointsFromAnimation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUpdateJointsFromAnimation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateJointsFromAnimation, USkeletalMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bUpdateJointsFromAnimation, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnablePhysicsOnDedicatedServer, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bEnablePhysicsOnDedicatedServer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnablePhysicsOnDedicatedServer"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnablePhysicsOnDedicatedServer, USkeletalMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bEnablePhysicsOnDedicatedServer, USkeletalMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bBlendPhysics, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bBlendPhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bBlendPhysics"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bBlendPhysics, USkeletalMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bBlendPhysics, USkeletalMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_KinematicBonesUpdateType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("KinematicBonesUpdateType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(KinematicBonesUpdateType, USkeletalMeshComponent), 0x0000040000000005, Z_Construct_UEnum_Engine_EKinematicBonesUpdateToPhysics());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValidBodies, USkeletalMeshComponent, uint8);
				UProperty* NewProp_bHasValidBodies = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasValidBodies"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValidBodies, USkeletalMeshComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bHasValidBodies, USkeletalMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_GlobalAnimRateScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GlobalAnimRateScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GlobalAnimRateScale, USkeletalMeshComponent), 0x0000040000000005);
				UProperty* NewProp_CachedSpaceBases = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedSpaceBases"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(CachedSpaceBases, USkeletalMeshComponent), 0x0000000000002000);
				UProperty* NewProp_CachedSpaceBases_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CachedSpaceBases, TEXT("CachedSpaceBases"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FTransform());
				UProperty* NewProp_CachedLocalAtoms = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedLocalAtoms"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(CachedLocalAtoms, USkeletalMeshComponent), 0x0000000000002000);
				UProperty* NewProp_CachedLocalAtoms_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CachedLocalAtoms, TEXT("CachedLocalAtoms"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FTransform());
				UProperty* NewProp_AnimationData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimationData"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AnimationData, USkeletalMeshComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FSingleAnimationPlayData());
				UProperty* NewProp_AnimScriptInstance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimScriptInstance"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimScriptInstance, USkeletalMeshComponent), 0x0000000000002000, Z_Construct_UClass_UAnimInstance_NoRegister());
				UProperty* NewProp_AnimBlueprintGeneratedClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimBlueprintGeneratedClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(AnimBlueprintGeneratedClass, USkeletalMeshComponent), 0x0000000000000015, Z_Construct_UClass_UObject_NoRegister());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_AnimationBlueprint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimationBlueprint"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimationBlueprint_DEPRECATED, USkeletalMeshComponent), 0x0000000820000000, Z_Construct_UClass_UAnimBlueprint_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_AnimationMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimationMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(AnimationMode, USkeletalMeshComponent), 0x0000080000000015, Z_Construct_UEnum_Engine_EAnimationMode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight()); // 4147673200
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_BindClothToMasterPoseComponent()); // 2729612551
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_ClearMorphTargets()); // 4058762166
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleport()); // 2483336531
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset()); // 4087952732
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_GetAnimationMode()); // 34785238
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_GetAnimInstance()); // 1470488849
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_GetClothMaxDistanceScale()); // 1324487107
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_GetMorphTarget()); // 980819550
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_GetPlayRate()); // 2669912817
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_GetPosition()); // 358089352
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_IsPlaying()); // 2889735729
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_Play()); // 981950478
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_PlayAnimation()); // 3672235940
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_ResetAllBodiesSimulatePhysics()); // 3967099474
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_ResetClothTeleportMode()); // 3817622429
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight()); // 1026762658
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics()); // 2963890254
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight()); // 3845953485
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllBodiesSimulatePhysics()); // 3373239997
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularDriveParams()); // 2720351126
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularPositionDrive()); // 1132349113
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive()); // 1648817369
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAnimation()); // 4220160857
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAnimationMode()); // 3329915768
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetAnimInstanceClass()); // 2001917033
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetClothMaxDistanceScale()); // 3809843397
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetEnablePhysicsBlending()); // 1256139918
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetMorphTarget()); // 2493678771
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetPhysicsBlendWeight()); // 1917983345
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetPlayRate()); // 3700108575
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_SetPosition()); // 3814921988
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_Stop()); // 196527512
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkeletalMeshComponent_UnbindClothFromMasterPoseComponent()); // 3708005438
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UInterface_CollisionDataProvider_NoRegister(), VTABLE_OFFSET(USkeletalMeshComponent, IInterface_CollisionDataProvider), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering Common"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("SkeletalMeshComponent is used to create an instance of an animated SkeletalMesh asset.\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/\n@see USkeletalMesh"));
				MetaData->SetValue(NewProp_LastPoseTickTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_LastPoseTickTime, TEXT("ToolTip"), TEXT("Keep track of when animation has been ticked to ensure it is ticked only once per frame."));
				MetaData->SetValue(NewProp_DefaultPlayRate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_DefaultPlayRate, TEXT("ToolTip"), TEXT("Default setting for playrate of SequenceToPlay to play."));
				MetaData->SetValue(NewProp_DefaultPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_DefaultPosition, TEXT("ToolTip"), TEXT("Default setting for position of SequenceToPlay to play."));
				MetaData->SetValue(NewProp_bDefaultPlaying, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bDefaultPlaying, TEXT("ToolTip"), TEXT("Default setting for playing for SequenceToPlay. This is not current state of playing."));
				MetaData->SetValue(NewProp_bDefaultLooping, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bDefaultLooping, TEXT("ToolTip"), TEXT("Default setting for looping for SequenceToPlay. This is not current state of looping."));
				MetaData->SetValue(NewProp_AnimToPlay, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_AnimToPlay, TEXT("ToolTip"), TEXT("The default sequence to play on this skeletal mesh"));
				MetaData->SetValue(NewProp_SequenceToPlay, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_SequenceToPlay, TEXT("ToolTip"), TEXT("these are deprecated variables from removing SingleAnimSkeletalComponent\nremove if this version goes away : VER_UE4_REMOVE_SINGLENODEINSTANCE\ndeprecated variable to be re-save"));
				MetaData->SetValue(NewProp_OnConstraintBroken, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_OnConstraintBroken, TEXT("ToolTip"), TEXT("Notification when constraint is broken."));
				MetaData->SetValue(NewProp_RagdollAggregateThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_RagdollAggregateThreshold, TEXT("ToolTip"), TEXT("Threshold for physics asset bodies above which we use an aggregate for broadphase collisions"));
				MetaData->SetValue(NewProp_LineCheckBoundsScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_LineCheckBoundsScale, TEXT("ToolTip"), TEXT("If bEnableLineCheckWithBounds is true, scale the bounds by this value before doing line check."));
				MetaData->SetValue(NewProp_bEnableLineCheckWithBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bEnableLineCheckWithBounds, TEXT("ToolTip"), TEXT("If true, line checks will test against the bounding box of this skeletal mesh component and return a hit if there is a collision."));
				MetaData->SetValue(NewProp_bAnimTreeInitialised, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bAnimTreeInitialised, TEXT("ToolTip"), TEXT("If true, AnimTree has been initialised."));
				MetaData->SetValue(NewProp_bRequiredBonesUpToDate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bRequiredBonesUpToDate, TEXT("ToolTip"), TEXT("If false, indicates that on the next call to UpdateSkelPose the RequiredBones array should be recalculated."));
				MetaData->SetValue(NewProp_bShowPrePhysBones, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bShowPrePhysBones, TEXT("ToolTip"), TEXT("Bool that enables debug drawing of the skeleton before it is passed to the physics. Useful for debugging animation-driven physics."));
				MetaData->SetValue(NewProp_bOldForceRefPose, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bOldForceRefPose, TEXT("ToolTip"), TEXT("If bForceRefPose was set last tick."));
				MetaData->SetValue(NewProp_bForceRefpose, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bForceRefpose, TEXT("ToolTip"), TEXT("If true, force the mesh into the reference pose - is an optimization."));
				MetaData->SetValue(NewProp_bAutonomousTickPose, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bAutonomousTickPose, TEXT("ToolTip"), TEXT("If true TickPose() will not be called from the Component's TickComponent function.\nIt will instead be called from Autonomous networking updates. See ACharacter."));
				MetaData->SetValue(NewProp_BodySetup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_BodySetup, TEXT("ToolTip"), TEXT("Used for per poly collision. In 99% of cases you will be better off using a Physics Asset.\nThis BodySetup is per instance because all modification of vertices is done in place"));
				MetaData->SetValue(NewProp_bEnablePerPolyCollision, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bEnablePerPolyCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bEnablePerPolyCollision, TEXT("ToolTip"), TEXT("Uses skinned data for collision data."));
				MetaData->SetValue(NewProp_bPauseAnims, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_bPauseAnims, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bPauseAnims, TEXT("ToolTip"), TEXT("pauses this component's animations (doesn't tick them, but still refreshes bones)"));
				MetaData->SetValue(NewProp_bNoSkeletonUpdate, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bNoSkeletonUpdate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bNoSkeletonUpdate, TEXT("ToolTip"), TEXT("Skips Ticking and Bone Refresh."));
				MetaData->SetValue(NewProp_RootBoneTranslation, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_RootBoneTranslation, TEXT("ToolTip"), TEXT("Offset of the root bone from the reference pose. Used to offset bounding box."));
				MetaData->SetValue(NewProp_ClothBlendWeight, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_ClothBlendWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_ClothBlendWeight, TEXT("ToolTip"), TEXT("weight to blend between simulated results and key-framed positions\nif weight is 1.0, shows only cloth simulation results and 0.0 will show only skinned results"));
				MetaData->SetValue(NewProp_TeleportRotationThreshold, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_TeleportRotationThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_TeleportRotationThreshold, TEXT("ToolTip"), TEXT("rotation threshold in degree, ranging from 0 to 180\nconduct teleportation if the character's rotation is greater than this threshold in 1 frame.\nZero or negative values will skip the check"));
				MetaData->SetValue(NewProp_TeleportDistanceThreshold, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_TeleportDistanceThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_TeleportDistanceThreshold, TEXT("ToolTip"), TEXT("conduct teleportation if the character's movement is greater than this threshold in 1 frame.\nZero or negative values will skip the check\nyou can also do force teleport manually using ForceNextUpdateTeleport() / ForceNextUpdateTeleportAndReset()"));
				MetaData->SetValue(NewProp_bResetAfterTeleport, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_bResetAfterTeleport, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bResetAfterTeleport, TEXT("ToolTip"), TEXT("reset the clothing after moving the clothing position (called teleport)"));
				MetaData->SetValue(NewProp_bClothMorphTarget, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_bClothMorphTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bClothMorphTarget, TEXT("ToolTip"), TEXT("cloth morph target option\nThis option will be applied only before playing because should do pre-calculation to reduce computation time for run-time play\nso it's impossible to change this option in run-time"));
				MetaData->SetValue(NewProp_bLocalSpaceSimulation, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_bLocalSpaceSimulation, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bLocalSpaceSimulation, TEXT("ToolTip"), TEXT("It's worth trying this option when you feel that the current cloth simulation is unstable.\nThe scale of the actor is maintained during the simulation.\nIt is possible to add the inertia effects to the simulation, through the inertiaScale parameter of the clothing material.\nSo with an inertiaScale of 1.0 there should be no visible difference between local space and global space simulation.\nKnown issues: - Currently there's simulation issues when this feature is used in 3.x (DE4076) So if localSpaceSim is enabled there's no inertia effect when the global pose of the clothing actor changes."));
				MetaData->SetValue(NewProp_bCollideWithAttachedChildren, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_bCollideWithAttachedChildren, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bCollideWithAttachedChildren, TEXT("ToolTip"), TEXT("can't collide with part of attached children if total collision volumes exceed 16 capsules or 32 planes per convex"));
				MetaData->SetValue(NewProp_bCollideWithEnvironment, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_bCollideWithEnvironment, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bCollideWithEnvironment, TEXT("ToolTip"), TEXT("can't collide with part of environment if total collision volumes exceed 16 capsules or 32 planes per convex"));
				MetaData->SetValue(NewProp_bDisableClothSimulation, TEXT("Category"), TEXT("Clothing"));
				MetaData->SetValue(NewProp_bDisableClothSimulation, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bDisableClothSimulation, TEXT("ToolTip"), TEXT("Disable cloth simulation and play original animation without simulation"));
				MetaData->SetValue(NewProp_bUpdateJointsFromAnimation, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bUpdateJointsFromAnimation, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bUpdateJointsFromAnimation, TEXT("ToolTip"), TEXT("If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the\nragdoll based on the animation."));
				MetaData->SetValue(NewProp_bEnablePhysicsOnDedicatedServer, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_bEnablePhysicsOnDedicatedServer, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bEnablePhysicsOnDedicatedServer, TEXT("ToolTip"), TEXT("If true, simulate physics for this component on a dedicated server.\nThis should be set if simulating physics and replicating with a dedicated server."));
				MetaData->SetValue(NewProp_bBlendPhysics, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bBlendPhysics, TEXT("ToolTip"), TEXT("Enables blending in of physics bodies whether Simulate or not"));
				MetaData->SetValue(NewProp_KinematicBonesUpdateType, TEXT("Category"), TEXT("SkeletalMesh"));
				MetaData->SetValue(NewProp_KinematicBonesUpdateType, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_KinematicBonesUpdateType, TEXT("ToolTip"), TEXT("If we are running physics, should we update non-simulated bones based on the animation bone positions."));
				MetaData->SetValue(NewProp_bHasValidBodies, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_bHasValidBodies, TEXT("ToolTip"), TEXT("If true, there is at least one body in the current PhysicsAsset with a valid bone in the current SkeletalMesh"));
				MetaData->SetValue(NewProp_GlobalAnimRateScale, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_GlobalAnimRateScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_GlobalAnimRateScale, TEXT("ToolTip"), TEXT("Used to scale speed of all animations on this skeletal mesh."));
				MetaData->SetValue(NewProp_CachedSpaceBases, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_CachedSpaceBases, TEXT("ToolTip"), TEXT("Cached SpaceBases for Update Rate optimization."));
				MetaData->SetValue(NewProp_CachedLocalAtoms, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_CachedLocalAtoms, TEXT("ToolTip"), TEXT("Cached LocalAtoms for Update Rate optimization."));
				MetaData->SetValue(NewProp_AnimationData, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_AnimationData, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_AnimationData, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_AnimScriptInstance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_AnimScriptInstance, TEXT("ToolTip"), TEXT("The active animation graph program instance."));
				MetaData->SetValue(NewProp_AnimBlueprintGeneratedClass, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_AnimBlueprintGeneratedClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_AnimBlueprintGeneratedClass, TEXT("ToolTip"), TEXT("The AnimBlueprint class to use. Use 'SetAnimInstanceClass' to change at runtime."));
				MetaData->SetValue(NewProp_AnimationBlueprint, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_AnimationBlueprint, TEXT("ToolTip"), TEXT("The blueprint for creating an AnimationScript."));
				MetaData->SetValue(NewProp_AnimationMode, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_AnimationMode, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_AnimationMode, TEXT("ToolTip"), TEXT("Whether to use Animation Blueprint or play Single Animation Asset."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkeletalMeshComponent(Z_Construct_UClass_USkeletalMeshComponent, TEXT("USkeletalMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkeletalMeshComponent);
	UClass* Z_Construct_UClass_UMatineeAnimInterface_NoRegister()
	{
		return UMatineeAnimInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UMatineeAnimInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Engine();
			OuterClass = UMatineeAnimInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20084081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("CannotImplementInterfaceInBlueprint"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMatineeAnimInterface(Z_Construct_UClass_UMatineeAnimInterface, TEXT("UMatineeAnimInterface"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMatineeAnimInterface);
	UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial0()
	{
		UObject* Outer=Z_Construct_UClass_ASkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedMaterial0"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial1()
	{
		UObject* Outer=Z_Construct_UClass_ASkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedMaterial1"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMesh()
	{
		UObject* Outer=Z_Construct_UClass_ASkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedMesh"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replication Notification Callbacks"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedPhysAsset()
	{
		UObject* Outer=Z_Construct_UClass_ASkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedPhysAsset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ASkeletalMeshActor_NoRegister()
	{
		return ASkeletalMeshActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ASkeletalMeshActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ASkeletalMeshActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial0());
				OuterClass->LinkChild(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial1());
				OuterClass->LinkChild(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMesh());
				OuterClass->LinkChild(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedPhysAsset());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ReplicatedMaterial1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedMaterial1"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReplicatedMaterial1, ASkeletalMeshActor), 0x0000000100000020, Z_Construct_UClass_UMaterialInterface_NoRegister());
				NewProp_ReplicatedMaterial1->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedMaterial1"));
				UProperty* NewProp_ReplicatedMaterial0 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedMaterial0"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReplicatedMaterial0, ASkeletalMeshActor), 0x0000000100000020, Z_Construct_UClass_UMaterialInterface_NoRegister());
				NewProp_ReplicatedMaterial0->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedMaterial0"));
				UProperty* NewProp_ReplicatedPhysAsset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedPhysAsset"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReplicatedPhysAsset, ASkeletalMeshActor), 0x0000000100002020, Z_Construct_UClass_UPhysicsAsset_NoRegister());
				NewProp_ReplicatedPhysAsset->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedPhysAsset"));
				UProperty* NewProp_ReplicatedMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReplicatedMesh, ASkeletalMeshActor), 0x0000000100002020, Z_Construct_UClass_USkeletalMesh_NoRegister());
				NewProp_ReplicatedMesh->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedMesh"));
				UProperty* NewProp_SkeletalMeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkeletalMeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SkeletalMeshComponent, ASkeletalMeshActor), 0x00000000000a001d, Z_Construct_UClass_USkeletalMeshComponent_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWakeOnLevelStart_DEPRECATED, ASkeletalMeshActor, uint8);
				UProperty* NewProp_bWakeOnLevelStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWakeOnLevelStart"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWakeOnLevelStart_DEPRECATED, ASkeletalMeshActor), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bWakeOnLevelStart_DEPRECATED, ASkeletalMeshActor), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldDoAnimNotifies, ASkeletalMeshActor, uint8);
				UProperty* NewProp_bShouldDoAnimNotifies = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldDoAnimNotifies"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldDoAnimNotifies, ASkeletalMeshActor), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bShouldDoAnimNotifies, ASkeletalMeshActor), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial0()); // 313226390
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMaterial1()); // 3481485209
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedMesh()); // 122921556
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASkeletalMeshActor_OnRep_ReplicatedPhysAsset()); // 3992263079
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UMatineeAnimInterface_NoRegister(), VTABLE_OFFSET(ASkeletalMeshActor, IMatineeAnimInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ChildCanTick"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("ISkeletalMeshes"));
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IsConversionRoot"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("SkeletalMeshActor is an instance of a USkeletalMesh in the world.\nSkeletal meshes are deformable meshes that can be animated and change their geometry at run-time.\nSkeletal meshes dragged into the level from the Content Browser are automatically converted to StaticMeshActors.\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/\n@see USkeletalMesh"));
				MetaData->SetValue(NewProp_ReplicatedMaterial1, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_ReplicatedMaterial0, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_ReplicatedMaterial0, TEXT("ToolTip"), TEXT("used to replicate the material in index 0"));
				MetaData->SetValue(NewProp_ReplicatedPhysAsset, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_ReplicatedPhysAsset, TEXT("ToolTip"), TEXT("Used to replicate physics asset to clients"));
				MetaData->SetValue(NewProp_ReplicatedMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_ReplicatedMesh, TEXT("ToolTip"), TEXT("Used to replicate mesh to clients"));
				MetaData->SetValue(NewProp_SkeletalMeshComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_SkeletalMeshComponent, TEXT("Category"), TEXT("SkeletalMeshActor"));
				MetaData->SetValue(NewProp_SkeletalMeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SkeletalMeshComponent, TEXT("ExposeFunctionCategories"), TEXT("Mesh,Components|SkeletalMesh,Animation,Physics"));
				MetaData->SetValue(NewProp_SkeletalMeshComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_bWakeOnLevelStart, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_bShouldDoAnimNotifies, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_bShouldDoAnimNotifies, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/SkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_bShouldDoAnimNotifies, TEXT("ToolTip"), TEXT("Whether or not this actor should respond to anim notifies - CURRENTLY ONLY AFFECTS PlayParticleEffect NOTIFIES*"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASkeletalMeshActor(Z_Construct_UClass_ASkeletalMeshActor, TEXT("ASkeletalMeshActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASkeletalMeshActor);
	UClass* Z_Construct_UClass_ASplineMeshActor_NoRegister()
	{
		return ASplineMeshActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ASplineMeshActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ASplineMeshActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SplineMeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineMeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SplineMeshComponent, ASplineMeshActor), 0x00000000000a001d, Z_Construct_UClass_USplineMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ChildCanTick"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Input"));
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/SplineMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsConversionRoot"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SplineMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("SplineMeshActor is an actor with a SplineMeshComponent.\n\n@see USplineMeshComponent"));
				MetaData->SetValue(NewProp_SplineMeshComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_SplineMeshComponent, TEXT("Category"), TEXT("SplineMeshActor"));
				MetaData->SetValue(NewProp_SplineMeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SplineMeshComponent, TEXT("ExposeFunctionCategories"), TEXT("Mesh,Rendering,Physics,Components|StaticMesh,Components|SplineMesh"));
				MetaData->SetValue(NewProp_SplineMeshComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/SplineMeshActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASplineMeshActor(Z_Construct_UClass_ASplineMeshActor, TEXT("ASplineMeshActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASplineMeshActor);
	UClass* Z_Construct_UClass_AStaticMeshActor_NoRegister()
	{
		return AStaticMeshActor::StaticClass();
	}
	UClass* Z_Construct_UClass_AStaticMeshActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = AStaticMeshActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_NavigationGeometryGatheringMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavigationGeometryGatheringMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NavigationGeometryGatheringMode, AStaticMeshActor), 0x0000040000000001, Z_Construct_UEnum_Engine_ENavDataGatheringMode());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStaticMeshReplicateMovement, AStaticMeshActor, bool);
				UProperty* NewProp_bStaticMeshReplicateMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bStaticMeshReplicateMovement"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStaticMeshReplicateMovement, AStaticMeshActor), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bStaticMeshReplicateMovement, AStaticMeshActor), sizeof(bool), true);
				UProperty* NewProp_StaticMeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StaticMeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(StaticMeshComponent, AStaticMeshActor), 0x00000000000a001d, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ChildCanTick"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Input"));
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/StaticMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsConversionRoot"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/StaticMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("StaticMeshActor is an instance of a UStaticMesh in the world.\nStatic meshes are geometry that do not animate or otherwise deform, and are more efficient to render than other types of geometry.\nStatic meshes dragged into the level from the Content Browser are automatically converted to StaticMeshActors.\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Actors/StaticMeshActor/\n@see UStaticMesh"));
				MetaData->SetValue(NewProp_NavigationGeometryGatheringMode, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_NavigationGeometryGatheringMode, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/StaticMeshActor.h"));
				MetaData->SetValue(NewProp_bStaticMeshReplicateMovement, TEXT("Category"), TEXT("Actor"));
				MetaData->SetValue(NewProp_bStaticMeshReplicateMovement, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/StaticMeshActor.h"));
				MetaData->SetValue(NewProp_bStaticMeshReplicateMovement, TEXT("ToolTip"), TEXT("This static mesh should replicate movement. Automatically sets the RemoteRole and bReplicateMovement flags. Meant to be edited on placed actors (those other two proeprties are not)"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("Category"), TEXT("StaticMeshActor"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("ExposeFunctionCategories"), TEXT("Mesh,Rendering,Physics,Components|StaticMesh"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/StaticMeshActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AStaticMeshActor(Z_Construct_UClass_AStaticMeshActor, TEXT("AStaticMeshActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AStaticMeshActor);
	UClass* Z_Construct_UClass_ATargetPoint_NoRegister()
	{
		return ATargetPoint::StaticClass();
	}
	UClass* Z_Construct_UClass_ATargetPoint()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ATargetPoint::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_ArrowComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ArrowComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ArrowComponent, ATargetPoint), 0x0000000800080008, Z_Construct_UClass_UArrowComponent_NoRegister());
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, ATargetPoint), 0x00000008000a001d, Z_Construct_UClass_UBillboardComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/TargetPoint.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TargetPoint.h"));
				MetaData->SetValue(NewProp_ArrowComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ArrowComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TargetPoint.h"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("Category"), TEXT("Display"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TargetPoint.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATargetPoint(Z_Construct_UClass_ATargetPoint, TEXT("ATargetPoint"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATargetPoint);
	UClass* Z_Construct_UClass_ATextRenderActor_NoRegister()
	{
		return ATextRenderActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ATextRenderActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ATextRenderActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, ATextRenderActor), 0x0000000800080008, Z_Construct_UClass_UBillboardComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_TextRender = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TextRender"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TextRender, ATextRenderActor), 0x00000000000a001d, Z_Construct_UClass_UTextRenderComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Attachment Actor"));
				MetaData->SetValue(OuterClass, TEXT("IgnoreCategoryKeywordsInSubclasses"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/TextRenderActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TextRenderActor.h"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TextRenderActor.h"));
				MetaData->SetValue(NewProp_TextRender, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_TextRender, TEXT("Category"), TEXT("TextRenderActor"));
				MetaData->SetValue(NewProp_TextRender, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_TextRender, TEXT("ExposeFunctionCategories"), TEXT("Rendering|Components|TextRender"));
				MetaData->SetValue(NewProp_TextRender, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TextRenderActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATextRenderActor(Z_Construct_UClass_ATextRenderActor, TEXT("ATextRenderActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATextRenderActor);
	UClass* Z_Construct_UClass_ATriggerBase_NoRegister()
	{
		return ATriggerBase::StaticClass();
	}
	UClass* Z_Construct_UClass_ATriggerBase()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = ATriggerBase::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, ATriggerBase), 0x0000000000080008, Z_Construct_UClass_UBillboardComponent_NoRegister());
				UProperty* NewProp_CollisionComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CollisionComponent, ATriggerBase), 0x00000000000a001d, Z_Construct_UClass_UShapeComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Common"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/TriggerBase.h"));
				MetaData->SetValue(OuterClass, TEXT("IsConversionRoot"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TriggerBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("An actor used to generate collision events (begin/end overlap) in the level."));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TriggerBase.h"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("Category"), TEXT("TriggerBase"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CollisionComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TriggerBase.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATriggerBase(Z_Construct_UClass_ATriggerBase, TEXT("ATriggerBase"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATriggerBase);
	UClass* Z_Construct_UClass_ATriggerBox_NoRegister()
	{
		return ATriggerBox::StaticClass();
	}
	UClass* Z_Construct_UClass_ATriggerBox()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ATriggerBase();
			Z_Construct_UPackage_Engine();
			OuterClass = ATriggerBox::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/TriggerBox.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TriggerBox.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A box shaped trigger, used to generate overlap events in the level"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATriggerBox(Z_Construct_UClass_ATriggerBox, TEXT("ATriggerBox"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATriggerBox);
	UClass* Z_Construct_UClass_ATriggerCapsule_NoRegister()
	{
		return ATriggerCapsule::StaticClass();
	}
	UClass* Z_Construct_UClass_ATriggerCapsule()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ATriggerBase();
			Z_Construct_UPackage_Engine();
			OuterClass = ATriggerCapsule::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/TriggerCapsule.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TriggerCapsule.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A capsule shaped trigger, used to generate overlap events in the level"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATriggerCapsule(Z_Construct_UClass_ATriggerCapsule, TEXT("ATriggerCapsule"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATriggerCapsule);
	UClass* Z_Construct_UClass_ATriggerSphere_NoRegister()
	{
		return ATriggerSphere::StaticClass();
	}
	UClass* Z_Construct_UClass_ATriggerSphere()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ATriggerBase();
			Z_Construct_UPackage_Engine();
			OuterClass = ATriggerSphere::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Engine/TriggerSphere.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Engine/TriggerSphere.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A sphere shaped trigger, used to generate overlap events in the level"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATriggerSphere(Z_Construct_UClass_ATriggerSphere, TEXT("ATriggerSphere"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATriggerSphere);
	UClass* Z_Construct_UClass_AVectorFieldVolume_NoRegister()
	{
		return AVectorFieldVolume::StaticClass();
	}
	UClass* Z_Construct_UClass_AVectorFieldVolume()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Engine();
			OuterClass = AVectorFieldVolume::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SpriteComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpriteComponent, AVectorFieldVolume), 0x0000000800080008, Z_Construct_UClass_UBillboardComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_VectorFieldComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VectorFieldComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VectorFieldComponent, AVectorFieldVolume), 0x00000000000a001d, Z_Construct_UClass_UVectorFieldComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Advanced Collision"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VectorField/VectorFieldVolume.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/VectorField/VectorFieldVolume.h"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SpriteComponent, TEXT("ModuleRelativePath"), TEXT("Classes/VectorField/VectorFieldVolume.h"));
				MetaData->SetValue(NewProp_VectorFieldComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VectorFieldComponent, TEXT("Category"), TEXT("VectorFieldVolume"));
				MetaData->SetValue(NewProp_VectorFieldComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VectorFieldComponent, TEXT("ModuleRelativePath"), TEXT("Classes/VectorField/VectorFieldVolume.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AVectorFieldVolume(Z_Construct_UClass_AVectorFieldVolume, TEXT("AVectorFieldVolume"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AVectorFieldVolume);
	UFunction* Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature()
	{
		UObject* Outer=Z_Construct_UClass_UApplicationLifecycleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ApplicationLifetimeDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UApplicationLifecycleComponent_NoRegister()
	{
		return UApplicationLifecycleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UApplicationLifecycleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UApplicationLifecycleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ApplicationWillTerminateDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplicationWillTerminateDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(ApplicationWillTerminateDelegate, UApplicationLifecycleComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature());
				UProperty* NewProp_ApplicationHasEnteredForegroundDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplicationHasEnteredForegroundDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(ApplicationHasEnteredForegroundDelegate, UApplicationLifecycleComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature());
				UProperty* NewProp_ApplicationWillEnterBackgroundDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplicationWillEnterBackgroundDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(ApplicationWillEnterBackgroundDelegate, UApplicationLifecycleComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature());
				UProperty* NewProp_ApplicationHasReactivatedDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplicationHasReactivatedDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(ApplicationHasReactivatedDelegate, UApplicationLifecycleComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature());
				UProperty* NewProp_ApplicationWillDeactivateDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplicationWillDeactivateDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(ApplicationWillDeactivateDelegate, UApplicationLifecycleComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature()); // 3690490437
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Activation Components|Activation Collision ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Component to handle receiving notifications from the OS about application state (activated, suspended, termination, etc)."));
				MetaData->SetValue(NewProp_ApplicationWillTerminateDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(NewProp_ApplicationWillTerminateDelegate, TEXT("ToolTip"), TEXT("This *may* be called when the application is getting terminated by the OS.\nThere is no guarantee that this will ever be called on a mobile device,\nsave state when ApplicationWillEnterBackgroundDelegate is called instead."));
				MetaData->SetValue(NewProp_ApplicationHasEnteredForegroundDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(NewProp_ApplicationHasEnteredForegroundDelegate, TEXT("ToolTip"), TEXT("Called when the application is returning to the foreground (reverse any processing done in the EnterBackground delegate)"));
				MetaData->SetValue(NewProp_ApplicationWillEnterBackgroundDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(NewProp_ApplicationWillEnterBackgroundDelegate, TEXT("ToolTip"), TEXT("This is called when the application is being backgrounded (e.g., due to switching\nto another app or closing it via the home button)\nThe game should release shared resources, save state, etc..., since it can be\nterminated from the background state without any further warning."));
				MetaData->SetValue(NewProp_ApplicationHasReactivatedDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(NewProp_ApplicationHasReactivatedDelegate, TEXT("ToolTip"), TEXT("Called when the application has been reactivated (reverse any processing done in the Deactivate delegate)"));
				MetaData->SetValue(NewProp_ApplicationWillDeactivateDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ApplicationLifecycleComponent.h"));
				MetaData->SetValue(NewProp_ApplicationWillDeactivateDelegate, TEXT("ToolTip"), TEXT("This is called when the application is about to be deactivated (e.g., due to a phone call or SMS or the sleep button).\nThe game should be paused if possible, etc..."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UApplicationLifecycleComponent(Z_Construct_UClass_UApplicationLifecycleComponent, TEXT("UApplicationLifecycleComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UApplicationLifecycleComponent);
	UEnum* Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EPlaneConstraintAxisSetting"), 0, Get_Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EPlaneConstraintAxisSetting"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPlaneConstraintAxisSetting::Custom")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPlaneConstraintAxisSetting::X")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPlaneConstraintAxisSetting::Y")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPlaneConstraintAxisSetting::Z")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPlaneConstraintAxisSetting::UseGlobalPhysicsSetting")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPlaneConstraintAxisSetting::EPlaneConstraintAxisSetting_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Custom.ToolTip"), TEXT("Lock movement to a user-defined axis."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Setting that controls behavior when movement is restricted to a 2D plane defined by a specific axis/normal,\nso that movement along the locked axis is not be possible."));
			MetaData->SetValue(ReturnEnum, TEXT("UseGlobalPhysicsSetting.ToolTip"), TEXT("Use the global physics project setting."));
			MetaData->SetValue(ReturnEnum, TEXT("X.ToolTip"), TEXT("Lock movement in the X axis."));
			MetaData->SetValue(ReturnEnum, TEXT("Y.ToolTip"), TEXT("Lock movement in the Y axis."));
			MetaData->SetValue(ReturnEnum, TEXT("Z.ToolTip"), TEXT("Lock movement in the Z axis."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting_CRC() { return 3549103373U; }
	UFunction* Z_Construct_UFunction_UMovementComponent_ConstrainDirectionToPlane()
	{
		struct MovementComponent_eventConstrainDirectionToPlane_Parms
		{
			FVector Direction;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstrainDirectionToPlane"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(MovementComponent_eventConstrainDirectionToPlane_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventConstrainDirectionToPlane_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Direction"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Direction, MovementComponent_eventConstrainDirectionToPlane_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Constrain a direction vector to the plane constraint, if enabled.\n@see SetPlaneConstraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_ConstrainLocationToPlane()
	{
		struct MovementComponent_eventConstrainLocationToPlane_Parms
		{
			FVector Location;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstrainLocationToPlane"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(MovementComponent_eventConstrainLocationToPlane_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventConstrainLocationToPlane_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, MovementComponent_eventConstrainLocationToPlane_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Constrain a position vector to the plane constraint, if enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_ConstrainNormalToPlane()
	{
		struct MovementComponent_eventConstrainNormalToPlane_Parms
		{
			FVector Normal;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstrainNormalToPlane"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(MovementComponent_eventConstrainNormalToPlane_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventConstrainNormalToPlane_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Normal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Normal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Normal, MovementComponent_eventConstrainNormalToPlane_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Constrain a normal vector (of unit length) to the plane constraint, if enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_GetGravityZ()
	{
		struct MovementComponent_eventGetGravityZ_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGravityZ"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MovementComponent_eventGetGravityZ_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventGetGravityZ_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return gravity that affects this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_GetMaxSpeed()
	{
		struct MovementComponent_eventGetMaxSpeed_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMaxSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MovementComponent_eventGetMaxSpeed_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventGetMaxSpeed_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return Maximum speed of component in current movement mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_GetPhysicsVolume()
	{
		struct MovementComponent_eventGetPhysicsVolume_Parms
		{
			APhysicsVolume* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysicsVolume"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MovementComponent_eventGetPhysicsVolume_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventGetPhysicsVolume_Parms), 0x0000000000000580, Z_Construct_UClass_APhysicsVolume_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return PhysicsVolume this MovementComponent is using, or the world's default physics volume if none. *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintAxisSetting()
	{
		struct MovementComponent_eventGetPlaneConstraintAxisSetting_Parms
		{
			TEnumAsByte<EPlaneConstraintAxisSetting> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlaneConstraintAxisSetting"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(MovementComponent_eventGetPlaneConstraintAxisSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventGetPlaneConstraintAxisSetting_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the plane constraint axis setting."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintNormal()
	{
		struct MovementComponent_eventGetPlaneConstraintNormal_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlaneConstraintNormal"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(MovementComponent_eventGetPlaneConstraintNormal_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventGetPlaneConstraintNormal_Parms), 0x0000000008000582, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return The normal of the plane that constrains movement, enforced if the plane constraint is enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintOrigin()
	{
		struct MovementComponent_eventGetPlaneConstraintOrigin_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlaneConstraintOrigin"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(MovementComponent_eventGetPlaneConstraintOrigin_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventGetPlaneConstraintOrigin_Parms), 0x0000000008000582, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the plane constraint origin. This defines the behavior of snapping a position to the plane, such as by SnapUpdatedComponentToPlane().\n@return The origin of the plane that constrains movement, if the plane constraint is enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_IsExceedingMaxSpeed()
	{
		struct MovementComponent_eventIsExceedingMaxSpeed_Parms
		{
			float MaxSpeed;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsExceedingMaxSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MovementComponent_eventIsExceedingMaxSpeed_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MovementComponent_eventIsExceedingMaxSpeed_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MovementComponent_eventIsExceedingMaxSpeed_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MovementComponent_eventIsExceedingMaxSpeed_Parms), sizeof(bool), true);
			UProperty* NewProp_MaxSpeed = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSpeed, MovementComponent_eventIsExceedingMaxSpeed_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns true if the current velocity is exceeding the given max speed (usually the result of GetMaxSpeed()), within a small error tolerance.\nNote that under normal circumstances updates cause by acceleration will not cause this to be true, however external forces or changes in the max speed limit\ncan cause the max speed to be violated."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_K2_GetMaxSpeedModifier()
	{
		struct MovementComponent_eventK2_GetMaxSpeedModifier_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_GetMaxSpeedModifier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MovementComponent_eventK2_GetMaxSpeedModifier_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventK2_GetMaxSpeedModifier_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("GetMaxSpeedModifier() is deprecated, apply your own modifiers to GetMaxSpeed() if desired."));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetMaxSpeedModifier"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return a scalar applied to the maximum velocity that the component can currently move."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_K2_GetModifiedMaxSpeed()
	{
		struct MovementComponent_eventK2_GetModifiedMaxSpeed_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_GetModifiedMaxSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MovementComponent_eventK2_GetModifiedMaxSpeed_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, MovementComponent_eventK2_GetModifiedMaxSpeed_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("GetModifiedMaxSpeed() is deprecated, apply your own modifiers to GetMaxSpeed() if desired."));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetModifiedMaxSpeed"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the result of GetMaxSpeed() * GetMaxSpeedModifier()."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_K2_MoveUpdatedComponent()
	{
		struct MovementComponent_eventK2_MoveUpdatedComponent_Parms
		{
			FVector Delta;
			FRotator NewRotation;
			FHitResult OutHit;
			bool bSweep;
			bool bTeleport;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_MoveUpdatedComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(MovementComponent_eventK2_MoveUpdatedComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MovementComponent_eventK2_MoveUpdatedComponent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MovementComponent_eventK2_MoveUpdatedComponent_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MovementComponent_eventK2_MoveUpdatedComponent_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTeleport, MovementComponent_eventK2_MoveUpdatedComponent_Parms, bool);
			UProperty* NewProp_bTeleport = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTeleport"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTeleport, MovementComponent_eventK2_MoveUpdatedComponent_Parms), 0x0000040000000080, CPP_BOOL_PROPERTY_BITMASK(bTeleport, MovementComponent_eventK2_MoveUpdatedComponent_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSweep, MovementComponent_eventK2_MoveUpdatedComponent_Parms, bool);
			UProperty* NewProp_bSweep = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSweep"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSweep, MovementComponent_eventK2_MoveUpdatedComponent_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSweep, MovementComponent_eventK2_MoveUpdatedComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutHit, MovementComponent_eventK2_MoveUpdatedComponent_Parms), 0x0000008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_NewRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewRotation, MovementComponent_eventK2_MoveUpdatedComponent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_Delta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Delta"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Delta, MovementComponent_eventK2_MoveUpdatedComponent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AdvancedDisplay"), TEXT("bTeleport"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSweep"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bTeleport"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MoveUpdatedComponent"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Moves our UpdatedComponent by the given Delta, and sets rotation to NewRotation.\nRespects the plane constraint, if enabled.\n@return True if some movement occurred, false if no movement occurred. Result of any impact will be stored in OutHit."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_PhysicsVolumeChanged()
	{
		struct MovementComponent_eventPhysicsVolumeChanged_Parms
		{
			APhysicsVolume* NewVolume;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PhysicsVolumeChanged"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535, sizeof(MovementComponent_eventPhysicsVolumeChanged_Parms));
			UProperty* NewProp_NewVolume = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVolume"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewVolume, MovementComponent_eventPhysicsVolumeChanged_Parms), 0x0000000000000080, Z_Construct_UClass_APhysicsVolume_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate when PhysicsVolume of UpdatedComponent has been changed *"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintAxisSetting()
	{
		struct MovementComponent_eventSetPlaneConstraintAxisSetting_Parms
		{
			TEnumAsByte<EPlaneConstraintAxisSetting> NewAxisSetting;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlaneConstraintAxisSetting"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(MovementComponent_eventSetPlaneConstraintAxisSetting_Parms));
			UProperty* NewProp_NewAxisSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAxisSetting"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewAxisSetting, MovementComponent_eventSetPlaneConstraintAxisSetting_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the plane constraint axis setting.\nChanging this setting will modify the current value of PlaneConstraintNormal.\n\n@param  NewAxisSetting New plane constraint axis setting."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintEnabled()
	{
		struct MovementComponent_eventSetPlaneConstraintEnabled_Parms
		{
			bool bEnabled;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlaneConstraintEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(MovementComponent_eventSetPlaneConstraintEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnabled, MovementComponent_eventSetPlaneConstraintEnabled_Parms, bool);
			UProperty* NewProp_bEnabled = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnabled, MovementComponent_eventSetPlaneConstraintEnabled_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnabled, MovementComponent_eventSetPlaneConstraintEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets whether or not the plane constraint is enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintFromVectors()
	{
		struct MovementComponent_eventSetPlaneConstraintFromVectors_Parms
		{
			FVector Forward;
			FVector Up;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlaneConstraintFromVectors"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(MovementComponent_eventSetPlaneConstraintFromVectors_Parms));
			UProperty* NewProp_Up = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Up"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Up, MovementComponent_eventSetPlaneConstraintFromVectors_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Forward = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Forward"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Forward, MovementComponent_eventSetPlaneConstraintFromVectors_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Uses the Forward and Up vectors to compute the plane that constrains movement, enforced if the plane constraint is enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintNormal()
	{
		struct MovementComponent_eventSetPlaneConstraintNormal_Parms
		{
			FVector PlaneNormal;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlaneConstraintNormal"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(MovementComponent_eventSetPlaneConstraintNormal_Parms));
			UProperty* NewProp_PlaneNormal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PlaneNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PlaneNormal, MovementComponent_eventSetPlaneConstraintNormal_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the normal of the plane that constrains movement, enforced if the plane constraint is enabled.\nChanging the normal automatically sets PlaneConstraintAxisSetting to \"Custom\".\n\n@param PlaneNormal   The normal of the plane. If non-zero in length, it will be normalized."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintOrigin()
	{
		struct MovementComponent_eventSetPlaneConstraintOrigin_Parms
		{
			FVector PlaneOrigin;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlaneConstraintOrigin"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(MovementComponent_eventSetPlaneConstraintOrigin_Parms));
			UProperty* NewProp_PlaneOrigin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PlaneOrigin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PlaneOrigin, MovementComponent_eventSetPlaneConstraintOrigin_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the origin of the plane that constrains movement, enforced if the plane constraint is enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SetUpdatedComponent()
	{
		struct MovementComponent_eventSetUpdatedComponent_Parms
		{
			USceneComponent* NewUpdatedComponent;
		};
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetUpdatedComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(MovementComponent_eventSetUpdatedComponent_Parms));
			UProperty* NewProp_NewUpdatedComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewUpdatedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewUpdatedComponent, MovementComponent_eventSetUpdatedComponent_Parms), 0x0000000000080080, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Assign the component we move and update."));
			MetaData->SetValue(NewProp_NewUpdatedComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_SnapUpdatedComponentToPlane()
	{
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SnapUpdatedComponentToPlane"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement|Planar"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Snap the updated component to the plane constraint, if enabled."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMovementComponent_StopMovementImmediately()
	{
		UObject* Outer=Z_Construct_UClass_UMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopMovementImmediately"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops movement immediately (zeroes velocity, usually zeros acceleration for components with acceleration)."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMovementComponent_NoRegister()
	{
		return UMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_ConstrainDirectionToPlane());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_ConstrainLocationToPlane());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_ConstrainNormalToPlane());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_GetGravityZ());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_GetMaxSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_GetPhysicsVolume());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintAxisSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintNormal());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintOrigin());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_IsExceedingMaxSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_K2_GetMaxSpeedModifier());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_K2_GetModifiedMaxSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_K2_MoveUpdatedComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_PhysicsVolumeChanged());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintAxisSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintFromVectors());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintNormal());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintOrigin());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SetUpdatedComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_SnapUpdatedComponentToPlane());
				OuterClass->LinkChild(Z_Construct_UFunction_UMovementComponent_StopMovementImmediately());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoRegisterUpdatedComponent, UMovementComponent, uint8);
				UProperty* NewProp_bAutoRegisterUpdatedComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutoRegisterUpdatedComponent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoRegisterUpdatedComponent, UMovementComponent), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAutoRegisterUpdatedComponent, UMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoUpdateTickRegistration, UMovementComponent, uint8);
				UProperty* NewProp_bAutoUpdateTickRegistration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutoUpdateTickRegistration"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoUpdateTickRegistration, UMovementComponent), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAutoUpdateTickRegistration, UMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOnlyIfRendered, UMovementComponent, uint8);
				UProperty* NewProp_bUpdateOnlyIfRendered = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUpdateOnlyIfRendered"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOnlyIfRendered, UMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bUpdateOnlyIfRendered, UMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_PlaneConstraintOrigin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlaneConstraintOrigin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PlaneConstraintOrigin, UMovementComponent), 0x0000080000010015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PlaneConstraintNormal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlaneConstraintNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PlaneConstraintNormal, UMovementComponent), 0x0000080000010015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PlaneConstraintAxisSetting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlaneConstraintAxisSetting"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PlaneConstraintAxisSetting, UMovementComponent), 0x0000000000010001, Z_Construct_UEnum_Engine_EPlaneConstraintAxisSetting());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSnapToPlaneAtStart, UMovementComponent, uint8);
				UProperty* NewProp_bSnapToPlaneAtStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSnapToPlaneAtStart"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSnapToPlaneAtStart, UMovementComponent), 0x0000000000010015, CPP_BOOL_PROPERTY_BITMASK(bSnapToPlaneAtStart, UMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConstrainToPlane, UMovementComponent, uint8);
				UProperty* NewProp_bConstrainToPlane = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bConstrainToPlane"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConstrainToPlane, UMovementComponent), 0x0000000000010015, CPP_BOOL_PROPERTY_BITMASK(bConstrainToPlane, UMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_Velocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Velocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Velocity, UMovementComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_UpdatedPrimitive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdatedPrimitive"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(UpdatedPrimitive, UMovementComponent), 0x000000000028001c, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
				UProperty* NewProp_UpdatedComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdatedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(UpdatedComponent, UMovementComponent), 0x000000000028001c, Z_Construct_UClass_USceneComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_ConstrainDirectionToPlane()); // 805348462
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_ConstrainLocationToPlane()); // 2124162653
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_ConstrainNormalToPlane()); // 806256632
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_GetGravityZ()); // 3333281606
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_GetMaxSpeed()); // 3434613690
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_GetPhysicsVolume()); // 408072008
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintAxisSetting()); // 3917219285
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintNormal()); // 2788165099
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_GetPlaneConstraintOrigin()); // 419315119
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_IsExceedingMaxSpeed()); // 968979449
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_K2_GetMaxSpeedModifier()); // 3615828907
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_K2_GetModifiedMaxSpeed()); // 4201510924
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_K2_MoveUpdatedComponent()); // 241960911
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_PhysicsVolumeChanged()); // 970202751
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintAxisSetting()); // 3408459471
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintEnabled()); // 241205581
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintFromVectors()); // 410757
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintNormal()); // 531839176
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SetPlaneConstraintOrigin()); // 27737789
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SetUpdatedComponent()); // 3464799914
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_SnapUpdatedComponentToPlane()); // 1735809944
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMovementComponent_StopMovementImmediately()); // 3183658398
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/MovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("MovementComponent is an abstract component class that defines functionality for moving a PrimitiveComponent (our UpdatedComponent) each tick.\nBase functionality includes:\n   - Restricting movement to a plane or axis.\n   - Utility functions for special handling of collision results (SlideAlongSurface(), ComputeSlideVector(), TwoWallAdjust()).\n   - Utility functions for moving when there may be initial penetration (SafeMoveUpdatedComponent(), ResolvePenetration()).\n   - Automatically registering the component tick and finding a component to move on the owning Actor.\nNormally the root component of the owning actor is moved, however another component may be selected (see SetUpdatedComponent()).\nDuring swept (non-teleporting) movement only collision of UpdatedComponent is considered, attached components will teleport to the end location ignoring collision."));
				MetaData->SetValue(NewProp_bAutoRegisterUpdatedComponent, TEXT("Category"), TEXT("MovementComponent"));
				MetaData->SetValue(NewProp_bAutoRegisterUpdatedComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_bAutoRegisterUpdatedComponent, TEXT("ToolTip"), TEXT("If true, registers the owner's Root component as the UpdatedComponent if there is not one currently assigned."));
				MetaData->SetValue(NewProp_bAutoUpdateTickRegistration, TEXT("Category"), TEXT("MovementComponent"));
				MetaData->SetValue(NewProp_bAutoUpdateTickRegistration, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_bAutoUpdateTickRegistration, TEXT("ToolTip"), TEXT("If true, whenever the updated component is changed, this component will enable or disable its tick dependent on whether it has something to update.\nThis will NOT enable tick at startup if bAutoActivate is false, because presumably you have a good reason for not wanting it to start ticking initially."));
				MetaData->SetValue(NewProp_bUpdateOnlyIfRendered, TEXT("Category"), TEXT("MovementComponent"));
				MetaData->SetValue(NewProp_bUpdateOnlyIfRendered, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_bUpdateOnlyIfRendered, TEXT("ToolTip"), TEXT("If true, skips TickComponent() if UpdatedComponent was not recently rendered."));
				MetaData->SetValue(NewProp_PlaneConstraintOrigin, TEXT("Category"), TEXT("PlanarMovement"));
				MetaData->SetValue(NewProp_PlaneConstraintOrigin, TEXT("editcondition"), TEXT("bConstrainToPlane"));
				MetaData->SetValue(NewProp_PlaneConstraintOrigin, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_PlaneConstraintOrigin, TEXT("ToolTip"), TEXT("The origin of the plane that constrains movement, if plane constraint is enabled.\nThis defines the behavior of snapping a position to the plane, such as by SnapUpdatedComponentToPlane().\n@see bConstrainToPlane, SetPlaneConstraintOrigin()."));
				MetaData->SetValue(NewProp_PlaneConstraintNormal, TEXT("Category"), TEXT("PlanarMovement"));
				MetaData->SetValue(NewProp_PlaneConstraintNormal, TEXT("editcondition"), TEXT("bConstrainToPlane"));
				MetaData->SetValue(NewProp_PlaneConstraintNormal, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_PlaneConstraintNormal, TEXT("ToolTip"), TEXT("The normal or axis of the plane that constrains movement, if bConstrainToPlane is enabled.\nIf for example you wanted to constrain movement to the X-Z plane (so that Y cannot change), the normal would be set to X=0 Y=1 Z=0.\nThis is recalculated whenever PlaneConstraintAxisSetting changes.\n@see bConstrainToPlane, SetPlaneConstraintNormal(), SetPlaneConstraintFromVectors()"));
				MetaData->SetValue(NewProp_PlaneConstraintAxisSetting, TEXT("Category"), TEXT("PlanarMovement"));
				MetaData->SetValue(NewProp_PlaneConstraintAxisSetting, TEXT("editcondition"), TEXT("bConstrainToPlane"));
				MetaData->SetValue(NewProp_PlaneConstraintAxisSetting, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_PlaneConstraintAxisSetting, TEXT("ToolTip"), TEXT("Setting that controls behavior when movement is restricted to a 2D plane defined by a specific axis/normal,\nso that movement along the locked axis is not be possible.\n@see SetPlaneConstraintAxisSetting"));
				MetaData->SetValue(NewProp_bSnapToPlaneAtStart, TEXT("Category"), TEXT("PlanarMovement"));
				MetaData->SetValue(NewProp_bSnapToPlaneAtStart, TEXT("editcondition"), TEXT("bConstrainToPlane"));
				MetaData->SetValue(NewProp_bSnapToPlaneAtStart, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_bSnapToPlaneAtStart, TEXT("ToolTip"), TEXT("If true and plane constraints are enabled, then the updated component will be snapped to the plane when first attached."));
				MetaData->SetValue(NewProp_bConstrainToPlane, TEXT("Category"), TEXT("PlanarMovement"));
				MetaData->SetValue(NewProp_bConstrainToPlane, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_bConstrainToPlane, TEXT("ToolTip"), TEXT("If true, movement will be constrained to a plane.\n@see PlaneConstraintNormal, PlaneConstraintOrigin, PlaneConstraintAxisSetting"));
				MetaData->SetValue(NewProp_Velocity, TEXT("Category"), TEXT("Velocity"));
				MetaData->SetValue(NewProp_Velocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_Velocity, TEXT("ToolTip"), TEXT("Current velocity of updated component."));
				MetaData->SetValue(NewProp_UpdatedPrimitive, TEXT("Category"), TEXT("MovementComponent"));
				MetaData->SetValue(NewProp_UpdatedPrimitive, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_UpdatedPrimitive, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_UpdatedPrimitive, TEXT("ToolTip"), TEXT("UpdatedComponent, cast as a UPrimitiveComponent. May be invalid if UpdatedComponent was null or not a UPrimitiveComponent."));
				MetaData->SetValue(NewProp_UpdatedComponent, TEXT("Category"), TEXT("MovementComponent"));
				MetaData->SetValue(NewProp_UpdatedComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_UpdatedComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/MovementComponent.h"));
				MetaData->SetValue(NewProp_UpdatedComponent, TEXT("ToolTip"), TEXT("The component we move and update.\nIf this is null at startup and bAutoRegisterUpdatedComponent is true, the owning Actor's root component will automatically be set as our UpdatedComponent at startup.\n@see bAutoRegisterUpdatedComponent, SetUpdatedComponent(), UpdatedPrimitive"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMovementComponent(Z_Construct_UClass_UMovementComponent, TEXT("UMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMovementComponent);
	UEnum* Z_Construct_UEnum_Engine_ESplineCoordinateSpace()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESplineCoordinateSpace_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESplineCoordinateSpace"), 0, Get_Z_Construct_UEnum_Engine_ESplineCoordinateSpace_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESplineCoordinateSpace"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineCoordinateSpace::Local")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineCoordinateSpace::World")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineCoordinateSpace::ESplineCoordinateSpace_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Types of coordinate space accepted by the functions."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESplineCoordinateSpace_CRC() { return 4141080886U; }
	UEnum* Z_Construct_UEnum_Engine_ESplinePointType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESplinePointType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESplinePointType"), 0, Get_Z_Construct_UEnum_Engine_ESplinePointType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESplinePointType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplinePointType::Linear")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplinePointType::Curve")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplinePointType::Constant")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplinePointType::CurveClamped")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplinePointType::CurveCustomTangent")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplinePointType::ESplinePointType_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Permitted spline point types for SplineComponent."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESplinePointType_CRC() { return 246511301U; }
	UFunction* Z_Construct_UFunction_USplineComponent_AddSplineLocalPoint()
	{
		struct SplineComponent_eventAddSplineLocalPoint_Parms
		{
			FVector Position;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSplineLocalPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventAddSplineLocalPoint_Parms));
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Position, SplineComponent_eventAddSplineLocalPoint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use AddSplinePoint, specifying SplineCoordinateSpace::Local"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds a local space point to the spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_AddSplinePoint()
	{
		struct SplineComponent_eventAddSplinePoint_Parms
		{
			FVector Position;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventAddSplinePoint_Parms));
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventAddSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Position, SplineComponent_eventAddSplinePoint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds a point to the spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_AddSplineWorldPoint()
	{
		struct SplineComponent_eventAddSplineWorldPoint_Parms
		{
			FVector Position;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSplineWorldPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventAddSplineWorldPoint_Parms));
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Position, SplineComponent_eventAddSplineWorldPoint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use AddSplinePoint, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds a world space point to the spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_ClearSplinePoints()
	{
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClearSplinePoints"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clears all the points in the spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetDefaultUpVector()
	{
		struct SplineComponent_eventGetDefaultUpVector_Parms
		{
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDefaultUpVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetDefaultUpVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetDefaultUpVector_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetDefaultUpVector_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the default up vector used by this spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetDirectionAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetDirectionAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDirectionAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetDirectionAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetDirectionAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetDirectionAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetDirectionAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a unit direction vector of the spline tangent there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetDirectionAtSplinePoint()
	{
		struct SplineComponent_eventGetDirectionAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDirectionAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetDirectionAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetDirectionAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetDirectionAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetDirectionAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the location at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetDirectionAtTime()
	{
		struct SplineComponent_eventGetDirectionAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDirectionAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetDirectionAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetDirectionAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetDirectionAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetDirectionAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetDirectionAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetDirectionAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetDirectionAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return a unit direction vector of the spline tangent there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetDistanceAlongSplineAtSplinePoint()
	{
		struct SplineComponent_eventGetDistanceAlongSplineAtSplinePoint_Parms
		{
			int32 PointIndex;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDistanceAlongSplineAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetDistanceAlongSplineAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetDistanceAlongSplineAtSplinePoint_Parms), 0x0000000000000580);
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetDistanceAlongSplineAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the distance along the spline at the spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetInputKeyAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetInputKeyAtDistanceAlongSpline_Parms
		{
			float Distance;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInputKeyAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetInputKeyAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetInputKeyAtDistanceAlongSpline_Parms), 0x0000000000000580);
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetInputKeyAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the corresponding input key at that point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetLocalLocationAndTangentAtSplinePoint()
	{
		struct SplineComponent_eventGetLocalLocationAndTangentAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector LocalLocation;
			FVector LocalTangent;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLocalLocationAndTangentAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(SplineComponent_eventGetLocalLocationAndTangentAtSplinePoint_Parms));
			UProperty* NewProp_LocalTangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LocalTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LocalTangent, SplineComponent_eventGetLocalLocationAndTangentAtSplinePoint_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LocalLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LocalLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LocalLocation, SplineComponent_eventGetLocalLocationAndTangentAtSplinePoint_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetLocalLocationAndTangentAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetLocationAndTangentAtSplinePoint, specifying SplineCoordinateSpace::Local"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get local location and tangent at a spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAndTangentAtSplinePoint()
	{
		struct SplineComponent_eventGetLocationAndTangentAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector Location;
			FVector Tangent;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLocationAndTangentAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(SplineComponent_eventGetLocationAndTangentAtSplinePoint_Parms));
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetLocationAndTangentAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Tangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Tangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Tangent, SplineComponent_eventGetLocationAndTangentAtSplinePoint_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, SplineComponent_eventGetLocationAndTangentAtSplinePoint_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetLocationAndTangentAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get location and tangent at a spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetLocationAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLocationAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetLocationAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetLocationAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetLocationAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetLocationAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the point in space where this puts you"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAtSplinePoint()
	{
		struct SplineComponent_eventGetLocationAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLocationAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetLocationAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetLocationAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetLocationAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetLocationAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the location at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetLocationAtTime()
	{
		struct SplineComponent_eventGetLocationAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLocationAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetLocationAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetLocationAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetLocationAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetLocationAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetLocationAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetLocationAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetLocationAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the point in space where this puts you"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetNumberOfSplinePoints()
	{
		struct SplineComponent_eventGetNumberOfSplinePoints_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetNumberOfSplinePoints"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetNumberOfSplinePoints_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetNumberOfSplinePoints_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the number of points that make up this spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetQuaternionAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetQuaternionAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FQuat ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetQuaternionAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetQuaternionAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetQuaternionAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FQuat());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetQuaternionAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetQuaternionAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a quaternion corresponding to the spline's rotation there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetQuaternionAtSplinePoint()
	{
		struct SplineComponent_eventGetQuaternionAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FQuat ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetQuaternionAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetQuaternionAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetQuaternionAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FQuat());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetQuaternionAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetQuaternionAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the rotation at spline point as a quaternion"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetQuaternionAtTime()
	{
		struct SplineComponent_eventGetQuaternionAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FQuat ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetQuaternionAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetQuaternionAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetQuaternionAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FQuat());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetQuaternionAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetQuaternionAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetQuaternionAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetQuaternionAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetQuaternionAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return a quaternion corresponding to the spline's rotation there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRightVectorAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetRightVectorAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRightVectorAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetRightVectorAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRightVectorAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRightVectorAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetRightVectorAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a unit direction vector corresponding to the spline's right vector there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRightVectorAtSplinePoint()
	{
		struct SplineComponent_eventGetRightVectorAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRightVectorAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetRightVectorAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRightVectorAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRightVectorAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetRightVectorAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the right vector at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRightVectorAtTime()
	{
		struct SplineComponent_eventGetRightVectorAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRightVectorAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetRightVectorAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRightVectorAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetRightVectorAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetRightVectorAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetRightVectorAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRightVectorAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetRightVectorAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the spline's right vector there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRollAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetRollAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRollAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetRollAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRollAtDistanceAlongSpline_Parms), 0x0000000000000580);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRollAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetRollAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the spline's roll there, in degrees."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRollAtSplinePoint()
	{
		struct SplineComponent_eventGetRollAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRollAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetRollAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRollAtSplinePoint_Parms), 0x0000000000000580);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRollAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetRollAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the amount of roll at spline point, in degrees"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRollAtTime()
	{
		struct SplineComponent_eventGetRollAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRollAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetRollAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRollAtTime_Parms), 0x0000000000000580);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetRollAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetRollAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetRollAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRollAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetRollAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the spline's roll there, in degrees."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRotationAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetRotationAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRotationAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetRotationAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRotationAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRotationAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetRotationAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a rotation corresponding to the spline's rotation there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRotationAtSplinePoint()
	{
		struct SplineComponent_eventGetRotationAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRotationAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetRotationAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRotationAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRotationAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetRotationAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the rotation at spline point as a rotator"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetRotationAtTime()
	{
		struct SplineComponent_eventGetRotationAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRotationAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetRotationAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetRotationAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FRotator());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetRotationAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetRotationAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetRotationAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetRotationAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetRotationAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return a rotation corresponding to the spline's position and direction there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetScaleAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetScaleAtDistanceAlongSpline_Parms
		{
			float Distance;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaleAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetScaleAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetScaleAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetScaleAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the spline's scale there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetScaleAtSplinePoint()
	{
		struct SplineComponent_eventGetScaleAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaleAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetScaleAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetScaleAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetScaleAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the scale at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetScaleAtTime()
	{
		struct SplineComponent_eventGetScaleAtTime_Parms
		{
			float Time;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaleAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetScaleAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetScaleAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetScaleAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetScaleAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetScaleAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetScaleAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the spline's scale there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetSplineLength()
	{
		struct SplineComponent_eventGetSplineLength_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSplineLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetSplineLength_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetSplineLength_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns total length along this spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetSplinePointType()
	{
		struct SplineComponent_eventGetSplinePointType_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplinePointType::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSplinePointType"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventGetSplinePointType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetSplinePointType_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_ESplinePointType());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetSplinePointType_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the type of a spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetTangentAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetTangentAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTangentAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetTangentAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetTangentAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetTangentAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetTangentAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the tangent vector of the spline there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetTangentAtSplinePoint()
	{
		struct SplineComponent_eventGetTangentAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTangentAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetTangentAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetTangentAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetTangentAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetTangentAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the tangent at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetTangentAtTime()
	{
		struct SplineComponent_eventGetTangentAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTangentAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetTangentAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetTangentAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetTangentAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetTangentAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetTangentAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetTangentAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetTangentAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the spline's tangent there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetTransformAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseScale;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTransformAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseScale, SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms, bool);
			UProperty* NewProp_bUseScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseScale, SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseScale, SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetTransformAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseScale"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return an FTransform corresponding to that point on the spline."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetTransformAtSplinePoint()
	{
		struct SplineComponent_eventGetTransformAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseScale;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTransformAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetTransformAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetTransformAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseScale, SplineComponent_eventGetTransformAtSplinePoint_Parms, bool);
			UProperty* NewProp_bUseScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseScale, SplineComponent_eventGetTransformAtSplinePoint_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseScale, SplineComponent_eventGetTransformAtSplinePoint_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetTransformAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetTransformAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseScale"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the transform at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetTransformAtTime()
	{
		struct SplineComponent_eventGetTransformAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			bool bUseScale;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTransformAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetTransformAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetTransformAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseScale, SplineComponent_eventGetTransformAtTime_Parms, bool);
			UProperty* NewProp_bUseScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseScale, SplineComponent_eventGetTransformAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseScale, SplineComponent_eventGetTransformAtTime_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetTransformAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetTransformAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetTransformAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetTransformAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetTransformAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseScale"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the spline's transform at the corresponding position."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetUpVectorAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetUpVectorAtDistanceAlongSpline_Parms
		{
			float Distance;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUpVectorAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetUpVectorAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetUpVectorAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetUpVectorAtDistanceAlongSpline_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetUpVectorAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a unit direction vector corresponding to the spline's up vector there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetUpVectorAtSplinePoint()
	{
		struct SplineComponent_eventGetUpVectorAtSplinePoint_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUpVectorAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetUpVectorAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetUpVectorAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetUpVectorAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetUpVectorAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the up vector at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetUpVectorAtTime()
	{
		struct SplineComponent_eventGetUpVectorAtTime_Parms
		{
			float Time;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUpVectorAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetUpVectorAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetUpVectorAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetUpVectorAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetUpVectorAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetUpVectorAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventGetUpVectorAtTime_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetUpVectorAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the spline's up vector there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetWorldDirectionAtDistanceAlongSpline_Parms
		{
			float Distance;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldDirectionAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldDirectionAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldDirectionAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetWorldDirectionAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetDirectionAtDistanceAlongSpline, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a unit direction vector of the spline tangent there, in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtTime()
	{
		struct SplineComponent_eventGetWorldDirectionAtTime_Parms
		{
			float Time;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldDirectionAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldDirectionAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldDirectionAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetWorldDirectionAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetWorldDirectionAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetWorldDirectionAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetWorldDirectionAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetDirectionAtTime, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return a unit direction vector of the spline tangent there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldLocationAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetWorldLocationAtDistanceAlongSpline_Parms
		{
			float Distance;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldLocationAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldLocationAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldLocationAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetWorldLocationAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetLocationAtDistanceAlongSpline, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the point in world space where this puts you"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldLocationAtSplinePoint()
	{
		struct SplineComponent_eventGetWorldLocationAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldLocationAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldLocationAtSplinePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldLocationAtSplinePoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventGetWorldLocationAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetLocationAtSplinePoint, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the world location at spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldLocationAtTime()
	{
		struct SplineComponent_eventGetWorldLocationAtTime_Parms
		{
			float Time;
			bool bUseConstantVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldLocationAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldLocationAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldLocationAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetWorldLocationAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetWorldLocationAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetWorldLocationAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetWorldLocationAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetLocationAtTime, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return the point in space where this puts you"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldRotationAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetWorldRotationAtDistanceAlongSpline_Parms
		{
			float Distance;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldRotationAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldRotationAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldRotationAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetWorldRotationAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetRotationAtDistanceAlongSpline, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return a rotation corresponding to the spline's rotation there, in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldRotationAtTime()
	{
		struct SplineComponent_eventGetWorldRotationAtTime_Parms
		{
			float Time;
			bool bUseConstantVelocity;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldRotationAtTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldRotationAtTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldRotationAtTime_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FRotator());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseConstantVelocity, SplineComponent_eventGetWorldRotationAtTime_Parms, bool);
			UProperty* NewProp_bUseConstantVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseConstantVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseConstantVelocity, SplineComponent_eventGetWorldRotationAtTime_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseConstantVelocity, SplineComponent_eventGetWorldRotationAtTime_Parms), sizeof(bool), true);
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, SplineComponent_eventGetWorldRotationAtTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUseConstantVelocity"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetRotationAtTime, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a time from 0 to the spline duration, return a rotation corresponding to the spline's position and direction there."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_GetWorldTangentAtDistanceAlongSpline()
	{
		struct SplineComponent_eventGetWorldTangentAtDistanceAlongSpline_Parms
		{
			float Distance;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWorldTangentAtDistanceAlongSpline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineComponent_eventGetWorldTangentAtDistanceAlongSpline_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineComponent_eventGetWorldTangentAtDistanceAlongSpline_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Distance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Distance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Distance, SplineComponent_eventGetWorldTangentAtDistanceAlongSpline_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use GetTangentAtDistanceAlongSpline, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Given a distance along the length of this spline, return the tangent vector of the spline there, in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_IsClosedLoop()
	{
		struct SplineComponent_eventIsClosedLoop_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsClosedLoop"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineComponent_eventIsClosedLoop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, SplineComponent_eventIsClosedLoop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, SplineComponent_eventIsClosedLoop_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, SplineComponent_eventIsClosedLoop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check whether the spline is a closed loop or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetClosedLoop()
	{
		struct SplineComponent_eventSetClosedLoop_Parms
		{
			bool bInClosedLoop;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetClosedLoop"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineComponent_eventSetClosedLoop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInClosedLoop, SplineComponent_eventSetClosedLoop_Parms, bool);
			UProperty* NewProp_bInClosedLoop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInClosedLoop"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInClosedLoop, SplineComponent_eventSetClosedLoop_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bInClosedLoop, SplineComponent_eventSetClosedLoop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Specify whether the spline is a closed loop or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetDefaultUpVector()
	{
		struct SplineComponent_eventSetDefaultUpVector_Parms
		{
			FVector UpVector;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDefaultUpVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventSetDefaultUpVector_Parms));
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventSetDefaultUpVector_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_UpVector = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UpVector"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(UpVector, SplineComponent_eventSetDefaultUpVector_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the default up vector used by this spline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetLocationAtSplinePoint()
	{
		struct SplineComponent_eventSetLocationAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector InLocation;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLocationAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventSetLocationAtSplinePoint_Parms));
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventSetLocationAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_InLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InLocation, SplineComponent_eventSetLocationAtSplinePoint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventSetLocationAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Move an existing point to a new location"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetSelectedSplineSegmentColor()
	{
		struct SplineComponent_eventSetSelectedSplineSegmentColor_Parms
		{
			FLinearColor SegmentColor;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSelectedSplineSegmentColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventSetSelectedSplineSegmentColor_Parms));
			UProperty* NewProp_SegmentColor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SegmentColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SegmentColor, SplineComponent_eventSetSelectedSplineSegmentColor_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Editor"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Specify selected spline component segment color in the editor"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetSplineLocalPoints()
	{
		struct SplineComponent_eventSetSplineLocalPoints_Parms
		{
			TArray<FVector> Points;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSplineLocalPoints"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(SplineComponent_eventSetSplineLocalPoints_Parms));
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Points"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Points, SplineComponent_eventSetSplineLocalPoints_Parms), 0x0000000008000182);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use SetSplinePoints, specifying SplineCoordinateSpace::Local"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the spline to an array of local space points"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetSplinePoints()
	{
		struct SplineComponent_eventSetSplinePoints_Parms
		{
			TArray<FVector> Points;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSplinePoints"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(SplineComponent_eventSetSplinePoints_Parms));
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventSetSplinePoints_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Points"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Points, SplineComponent_eventSetSplinePoints_Parms), 0x0000000008000182);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the spline to an array of points"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetSplinePointType()
	{
		struct SplineComponent_eventSetSplinePointType_Parms
		{
			int32 PointIndex;
			TEnumAsByte<ESplinePointType::Type> Type;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSplinePointType"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineComponent_eventSetSplinePointType_Parms));
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Type"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Type, SplineComponent_eventSetSplinePointType_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplinePointType());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventSetSplinePointType_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Specify the type of a spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetSplineWorldPoints()
	{
		struct SplineComponent_eventSetSplineWorldPoints_Parms
		{
			TArray<FVector> Points;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSplineWorldPoints"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(SplineComponent_eventSetSplineWorldPoints_Parms));
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Points"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Points, SplineComponent_eventSetSplineWorldPoints_Parms), 0x0000000008000182);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use SetSplinePoints, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the spline to an array of world space points"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetTangentAtSplinePoint()
	{
		struct SplineComponent_eventSetTangentAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector InTangent;
			TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTangentAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventSetTangentAtSplinePoint_Parms));
			UProperty* NewProp_CoordinateSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CoordinateSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CoordinateSpace, SplineComponent_eventSetTangentAtSplinePoint_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineCoordinateSpace());
			UProperty* NewProp_InTangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InTangent, SplineComponent_eventSetTangentAtSplinePoint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventSetTangentAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Specify the tangent at a given spline point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetUnselectedSplineSegmentColor()
	{
		struct SplineComponent_eventSetUnselectedSplineSegmentColor_Parms
		{
			FLinearColor SegmentColor;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetUnselectedSplineSegmentColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventSetUnselectedSplineSegmentColor_Parms));
			UProperty* NewProp_SegmentColor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SegmentColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SegmentColor, SplineComponent_eventSetUnselectedSplineSegmentColor_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Editor"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Specify unselected spline component segment color in the editor"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineComponent_SetWorldLocationAtSplinePoint()
	{
		struct SplineComponent_eventSetWorldLocationAtSplinePoint_Parms
		{
			int32 PointIndex;
			FVector InLocation;
		};
		UObject* Outer=Z_Construct_UClass_USplineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetWorldLocationAtSplinePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineComponent_eventSetWorldLocationAtSplinePoint_Parms));
			UProperty* NewProp_InLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InLocation, SplineComponent_eventSetWorldLocationAtSplinePoint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PointIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PointIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PointIndex, SplineComponent_eventSetWorldLocationAtSplinePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Spline"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Please use SetLocationAtSplinePoint, specifying SplineCoordinateSpace::World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Move an existing point to a new world location"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USplineComponent_NoRegister()
	{
		return USplineComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USplineComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USplineComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_AddSplineLocalPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_AddSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_AddSplineWorldPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_ClearSplinePoints());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetDefaultUpVector());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetDirectionAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetDirectionAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetDirectionAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetDistanceAlongSplineAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetInputKeyAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetLocalLocationAndTangentAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetLocationAndTangentAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetLocationAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetLocationAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetLocationAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetNumberOfSplinePoints());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetQuaternionAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetQuaternionAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetQuaternionAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRightVectorAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRightVectorAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRightVectorAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRollAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRollAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRollAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRotationAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRotationAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetRotationAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetScaleAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetScaleAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetScaleAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetSplineLength());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetSplinePointType());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetTangentAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetTangentAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetTangentAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetTransformAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetTransformAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetTransformAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetUpVectorAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetUpVectorAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetUpVectorAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldLocationAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldLocationAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldLocationAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldRotationAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldRotationAtTime());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_GetWorldTangentAtDistanceAlongSpline());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_IsClosedLoop());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetClosedLoop());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetDefaultUpVector());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetLocationAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetSelectedSplineSegmentColor());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetSplineLocalPoints());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetSplinePoints());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetSplinePointType());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetSplineWorldPoints());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetTangentAtSplinePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetUnselectedSplineSegmentColor());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineComponent_SetWorldLocationAtSplinePoint());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_ScaleVisualizationWidth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleVisualizationWidth"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleVisualizationWidth, USplineComponent), 0x0000000800000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldVisualizeScale, USplineComponent, bool);
				UProperty* NewProp_bShouldVisualizeScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldVisualizeScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldVisualizeScale, USplineComponent), 0x0000000800000001, CPP_BOOL_PROPERTY_BITMASK(bShouldVisualizeScale, USplineComponent), sizeof(bool), true);
				UProperty* NewProp_EditorSelectedSplineSegmentColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EditorSelectedSplineSegmentColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EditorSelectedSplineSegmentColor, USplineComponent), 0x0000000800000001, Z_Construct_UScriptStruct_FLinearColor());
				UProperty* NewProp_EditorUnselectedSplineSegmentColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EditorUnselectedSplineSegmentColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EditorUnselectedSplineSegmentColor, USplineComponent), 0x0000000800000001, Z_Construct_UScriptStruct_FLinearColor());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_DefaultUpVector = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultUpVector"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(DefaultUpVector, USplineComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClosedLoop, USplineComponent, bool);
				UProperty* NewProp_bClosedLoop = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bClosedLoop"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClosedLoop, USplineComponent), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bClosedLoop, USplineComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSplineHasBeenEdited, USplineComponent, bool);
				UProperty* NewProp_bSplineHasBeenEdited = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSplineHasBeenEdited"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSplineHasBeenEdited, USplineComponent), 0x0000000000020001, CPP_BOOL_PROPERTY_BITMASK(bSplineHasBeenEdited, USplineComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStationaryEndpoints, USplineComponent, bool);
				UProperty* NewProp_bStationaryEndpoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bStationaryEndpoints"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStationaryEndpoints, USplineComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bStationaryEndpoints, USplineComponent), sizeof(bool), true);
				UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Duration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Duration, USplineComponent), 0x0000000000000005);
				UProperty* NewProp_ReparamStepsPerSegment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReparamStepsPerSegment"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReparamStepsPerSegment, USplineComponent), 0x0000040000000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowSplineEditingPerInstance_DEPRECATED, USplineComponent, bool);
				UProperty* NewProp_bAllowSplineEditingPerInstance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowSplineEditingPerInstance"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowSplineEditingPerInstance_DEPRECATED, USplineComponent), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bAllowSplineEditingPerInstance_DEPRECATED, USplineComponent), sizeof(bool), true);
				UProperty* NewProp_SplineReparamTable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineReparamTable"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SplineReparamTable, USplineComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurveFloat());
				UProperty* NewProp_SplineScaleInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineScaleInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SplineScaleInfo, USplineComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurveVector());
				UProperty* NewProp_SplineRotInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineRotInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SplineRotInfo, USplineComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurveQuat());
				UProperty* NewProp_SplineInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SplineInfo, USplineComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurveVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_AddSplineLocalPoint()); // 3409875118
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_AddSplinePoint()); // 519620654
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_AddSplineWorldPoint()); // 3657386612
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_ClearSplinePoints()); // 4159316753
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetDefaultUpVector()); // 2353969547
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetDirectionAtDistanceAlongSpline()); // 3793351584
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetDirectionAtSplinePoint()); // 751924705
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetDirectionAtTime()); // 1978234869
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetDistanceAlongSplineAtSplinePoint()); // 3690314717
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetInputKeyAtDistanceAlongSpline()); // 1913281423
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetLocalLocationAndTangentAtSplinePoint()); // 1762873861
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetLocationAndTangentAtSplinePoint()); // 3232597995
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetLocationAtDistanceAlongSpline()); // 633215234
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetLocationAtSplinePoint()); // 2442661760
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetLocationAtTime()); // 2356457070
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetNumberOfSplinePoints()); // 1958482093
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetQuaternionAtDistanceAlongSpline()); // 2522998861
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetQuaternionAtSplinePoint()); // 3710731128
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetQuaternionAtTime()); // 354690585
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRightVectorAtDistanceAlongSpline()); // 375114872
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRightVectorAtSplinePoint()); // 2204046683
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRightVectorAtTime()); // 3678912121
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRollAtDistanceAlongSpline()); // 2430287148
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRollAtSplinePoint()); // 1164429191
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRollAtTime()); // 1197520685
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRotationAtDistanceAlongSpline()); // 3888935438
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRotationAtSplinePoint()); // 3868914540
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetRotationAtTime()); // 1042491657
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetScaleAtDistanceAlongSpline()); // 2319571567
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetScaleAtSplinePoint()); // 599294439
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetScaleAtTime()); // 3215676863
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetSplineLength()); // 329120577
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetSplinePointType()); // 3003176598
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetTangentAtDistanceAlongSpline()); // 3175636624
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetTangentAtSplinePoint()); // 1851183918
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetTangentAtTime()); // 2969388361
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetTransformAtDistanceAlongSpline()); // 3553376564
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetTransformAtSplinePoint()); // 965990669
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetTransformAtTime()); // 4064935389
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetUpVectorAtDistanceAlongSpline()); // 4009127191
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetUpVectorAtSplinePoint()); // 2168184988
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetUpVectorAtTime()); // 4213445324
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtDistanceAlongSpline()); // 1202023686
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldDirectionAtTime()); // 2619369340
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldLocationAtDistanceAlongSpline()); // 2421296257
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldLocationAtSplinePoint()); // 2593738565
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldLocationAtTime()); // 1720543354
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldRotationAtDistanceAlongSpline()); // 2056713692
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldRotationAtTime()); // 3407872043
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_GetWorldTangentAtDistanceAlongSpline()); // 4191182498
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_IsClosedLoop()); // 2227730270
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetClosedLoop()); // 1120153272
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetDefaultUpVector()); // 311062877
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetLocationAtSplinePoint()); // 1341590811
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetSelectedSplineSegmentColor()); // 2124836824
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetSplineLocalPoints()); // 1640614180
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetSplinePoints()); // 1311928819
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetSplinePointType()); // 2026180011
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetSplineWorldPoints()); // 54121571
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetTangentAtSplinePoint()); // 4087643729
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetUnselectedSplineSegmentColor()); // 3101698822
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineComponent_SetWorldLocationAtSplinePoint()); // 1421459713
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SplineComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A spline component is a spline shape which can be used for other purposes (e.g. animating objects). It does not contain rendering capabilities itself (outside the editor)\n@see https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Blueprint_Splines"));
				MetaData->SetValue(NewProp_ScaleVisualizationWidth, TEXT("Category"), TEXT("Editor"));
				MetaData->SetValue(NewProp_ScaleVisualizationWidth, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_ScaleVisualizationWidth, TEXT("ToolTip"), TEXT("Width of spline in editor for use with scale visualization"));
				MetaData->SetValue(NewProp_bShouldVisualizeScale, TEXT("Category"), TEXT("Editor"));
				MetaData->SetValue(NewProp_bShouldVisualizeScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_bShouldVisualizeScale, TEXT("ToolTip"), TEXT("Whether scale visualization should be displayed"));
				MetaData->SetValue(NewProp_EditorSelectedSplineSegmentColor, TEXT("Category"), TEXT("Editor"));
				MetaData->SetValue(NewProp_EditorSelectedSplineSegmentColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_EditorSelectedSplineSegmentColor, TEXT("ToolTip"), TEXT("Color of a selected spline component segment in the editor"));
				MetaData->SetValue(NewProp_EditorUnselectedSplineSegmentColor, TEXT("Category"), TEXT("Editor"));
				MetaData->SetValue(NewProp_EditorUnselectedSplineSegmentColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_EditorUnselectedSplineSegmentColor, TEXT("ToolTip"), TEXT("Color of an unselected spline component segment in the editor"));
				MetaData->SetValue(NewProp_DefaultUpVector, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_DefaultUpVector, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_DefaultUpVector, TEXT("ToolTip"), TEXT("Default up vector in local space to be used when calculating transforms along the spline"));
				MetaData->SetValue(NewProp_bClosedLoop, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_bClosedLoop, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_bClosedLoop, TEXT("ToolTip"), TEXT("Whether the spline is to be considered as a closed loop.\nUse SetClosedLoop() to set this property, and IsClosedLoop() to read it."));
				MetaData->SetValue(NewProp_bSplineHasBeenEdited, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_bSplineHasBeenEdited, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_bSplineHasBeenEdited, TEXT("ToolTip"), TEXT("Whether the spline has been edited from its default by the spline component visualizer"));
				MetaData->SetValue(NewProp_bStationaryEndpoints, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_bStationaryEndpoints, TEXT("EditCondition"), TEXT("!bClosedLoop"));
				MetaData->SetValue(NewProp_bStationaryEndpoints, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_bStationaryEndpoints, TEXT("ToolTip"), TEXT("Whether the endpoints of the spline are considered stationary when traversing the spline at non-constant velocity.  Essentially this sets the endpoints' tangents to zero vectors."));
				MetaData->SetValue(NewProp_Duration, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_Duration, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_Duration, TEXT("ToolTip"), TEXT("Specifies the duration of the spline in seconds"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("ClampMax"), TEXT("100"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("ClampMin"), TEXT("4"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("ToolTip"), TEXT("Number of steps per spline segment to place in the reparameterization table"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("UIMax"), TEXT("100"));
				MetaData->SetValue(NewProp_ReparamStepsPerSegment, TEXT("UIMin"), TEXT("4"));
				MetaData->SetValue(NewProp_bAllowSplineEditingPerInstance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_SplineReparamTable, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_SplineReparamTable, TEXT("ToolTip"), TEXT("Input, distance along curve, output, parameter that puts you there."));
				MetaData->SetValue(NewProp_SplineScaleInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_SplineScaleInfo, TEXT("ToolTip"), TEXT("Spline built from scale data."));
				MetaData->SetValue(NewProp_SplineRotInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_SplineRotInfo, TEXT("ToolTip"), TEXT("Spline built from rotation data."));
				MetaData->SetValue(NewProp_SplineInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineComponent.h"));
				MetaData->SetValue(NewProp_SplineInfo, TEXT("ToolTip"), TEXT("Spline built from position data. //EditAnywhere, Category = Points)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USplineComponent(Z_Construct_UClass_USplineComponent, TEXT("USplineComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USplineComponent);
	UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature()
	{
		struct InterpToMovementComponent_eventOnInterpToResetDelegate_Parms
		{
			FHitResult ImpactResult;
			float Time;
		};
		UObject* Outer=Z_Construct_UClass_UInterpToMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToResetDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00530000, 65535, sizeof(InterpToMovementComponent_eventOnInterpToResetDelegate_Parms));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, InterpToMovementComponent_eventOnInterpToResetDelegate_Parms), 0x0000000000000080);
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, InterpToMovementComponent_eventOnInterpToResetDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature()
	{
		struct InterpToMovementComponent_eventOnInterpToWaitEndDelegate_Parms
		{
			FHitResult ImpactResult;
			float Time;
		};
		UObject* Outer=Z_Construct_UClass_UInterpToMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToWaitEndDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00530000, 65535, sizeof(InterpToMovementComponent_eventOnInterpToWaitEndDelegate_Parms));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, InterpToMovementComponent_eventOnInterpToWaitEndDelegate_Parms), 0x0000000000000080);
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, InterpToMovementComponent_eventOnInterpToWaitEndDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature()
	{
		struct InterpToMovementComponent_eventOnInterpToWaitBeginDelegate_Parms
		{
			FHitResult ImpactResult;
			float Time;
		};
		UObject* Outer=Z_Construct_UClass_UInterpToMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToWaitBeginDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00530000, 65535, sizeof(InterpToMovementComponent_eventOnInterpToWaitBeginDelegate_Parms));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, InterpToMovementComponent_eventOnInterpToWaitBeginDelegate_Parms), 0x0000000000000080);
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, InterpToMovementComponent_eventOnInterpToWaitBeginDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature()
	{
		struct InterpToMovementComponent_eventOnInterpToStopDelegate_Parms
		{
			FHitResult ImpactResult;
			float Time;
		};
		UObject* Outer=Z_Construct_UClass_UInterpToMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToStopDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00530000, 65535, sizeof(InterpToMovementComponent_eventOnInterpToStopDelegate_Parms));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, InterpToMovementComponent_eventOnInterpToStopDelegate_Parms), 0x0000000000000080);
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, InterpToMovementComponent_eventOnInterpToStopDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature()
	{
		struct InterpToMovementComponent_eventOnInterpToReverseDelegate_Parms
		{
			FHitResult ImpactResult;
			float Time;
		};
		UObject* Outer=Z_Construct_UClass_UInterpToMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnInterpToReverseDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00530000, 65535, sizeof(InterpToMovementComponent_eventOnInterpToReverseDelegate_Parms));
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, InterpToMovementComponent_eventOnInterpToReverseDelegate_Parms), 0x0000000000000080);
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, InterpToMovementComponent_eventOnInterpToReverseDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UEnum* Z_Construct_UEnum_Engine_EInterpToBehaviourType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EInterpToBehaviourType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EInterpToBehaviourType"), 0, Get_Z_Construct_UEnum_Engine_EInterpToBehaviourType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EInterpToBehaviourType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EInterpToBehaviourType::OneShot")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EInterpToBehaviourType::OneShot_Reverse")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EInterpToBehaviourType::Loop_Reset")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EInterpToBehaviourType::PingPong")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EInterpToBehaviourType::EInterpToBehaviourType_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Loop_Reset.ToolTip"), TEXT("Reset back to start when reaching the end"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("OneShot.ToolTip"), TEXT("Move to destination and stop"));
			MetaData->SetValue(ReturnEnum, TEXT("OneShot_Reverse.ToolTip"), TEXT("Move to destination, return and stop"));
			MetaData->SetValue(ReturnEnum, TEXT("PingPong.ToolTip"), TEXT("Repeatedly lerp from start to end and back"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Controls the movement behaviour"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EInterpToBehaviourType_CRC() { return 657488595U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpControlPoint()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpControlPoint_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("InterpControlPoint"), sizeof(FInterpControlPoint), Get_Z_Construct_UScriptStruct_FInterpControlPoint_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpControlPoint"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FInterpControlPoint>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPositionIsRelative, FInterpControlPoint, bool);
			UProperty* NewProp_bPositionIsRelative = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bPositionIsRelative"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPositionIsRelative, FInterpControlPoint), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bPositionIsRelative, FInterpControlPoint), sizeof(bool), true);
			UProperty* NewProp_PositionControlPoint = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PositionControlPoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PositionControlPoint, FInterpControlPoint), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
			MetaData->SetValue(NewProp_bPositionIsRelative, TEXT("Category"), TEXT("Location"));
			MetaData->SetValue(NewProp_bPositionIsRelative, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
			MetaData->SetValue(NewProp_bPositionIsRelative, TEXT("ToolTip"), TEXT("Is the location relative to the root components initial location"));
			MetaData->SetValue(NewProp_PositionControlPoint, TEXT("Category"), TEXT("Location"));
			MetaData->SetValue(NewProp_PositionControlPoint, TEXT("MakeEditWidget"), TEXT("TRUE"));
			MetaData->SetValue(NewProp_PositionControlPoint, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
			MetaData->SetValue(NewProp_PositionControlPoint, TEXT("ToolTip"), TEXT("The position of the point"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpControlPoint_CRC() { return 173171639U; }
	UFunction* Z_Construct_UFunction_UInterpToMovementComponent_StopSimulating()
	{
		struct InterpToMovementComponent_eventStopSimulating_Parms
		{
			FHitResult HitResult;
		};
		UObject* Outer=Z_Construct_UClass_UInterpToMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopSimulating"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(InterpToMovementComponent_eventStopSimulating_Parms));
			UProperty* NewProp_HitResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitResult, InterpToMovementComponent_eventStopSimulating_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|InterpToMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clears the reference to UpdatedComponent, fires stop event, and stops ticking."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UInterpToMovementComponent_NoRegister()
	{
		return UInterpToMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UInterpToMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UInterpToMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UFunction_UInterpToMovementComponent_StopSimulating());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ControlPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ControlPoints"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ControlPoints, UInterpToMovementComponent), 0x0000000000000005);
				UProperty* NewProp_ControlPoints_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ControlPoints, TEXT("ControlPoints"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpControlPoint());
				UProperty* NewProp_MaxSimulationIterations = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSimulationIterations"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxSimulationIterations, UInterpToMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxSimulationTimeStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSimulationTimeStep"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSimulationTimeStep, UInterpToMovementComponent), 0x0000000000000005);
				UProperty* NewProp_OnResetDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnResetDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnResetDelegate, UInterpToMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature());
				UProperty* NewProp_OnWaitEndDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnWaitEndDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnWaitEndDelegate, UInterpToMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature());
				UProperty* NewProp_OnWaitBeginDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnWaitBeginDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnWaitBeginDelegate, UInterpToMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature());
				UProperty* NewProp_OnInterpToStop = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInterpToStop"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInterpToStop, UInterpToMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature());
				UProperty* NewProp_OnInterpToReverse = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInterpToReverse"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInterpToReverse, UInterpToMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceSubStepping, UInterpToMovementComponent, uint8);
				UProperty* NewProp_bForceSubStepping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceSubStepping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceSubStepping, UInterpToMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bForceSubStepping, UInterpToMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_BehaviourType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BehaviourType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BehaviourType, UInterpToMovementComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_EInterpToBehaviourType());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPauseOnImpact, UInterpToMovementComponent, uint8);
				UProperty* NewProp_bPauseOnImpact = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPauseOnImpact"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPauseOnImpact, UInterpToMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bPauseOnImpact, UInterpToMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Duration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Duration, UInterpToMovementComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature()); // 2008680795
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature()); // 3208063476
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature()); // 855523970
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature()); // 3223582857
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature()); // 3648653257
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInterpToMovementComponent_StopSimulating()); // 567196620
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Velocity ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/InterpToMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Move the root component between a series of points over a given time *\n\n@see UMovementComponent"));
				MetaData->SetValue(NewProp_ControlPoints, TEXT("Category"), TEXT("Control"));
				MetaData->SetValue(NewProp_ControlPoints, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_ControlPoints, TEXT("ToolTip"), TEXT("List of control points to visit."));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("Category"), TEXT("Simulation"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ClampMax"), TEXT("25"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ClampMin"), TEXT("1"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ToolTip"), TEXT("Max number of iterations used for each discrete simulation step.\nIncreasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationTimeStep, bForceSubStepping"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("UIMax"), TEXT("25"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("Category"), TEXT("Simulation"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ClampMax"), TEXT("0.50"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ClampMin"), TEXT("0.0166"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ToolTip"), TEXT("Max time delta for each discrete simulation step.\nLowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationIterations, bForceSubStepping"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("UIMax"), TEXT("0.50"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("UIMin"), TEXT("0.0166"));
				MetaData->SetValue(NewProp_OnResetDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_OnResetDelegate, TEXT("ToolTip"), TEXT("Called when InterpTo reached the end and reset back to start ."));
				MetaData->SetValue(NewProp_OnWaitEndDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_OnWaitEndDelegate, TEXT("ToolTip"), TEXT("Called when InterpTo has resumed following a stop."));
				MetaData->SetValue(NewProp_OnWaitBeginDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_OnWaitBeginDelegate, TEXT("ToolTip"), TEXT("Called when InterpTo has come to a stop but will resume when possible."));
				MetaData->SetValue(NewProp_OnInterpToStop, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_OnInterpToStop, TEXT("ToolTip"), TEXT("Called when InterpTo has come to a stop."));
				MetaData->SetValue(NewProp_OnInterpToReverse, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_OnInterpToReverse, TEXT("ToolTip"), TEXT("Called when InterpTo impacts something and reverse is enabled."));
				MetaData->SetValue(NewProp_bForceSubStepping, TEXT("Category"), TEXT("Simulation"));
				MetaData->SetValue(NewProp_bForceSubStepping, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_bForceSubStepping, TEXT("ToolTip"), TEXT("If true, forces sub-stepping to break up movement into discrete smaller steps to improve accuracy of the trajectory.\nObjects that move in a straight line typically do *not* need to set this, as movement always uses continuous collision detection (sweeps) so collision is not missed.\nSub-stepping is automatically enabled when under the effects of gravity or when homing towards a target.\n@see MaxSimulationTimeStep, MaxSimulationIterations"));
				MetaData->SetValue(NewProp_BehaviourType, TEXT("Category"), TEXT("Behaviour"));
				MetaData->SetValue(NewProp_BehaviourType, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_BehaviourType, TEXT("ToolTip"), TEXT("Movement behaviour of the component"));
				MetaData->SetValue(NewProp_bPauseOnImpact, TEXT("Category"), TEXT("Behaviour"));
				MetaData->SetValue(NewProp_bPauseOnImpact, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_bPauseOnImpact, TEXT("ToolTip"), TEXT("If true, will pause movement on impact. If false it will behave as if the end of the movement range was reached based on the BehaviourType."));
				MetaData->SetValue(NewProp_Duration, TEXT("Category"), TEXT("Control"));
				MetaData->SetValue(NewProp_Duration, TEXT("ClampMin"), TEXT("0.100000"));
				MetaData->SetValue(NewProp_Duration, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InterpToMovementComponent.h"));
				MetaData->SetValue(NewProp_Duration, TEXT("ToolTip"), TEXT("How long to take to move from the first point to the last (or vice versa)"));
				MetaData->SetValue(NewProp_Duration, TEXT("UIMin"), TEXT("0.100000"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UInterpToMovementComponent(Z_Construct_UClass_UInterpToMovementComponent, TEXT("UInterpToMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UInterpToMovementComponent);
	UClass* Z_Construct_UClass_UBlueprintFunctionLibrary_NoRegister()
	{
		return UBlueprintFunctionLibrary::StaticClass();
	}
	UClass* Z_Construct_UClass_UBlueprintFunctionLibrary()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = UBlueprintFunctionLibrary::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20080081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Kismet/BlueprintFunctionLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Kismet/BlueprintFunctionLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("This class is a base class for any function libraries exposed to blueprints.\nMethods in subclasses are expected to be static, and no methods should be added to this base class."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBlueprintFunctionLibrary(Z_Construct_UClass_UBlueprintFunctionLibrary, TEXT("UBlueprintFunctionLibrary"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBlueprintFunctionLibrary);
	UFunction* Z_Construct_UDelegateFunction_Engine_OnNavDataGenerigEvent__DelegateSignature()
	{
		struct _Script_Engine_eventOnNavDataGenerigEvent_Parms
		{
			ANavigationData* NavData;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnNavDataGenerigEvent__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventOnNavDataGenerigEvent_Parms));
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, _Script_Engine_eventOnNavDataGenerigEvent_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate to let interested parties know that Nav Data has been registered"));
#endif
		}
		return ReturnFunction;
	}
	UEnum* Z_Construct_UEnum_Engine_FNavigationSystemRunMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_FNavigationSystemRunMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("FNavigationSystemRunMode"), 0, Get_Z_Construct_UEnum_Engine_FNavigationSystemRunMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FNavigationSystemRunMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FNavigationSystemRunMode::InvalidMode")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FNavigationSystemRunMode::GameMode")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FNavigationSystemRunMode::EditorMode")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FNavigationSystemRunMode::SimulationMode")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FNavigationSystemRunMode::PIEMode")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FNavigationSystemRunMode::FNavigationSystemRunMode_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_FNavigationSystemRunMode_CRC() { return 512934495U; }
	UFunction* Z_Construct_UFunction_UNavigationSystem_FindPathToActorSynchronously()
	{
		struct NavigationSystem_eventFindPathToActorSynchronously_Parms
		{
			UObject* WorldContext;
			FVector PathStart;
			AActor* GoalActor;
			float TetherDistance;
			AActor* PathfindingContext;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			UNavigationPath* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FindPathToActorSynchronously"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C22401, 65535, sizeof(NavigationSystem_eventFindPathToActorSynchronously_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0000000000000580, Z_Construct_UClass_UNavigationPath_NoRegister());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_PathfindingContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathfindingContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PathfindingContext, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_TetherDistance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TetherDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TetherDistance, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0000000000000080);
			UProperty* NewProp_GoalActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GoalActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(GoalActor, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_PathStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathStart, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventFindPathToActorSynchronously_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_TetherDistance"), TEXT("50.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("DefaultToSelf"), TEXT("WorldContext"));
			MetaData->SetValue(ReturnFunction, TEXT("HidePin"), TEXT("WorldContext"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Finds path instantly, in a FindPath Synchronously. Main advantage over FindPathToLocationSynchronously is that\n    the resulting path with automatically get updated if goal actor moves more then TetherDistance away from last path node\n    @param PathfindingContext could be one of following: NavigationData (like Navmesh actor), Pawn or Controller. This parameter determines parameters of specific pathfinding query"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_FindPathToLocationSynchronously()
	{
		struct NavigationSystem_eventFindPathToLocationSynchronously_Parms
		{
			UObject* WorldContext;
			FVector PathStart;
			FVector PathEnd;
			AActor* PathfindingContext;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			UNavigationPath* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FindPathToLocationSynchronously"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C22401, 65535, sizeof(NavigationSystem_eventFindPathToLocationSynchronously_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventFindPathToLocationSynchronously_Parms), 0x0000000000000580, Z_Construct_UClass_UNavigationPath_NoRegister());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventFindPathToLocationSynchronously_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_PathfindingContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathfindingContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PathfindingContext, NavigationSystem_eventFindPathToLocationSynchronously_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_PathEnd = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathEnd"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathEnd, NavigationSystem_eventFindPathToLocationSynchronously_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PathStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathStart, NavigationSystem_eventFindPathToLocationSynchronously_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventFindPathToLocationSynchronously_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("DefaultToSelf"), TEXT("WorldContext"));
			MetaData->SetValue(ReturnFunction, TEXT("HidePin"), TEXT("WorldContext"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Finds path instantly, in a FindPath Synchronously.\n    @param PathfindingContext could be one of following: NavigationData (like Navmesh actor), Pawn or Controller. This parameter determines parameters of specific pathfinding query"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetNavigationSystem()
	{
		struct NavigationSystem_eventGetNavigationSystem_Parms
		{
			UObject* WorldContext;
			UNavigationSystem* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetNavigationSystem"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(NavigationSystem_eventGetNavigationSystem_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetNavigationSystem_Parms), 0x0000000000000580, Z_Construct_UClass_UNavigationSystem_NoRegister());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetNavigationSystem_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Blueprint functions"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetPathCost()
	{
		struct NavigationSystem_eventGetPathCost_Parms
		{
			UObject* WorldContext;
			FVector PathStart;
			FVector PathEnd;
			float PathCost;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			TEnumAsByte<ENavigationQueryResult::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPathCost"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(NavigationSystem_eventGetPathCost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetPathCost_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_ENavigationQueryResult());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventGetPathCost_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventGetPathCost_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_PathCost = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathCost"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PathCost, NavigationSystem_eventGetPathCost_Parms), 0x0000000000000180);
			UProperty* NewProp_PathEnd = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathEnd"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathEnd, NavigationSystem_eventGetPathCost_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PathStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathStart, NavigationSystem_eventGetPathCost_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetPathCost_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Potentially expensive. Use with caution. Consider using UPathFollowingComponent::GetRemainingPathCost instead"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetPathLength()
	{
		struct NavigationSystem_eventGetPathLength_Parms
		{
			UObject* WorldContext;
			FVector PathStart;
			FVector PathEnd;
			float PathLength;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			TEnumAsByte<ENavigationQueryResult::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPathLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(NavigationSystem_eventGetPathLength_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetPathLength_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_ENavigationQueryResult());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventGetPathLength_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventGetPathLength_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_PathLength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PathLength, NavigationSystem_eventGetPathLength_Parms), 0x0000000000000180);
			UProperty* NewProp_PathEnd = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathEnd"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathEnd, NavigationSystem_eventGetPathLength_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_PathStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PathStart, NavigationSystem_eventGetPathLength_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetPathLength_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Potentially expensive. Use with caution"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomPoint()
	{
		struct NavigationSystem_eventGetRandomPoint_Parms
		{
			UObject* WorldContext;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRandomPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14822401, 65535, sizeof(NavigationSystem_eventGetRandomPoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetRandomPoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventGetRandomPoint_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventGetRandomPoint_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetRandomPoint_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedMessage"), TEXT("GetRandomPoint is deprecated. Use either GetRandomReachablePointInRadius or GetRandomPointInNavigableSpace"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomPointInNavigableRadius()
	{
		struct NavigationSystem_eventGetRandomPointInNavigableRadius_Parms
		{
			UObject* WorldContext;
			FVector Origin;
			float Radius;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRandomPointInNavigableRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(NavigationSystem_eventGetRandomPointInNavigableRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetRandomPointInNavigableRadius_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventGetRandomPointInNavigableRadius_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventGetRandomPointInNavigableRadius_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, NavigationSystem_eventGetRandomPointInNavigableRadius_Parms), 0x0000000000000080);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Origin, NavigationSystem_eventGetRandomPointInNavigableRadius_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetRandomPointInNavigableRadius_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomPointInRadius()
	{
		struct NavigationSystem_eventGetRandomPointInRadius_Parms
		{
			UObject* WorldContext;
			FVector Origin;
			float Radius;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRandomPointInRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(NavigationSystem_eventGetRandomPointInRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetRandomPointInRadius_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventGetRandomPointInRadius_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventGetRandomPointInRadius_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, NavigationSystem_eventGetRandomPointInRadius_Parms), 0x0000000000000080);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Origin, NavigationSystem_eventGetRandomPointInRadius_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetRandomPointInRadius_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedMessage"), TEXT("GetRandomPointInRadius is deprecated. Use either GetRandomReachablePointInRadius or GetRandomPointInNavigableSpace"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_GetRandomReachablePointInRadius()
	{
		struct NavigationSystem_eventGetRandomReachablePointInRadius_Parms
		{
			UObject* WorldContext;
			FVector Origin;
			float Radius;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetRandomReachablePointInRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(NavigationSystem_eventGetRandomReachablePointInRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventGetRandomReachablePointInRadius_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventGetRandomReachablePointInRadius_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventGetRandomReachablePointInRadius_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, NavigationSystem_eventGetRandomReachablePointInRadius_Parms), 0x0000000000000080);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Origin, NavigationSystem_eventGetRandomReachablePointInRadius_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventGetRandomReachablePointInRadius_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_IsNavigationBeingBuilt()
	{
		struct NavigationSystem_eventIsNavigationBeingBuilt_Parms
		{
			UObject* WorldContext;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsNavigationBeingBuilt"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(NavigationSystem_eventIsNavigationBeingBuilt_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavigationSystem_eventIsNavigationBeingBuilt_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavigationSystem_eventIsNavigationBeingBuilt_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavigationSystem_eventIsNavigationBeingBuilt_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventIsNavigationBeingBuilt_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_NavigationRaycast()
	{
		struct NavigationSystem_eventNavigationRaycast_Parms
		{
			UObject* WorldContext;
			FVector RayStart;
			FVector RayEnd;
			FVector HitLocation;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			AController* Querier;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NavigationRaycast"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C22401, 65535, sizeof(NavigationSystem_eventNavigationRaycast_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavigationSystem_eventNavigationRaycast_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavigationSystem_eventNavigationRaycast_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavigationSystem_eventNavigationRaycast_Parms), sizeof(bool), true);
			UProperty* NewProp_Querier = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Querier"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Querier, NavigationSystem_eventNavigationRaycast_Parms), 0x0000000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventNavigationRaycast_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_HitLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitLocation, NavigationSystem_eventNavigationRaycast_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_RayEnd = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("RayEnd"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RayEnd, NavigationSystem_eventNavigationRaycast_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_RayStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("RayStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RayStart, NavigationSystem_eventNavigationRaycast_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventNavigationRaycast_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Performs navigation raycast on NavigationData appropriate for given Querier.\n    @param Querier if not passed default navigation data will be used\n    @param HitLocation if line was obstructed this will be set to hit location. Otherwise it contains SegmentEnd\n    @return true if line from RayStart to RayEnd was obstructed. Also, true when no navigation data present"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_OnNavigationBoundsUpdated()
	{
		struct NavigationSystem_eventOnNavigationBoundsUpdated_Parms
		{
			ANavMeshBoundsVolume* NavVolume;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnNavigationBoundsUpdated"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(NavigationSystem_eventOnNavigationBoundsUpdated_Parms));
			UProperty* NewProp_NavVolume = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavVolume"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavVolume, NavigationSystem_eventOnNavigationBoundsUpdated_Parms), 0x0000000000000080, Z_Construct_UClass_ANavMeshBoundsVolume_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@todo document"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_ProjectPointToNavigation()
	{
		struct NavigationSystem_eventProjectPointToNavigation_Parms
		{
			UObject* WorldContext;
			FVector Point;
			ANavigationData* NavData;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			FVector QueryExtent;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ProjectPointToNavigation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(NavigationSystem_eventProjectPointToNavigation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, NavigationSystem_eventProjectPointToNavigation_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_QueryExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("QueryExtent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(QueryExtent, NavigationSystem_eventProjectPointToNavigation_Parms), 0x0000000000000082, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(FilterClass, NavigationSystem_eventProjectPointToNavigation_Parms), 0x0004000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister());
			UProperty* NewProp_NavData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NavData, NavigationSystem_eventProjectPointToNavigation_Parms), 0x0000000000000080, Z_Construct_UClass_ANavigationData_NoRegister());
			UProperty* NewProp_Point = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Point"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Point, NavigationSystem_eventProjectPointToNavigation_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldContext = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContext"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContext, NavigationSystem_eventProjectPointToNavigation_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Project a point onto the NavigationData"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContext"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_RegisterNavigationInvoker()
	{
		struct NavigationSystem_eventRegisterNavigationInvoker_Parms
		{
			AActor* Invoker;
			float TileGenerationRadius;
			float TileRemovalRadius;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RegisterNavigationInvoker"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(NavigationSystem_eventRegisterNavigationInvoker_Parms));
			UProperty* NewProp_TileRemovalRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TileRemovalRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TileRemovalRadius, NavigationSystem_eventRegisterNavigationInvoker_Parms), 0x0000000000000080);
			UProperty* NewProp_TileGenerationRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TileGenerationRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TileGenerationRadius, NavigationSystem_eventRegisterNavigationInvoker_Parms), 0x0000000000000080);
			UProperty* NewProp_Invoker = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Invoker"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Invoker, NavigationSystem_eventRegisterNavigationInvoker_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_TileGenerationRadius"), TEXT("3000.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_TileRemovalRadius"), TEXT("5000.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Registers given actor as a \"navigation enforcer\" which means navigation system will\n    make sure navigation is being generated in specified radius around it.\n    @note: you need NavigationSystem's GenerateNavigationOnlyAroundNavigationInvokers to be set to true\n            to take advantage of this feature"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_ResetMaxSimultaneousTileGenerationJobsCount()
	{
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ResetMaxSimultaneousTileGenerationJobsCount"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Brings limit of simultaneous navmesh tile generation jobs back to Project Setting's default value"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_SetGeometryGatheringMode()
	{
		struct NavigationSystem_eventSetGeometryGatheringMode_Parms
		{
			TEnumAsByte<ENavDataGatheringModeConfig> NewMode;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGeometryGatheringMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(NavigationSystem_eventSetGeometryGatheringMode_Parms));
			UProperty* NewProp_NewMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewMode, NavigationSystem_eventSetGeometryGatheringMode_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ENavDataGatheringModeConfig());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation|Generation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_SetMaxSimultaneousTileGenerationJobsCount()
	{
		struct NavigationSystem_eventSetMaxSimultaneousTileGenerationJobsCount_Parms
		{
			int32 MaxNumberOfJobs;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMaxSimultaneousTileGenerationJobsCount"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(NavigationSystem_eventSetMaxSimultaneousTileGenerationJobsCount_Parms));
			UProperty* NewProp_MaxNumberOfJobs = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxNumberOfJobs"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxNumberOfJobs, NavigationSystem_eventSetMaxSimultaneousTileGenerationJobsCount_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("will limit the number of simultaneously running navmesh tile generation jobs to specified number.\n    @param MaxNumberOfJobs gets trimmed to be at least 1. You cannot use this function to pause navmesh generation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_SimpleMoveToActor()
	{
		struct NavigationSystem_eventSimpleMoveToActor_Parms
		{
			AController* Controller;
			const AActor* Goal;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimpleMoveToActor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(NavigationSystem_eventSimpleMoveToActor_Parms));
			UProperty* NewProp_Goal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Goal"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Goal, NavigationSystem_eventSimpleMoveToActor_Parms), 0x0000000000000082, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_Controller = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Controller"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Controller, NavigationSystem_eventSimpleMoveToActor_Parms), 0x0000000000000080, Z_Construct_UClass_AController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_SimpleMoveToLocation()
	{
		struct NavigationSystem_eventSimpleMoveToLocation_Parms
		{
			AController* Controller;
			FVector Goal;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimpleMoveToLocation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C22401, 65535, sizeof(NavigationSystem_eventSimpleMoveToLocation_Parms));
			UProperty* NewProp_Goal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Goal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Goal, NavigationSystem_eventSimpleMoveToLocation_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Controller = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Controller"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Controller, NavigationSystem_eventSimpleMoveToLocation_Parms), 0x0000000000000080, Z_Construct_UClass_AController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavigationSystem_UnregisterNavigationInvoker()
	{
		struct NavigationSystem_eventUnregisterNavigationInvoker_Parms
		{
			AActor* Invoker;
		};
		UObject* Outer=Z_Construct_UClass_UNavigationSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UnregisterNavigationInvoker"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(NavigationSystem_eventUnregisterNavigationInvoker_Parms));
			UProperty* NewProp_Invoker = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Invoker"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Invoker, NavigationSystem_eventUnregisterNavigationInvoker_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Removes given actor from the list of active navigation enforcers.\n    @see RegisterNavigationInvoker for more details"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UNavigationSystem_NoRegister()
	{
		return UNavigationSystem::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavigationSystem()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UBlueprintFunctionLibrary();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavigationSystem::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900086;

				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_FindPathToActorSynchronously());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_FindPathToLocationSynchronously());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetNavigationSystem());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetPathCost());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetPathLength());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetRandomPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetRandomPointInNavigableRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetRandomPointInRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_GetRandomReachablePointInRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_IsNavigationBeingBuilt());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_NavigationRaycast());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_OnNavigationBoundsUpdated());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_ProjectPointToNavigation());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_RegisterNavigationInvoker());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_ResetMaxSimultaneousTileGenerationJobsCount());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_SetGeometryGatheringMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_SetMaxSimultaneousTileGenerationJobsCount());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_SimpleMoveToActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_SimpleMoveToLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavigationSystem_UnregisterNavigationInvoker());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OperationMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OperationMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(OperationMode, UNavigationSystem), 0x0000080000000000, Z_Construct_UEnum_Engine_FNavigationSystemRunMode());
				UProperty* NewProp_OnNavigationGenerationFinishedDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnNavigationGenerationFinishedDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnNavigationGenerationFinishedDelegate, UNavigationSystem), 0x0000000010082000, Z_Construct_UDelegateFunction_Engine_OnNavDataGenerigEvent__DelegateSignature());
				UProperty* NewProp_OnNavDataRegisteredEvent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnNavDataRegisteredEvent"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnNavDataRegisteredEvent, UNavigationSystem), 0x0000000000082000, Z_Construct_UDelegateFunction_Engine_OnNavDataGenerigEvent__DelegateSignature());
				UProperty* NewProp_NavDataRegistrationQueue = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavDataRegistrationQueue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(NavDataRegistrationQueue, UNavigationSystem), 0x0000000000002000);
				UProperty* NewProp_NavDataRegistrationQueue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_NavDataRegistrationQueue, TEXT("NavDataRegistrationQueue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_ANavigationData_NoRegister());
				UProperty* NewProp_NavDataSet = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavDataSet"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(NavDataSet, UNavigationSystem), 0x0000000000000000);
				UProperty* NewProp_NavDataSet_Inner = new(EC_InternalUseOnlyConstructor, NewProp_NavDataSet, TEXT("NavDataSet"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_ANavigationData_NoRegister());
				UProperty* NewProp_DirtyAreasUpdateFreq = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DirtyAreasUpdateFreq"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DirtyAreasUpdateFreq, UNavigationSystem), 0x0000000000004001);
				UProperty* NewProp_SupportedAgents = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SupportedAgents"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SupportedAgents, UNavigationSystem), 0x0000080000004001);
				UProperty* NewProp_SupportedAgents_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SupportedAgents, TEXT("SupportedAgents"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000004000, Z_Construct_UScriptStruct_FNavDataConfig());
				UProperty* NewProp_ActiveTilesUpdateInterval = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActiveTilesUpdateInterval"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ActiveTilesUpdateInterval, UNavigationSystem), 0x0000080000004001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGenerateNavigationOnlyAroundNavigationInvokers, UNavigationSystem, uint8);
				UProperty* NewProp_bGenerateNavigationOnlyAroundNavigationInvokers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bGenerateNavigationOnlyAroundNavigationInvokers"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGenerateNavigationOnlyAroundNavigationInvokers, UNavigationSystem), 0x0000080000014001, CPP_BOOL_PROPERTY_BITMASK(bGenerateNavigationOnlyAroundNavigationInvokers, UNavigationSystem), sizeof(uint8), false);
				UProperty* NewProp_DataGatheringMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DataGatheringMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DataGatheringMode, UNavigationSystem), 0x0000080000014001, Z_Construct_UEnum_Engine_ENavDataGatheringModeConfig());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipAgentHeightCheckWhenPickingNavData, UNavigationSystem, uint8);
				UProperty* NewProp_bSkipAgentHeightCheckWhenPickingNavData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSkipAgentHeightCheckWhenPickingNavData"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipAgentHeightCheckWhenPickingNavData, UNavigationSystem), 0x0000000000004001, CPP_BOOL_PROPERTY_BITMASK(bSkipAgentHeightCheckWhenPickingNavData, UNavigationSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInitialBuildingLocked, UNavigationSystem, uint8);
				UProperty* NewProp_bInitialBuildingLocked = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInitialBuildingLocked"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInitialBuildingLocked, UNavigationSystem), 0x0000000000004001, CPP_BOOL_PROPERTY_BITMASK(bInitialBuildingLocked, UNavigationSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSupportRebuilding, UNavigationSystem, uint8);
				UProperty* NewProp_bSupportRebuilding = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSupportRebuilding"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSupportRebuilding, UNavigationSystem), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bSupportRebuilding, UNavigationSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowClientSideNavigation, UNavigationSystem, uint8);
				UProperty* NewProp_bAllowClientSideNavigation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowClientSideNavigation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowClientSideNavigation, UNavigationSystem), 0x0000080000004001, CPP_BOOL_PROPERTY_BITMASK(bAllowClientSideNavigation, UNavigationSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoCreateNavigationData, UNavigationSystem, uint8);
				UProperty* NewProp_bAutoCreateNavigationData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutoCreateNavigationData"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoCreateNavigationData, UNavigationSystem), 0x0000080000004001, CPP_BOOL_PROPERTY_BITMASK(bAutoCreateNavigationData, UNavigationSystem), sizeof(uint8), false);
				UProperty* NewProp_AbstractNavData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AbstractNavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AbstractNavData, UNavigationSystem), 0x0000000000000000, Z_Construct_UClass_ANavigationData_NoRegister());
				UProperty* NewProp_MainNavData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MainNavData"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(MainNavData, UNavigationSystem), 0x0000000000000000, Z_Construct_UClass_ANavigationData_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_FindPathToActorSynchronously()); // 3728313135
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_FindPathToLocationSynchronously()); // 3493770142
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetNavigationSystem()); // 3949941946
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetPathCost()); // 1325451700
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetPathLength()); // 201360946
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetRandomPoint()); // 3381671763
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetRandomPointInNavigableRadius()); // 2203915261
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetRandomPointInRadius()); // 1161562740
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_GetRandomReachablePointInRadius()); // 1342761653
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_IsNavigationBeingBuilt()); // 2989128315
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_NavigationRaycast()); // 2299656655
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_OnNavigationBoundsUpdated()); // 581653350
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_ProjectPointToNavigation()); // 2447738472
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_RegisterNavigationInvoker()); // 1395855462
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_ResetMaxSimultaneousTileGenerationJobsCount()); // 3105387603
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_SetGeometryGatheringMode()); // 1593726141
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_SetMaxSimultaneousTileGenerationJobsCount()); // 1655158000
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_SimpleMoveToActor()); // 544747673
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_SimpleMoveToLocation()); // 3237368277
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavigationSystem_UnregisterNavigationInvoker()); // 2838757348
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_OperationMode, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_OnNavigationGenerationFinishedDelegate, TEXT("displayname"), TEXT("OnNavigationGenerationFinished"));
				MetaData->SetValue(NewProp_OnNavigationGenerationFinishedDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_OnNavDataRegisteredEvent, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_OnNavDataRegisteredEvent, TEXT("ToolTip"), TEXT("BlueprintAssignable,"));
				MetaData->SetValue(NewProp_NavDataRegistrationQueue, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_NavDataSet, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_DirtyAreasUpdateFreq, TEXT("Category"), TEXT("NavigationSystem"));
				MetaData->SetValue(NewProp_DirtyAreasUpdateFreq, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_DirtyAreasUpdateFreq, TEXT("ToolTip"), TEXT("update frequency for dirty areas on navmesh"));
				MetaData->SetValue(NewProp_SupportedAgents, TEXT("Category"), TEXT("Agents"));
				MetaData->SetValue(NewProp_SupportedAgents, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_ActiveTilesUpdateInterval, TEXT("Category"), TEXT("Navigation Enforcing"));
				MetaData->SetValue(NewProp_ActiveTilesUpdateInterval, TEXT("ClampMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_ActiveTilesUpdateInterval, TEXT("EditCondition"), TEXT("bGenerateNavigationOnlyAroundNavigationInvokers"));
				MetaData->SetValue(NewProp_ActiveTilesUpdateInterval, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_ActiveTilesUpdateInterval, TEXT("ToolTip"), TEXT("Minimal time, in seconds, between active tiles set update"));
				MetaData->SetValue(NewProp_ActiveTilesUpdateInterval, TEXT("UIMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_bGenerateNavigationOnlyAroundNavigationInvokers, TEXT("Category"), TEXT("Navigation Enforcing"));
				MetaData->SetValue(NewProp_bGenerateNavigationOnlyAroundNavigationInvokers, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bGenerateNavigationOnlyAroundNavigationInvokers, TEXT("ToolTip"), TEXT("If set to true navigation will be generated only around registered \"navigation enforcers\"\n     This has a range of consequences (including how navigation octree operates) so it needs to\n     be a conscious decision.\n     Once enabled results in whole world being navigable.\n     @see RegisterNavigationInvoker"));
				MetaData->SetValue(NewProp_DataGatheringMode, TEXT("Category"), TEXT("NavigationSystem"));
				MetaData->SetValue(NewProp_DataGatheringMode, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bSkipAgentHeightCheckWhenPickingNavData, TEXT("Category"), TEXT("NavigationSystem"));
				MetaData->SetValue(NewProp_bSkipAgentHeightCheckWhenPickingNavData, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bSkipAgentHeightCheckWhenPickingNavData, TEXT("ToolTip"), TEXT("false by default, if set to true will result in not caring about nav agent height\n    when trying to match navigation data to passed in nav agent"));
				MetaData->SetValue(NewProp_bInitialBuildingLocked, TEXT("Category"), TEXT("NavigationSystem"));
				MetaData->SetValue(NewProp_bInitialBuildingLocked, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bInitialBuildingLocked, TEXT("ToolTip"), TEXT("if set to true will result navigation system not rebuild navigation until\n    a call to ReleaseInitialBuildingLock() is called. Does not influence\n    editor-time generation (i.e. does influence PIE and Game).\n    Defaults to false."));
				MetaData->SetValue(NewProp_bSupportRebuilding, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bSupportRebuilding, TEXT("ToolTip"), TEXT("gets set to true if gathering navigation data (like in navoctree) is required due to the need of navigation generation\n    Is always true in Editor Mode. In other modes it depends on bRebuildAtRuntime of every required NavigationData class' CDO"));
				MetaData->SetValue(NewProp_bAllowClientSideNavigation, TEXT("Category"), TEXT("NavigationSystem"));
				MetaData->SetValue(NewProp_bAllowClientSideNavigation, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bAutoCreateNavigationData, TEXT("Category"), TEXT("NavigationSystem"));
				MetaData->SetValue(NewProp_bAutoCreateNavigationData, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_bAutoCreateNavigationData, TEXT("ToolTip"), TEXT("Should navigation system spawn default Navigation Data when there's none and there are navigation bounds present?"));
				MetaData->SetValue(NewProp_AbstractNavData, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
				MetaData->SetValue(NewProp_AbstractNavData, TEXT("ToolTip"), TEXT("special navigation data for managing direct paths, not part of NavDataSet!"));
				MetaData->SetValue(NewProp_MainNavData, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationSystem.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavigationSystem(Z_Construct_UClass_UNavigationSystem, TEXT("UNavigationSystem"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavigationSystem);
	UFunction* Z_Construct_UFunction_UNavMovementComponent_IsCrouching()
	{
		struct NavMovementComponent_eventIsCrouching_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsCrouching"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(NavMovementComponent_eventIsCrouching_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavMovementComponent_eventIsCrouching_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavMovementComponent_eventIsCrouching_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavMovementComponent_eventIsCrouching_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Components|NavMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if currently crouching"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavMovementComponent_IsFalling()
	{
		struct NavMovementComponent_eventIsFalling_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsFalling"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(NavMovementComponent_eventIsFalling_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavMovementComponent_eventIsFalling_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavMovementComponent_eventIsFalling_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavMovementComponent_eventIsFalling_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Components|NavMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if currently falling (not flying, in a non-fluid volume, and not on the ground)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavMovementComponent_IsFlying()
	{
		struct NavMovementComponent_eventIsFlying_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsFlying"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(NavMovementComponent_eventIsFlying_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavMovementComponent_eventIsFlying_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavMovementComponent_eventIsFlying_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavMovementComponent_eventIsFlying_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Components|NavMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if currently flying (moving through a non-fluid volume without resting on the ground)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavMovementComponent_IsMovingOnGround()
	{
		struct NavMovementComponent_eventIsMovingOnGround_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsMovingOnGround"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(NavMovementComponent_eventIsMovingOnGround_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavMovementComponent_eventIsMovingOnGround_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavMovementComponent_eventIsMovingOnGround_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavMovementComponent_eventIsMovingOnGround_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Components|NavMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if currently moving on the ground (e.g. walking or driving)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavMovementComponent_IsSwimming()
	{
		struct NavMovementComponent_eventIsSwimming_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsSwimming"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(NavMovementComponent_eventIsSwimming_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, NavMovementComponent_eventIsSwimming_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, NavMovementComponent_eventIsSwimming_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, NavMovementComponent_eventIsSwimming_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Components|NavMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if currently swimming (moving through a fluid volume)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavMovementComponent_StopActiveMovement()
	{
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopActiveMovement"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops applying further movement (usually zeros acceleration)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UNavMovementComponent_StopMovementKeepPathing()
	{
		UObject* Outer=Z_Construct_UClass_UNavMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopMovementKeepPathing"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Movement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops movement immediately (reset velocity) but keeps following current path"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UNavMovementComponent_NoRegister()
	{
		return UNavMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_IsCrouching());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_IsFalling());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_IsFlying());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_IsMovingOnGround());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_IsSwimming());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_StopActiveMovement());
				OuterClass->LinkChild(Z_Construct_UFunction_UNavMovementComponent_StopMovementKeepPathing());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MovementState = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementState"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(MovementState, UNavMovementComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FMovementProperties());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateNavAgentWithOwnersCollision, UNavMovementComponent, uint8);
				UProperty* NewProp_bUpdateNavAgentWithOwnersCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUpdateNavAgentWithOwnersCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateNavAgentWithOwnersCollision, UNavMovementComponent), 0x0000080000000001, CPP_BOOL_PROPERTY_BITMASK(bUpdateNavAgentWithOwnersCollision, UNavMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_NavAgentProps = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavAgentProps"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NavAgentProps, UNavMovementComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FNavAgentProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_IsCrouching()); // 1621300318
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_IsFalling()); // 1200671826
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_IsFlying()); // 3192052727
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_IsMovingOnGround()); // 2606389218
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_IsSwimming()); // 2954229405
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_StopActiveMovement()); // 3007448961
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavMovementComponent_StopMovementKeepPathing()); // 2284477697
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/NavMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("NavMovementComponent defines base functionality for MovementComponents that move any 'agent' that may be involved in AI pathfinding."));
				MetaData->SetValue(NewProp_MovementState, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
				MetaData->SetValue(NewProp_MovementState, TEXT("ToolTip"), TEXT("Expresses runtime state of character's movement. Put all temporal changes to movement properties here"));
				MetaData->SetValue(NewProp_bUpdateNavAgentWithOwnersCollision, TEXT("Category"), TEXT("MovementComponent"));
				MetaData->SetValue(NewProp_bUpdateNavAgentWithOwnersCollision, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
				MetaData->SetValue(NewProp_bUpdateNavAgentWithOwnersCollision, TEXT("ToolTip"), TEXT("If set to true NavAgentProps' radius and height will be updated with Owner's collision capsule size"));
				MetaData->SetValue(NewProp_NavAgentProps, TEXT("Category"), TEXT("Movement Capabilities"));
				MetaData->SetValue(NewProp_NavAgentProps, TEXT("DisplayName"), TEXT("Movement Capabilities"));
				MetaData->SetValue(NewProp_NavAgentProps, TEXT("Keywords"), TEXT("Nav Agent"));
				MetaData->SetValue(NewProp_NavAgentProps, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/NavMovementComponent.h"));
				MetaData->SetValue(NewProp_NavAgentProps, TEXT("ToolTip"), TEXT("Properties that define how the component can move."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavMovementComponent(Z_Construct_UClass_UNavMovementComponent, TEXT("UNavMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavMovementComponent);
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_AddInputVector()
	{
		struct PawnMovementComponent_eventAddInputVector_Parms
		{
			FVector WorldVector;
			bool bForce;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddInputVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PawnMovementComponent_eventAddInputVector_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForce, PawnMovementComponent_eventAddInputVector_Parms, bool);
			UProperty* NewProp_bForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForce"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForce, PawnMovementComponent_eventAddInputVector_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bForce, PawnMovementComponent_eventAddInputVector_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldVector = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldVector"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WorldVector, PawnMovementComponent_eventAddInputVector_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bForce"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds the given vector to the accumulated input in world space. Input vectors are usually between 0 and 1 in magnitude.\nThey are accumulated during a frame then applied as acceleration during the movement update.\n\n@param WorldDirection        Direction in world space to apply input\n@param ScaleValue            Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value.\n@param bForce                        If true always add the input, ignoring the result of IsMoveInputIgnored().\n@see APawn::AddMovementInput()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_ConsumeInputVector()
	{
		struct PawnMovementComponent_eventConsumeInputVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConsumeInputVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(PawnMovementComponent_eventConsumeInputVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PawnMovementComponent_eventConsumeInputVector_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the pending input vector and resets it to zero.\n       * This should be used during a movement update (by the Pawn or PawnMovementComponent) to prevent accumulation of control input between frames.\n       * Copies the pending input vector to the saved input vector (GetLastMovementInputVector()).\n       * @return The pending input vector."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_GetLastInputVector()
	{
		struct PawnMovementComponent_eventGetLastInputVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLastInputVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(PawnMovementComponent_eventGetLastInputVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PawnMovementComponent_eventGetLastInputVector_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("GetInput"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return the last input vector in world space that was processed by ConsumeInputVector(), which is usually done by the Pawn or PawnMovementComponent.\nAny user that needs to know about the input that last affected movement should use this function.\n@return The last input vector in world space that was processed by ConsumeInputVector().\n@see AddInputVector(), ConsumeInputVector(), GetPendingInputVector()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_GetPawnOwner()
	{
		struct PawnMovementComponent_eventGetPawnOwner_Parms
		{
			APawn* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPawnOwner"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(PawnMovementComponent_eventGetPawnOwner_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, PawnMovementComponent_eventGetPawnOwner_Parms), 0x0000000000000580, Z_Construct_UClass_APawn_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return the Pawn that owns UpdatedComponent."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_GetPendingInputVector()
	{
		struct PawnMovementComponent_eventGetPendingInputVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPendingInputVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(PawnMovementComponent_eventGetPendingInputVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PawnMovementComponent_eventGetPendingInputVector_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("GetInput"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return the pending input vector in world space. This is the most up-to-date value of the input vector, pending ConsumeMovementInputVector() which clears it.\nPawnMovementComponents implementing movement usually want to use either this or ConsumeInputVector() as these functions represent the most recent state of input.\n@return The pending input vector in world space.\n@see AddInputVector(), ConsumeInputVector(), GetLastInputVector()"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_IsMoveInputIgnored()
	{
		struct PawnMovementComponent_eventIsMoveInputIgnored_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsMoveInputIgnored"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(PawnMovementComponent_eventIsMoveInputIgnored_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PawnMovementComponent_eventIsMoveInputIgnored_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PawnMovementComponent_eventIsMoveInputIgnored_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PawnMovementComponent_eventIsMoveInputIgnored_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Helper to see if move input is ignored. If there is no Pawn or UpdatedComponent, returns true, otherwise defers to the Pawn's implementation of IsMoveInputIgnored()."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPawnMovementComponent_K2_GetInputVector()
	{
		struct PawnMovementComponent_eventK2_GetInputVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPawnMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_GetInputVector"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(PawnMovementComponent_eventK2_GetInputVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PawnMovementComponent_eventK2_GetInputVector_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|PawnMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("GetInputVector has been deprecated, use either GetPendingInputVector or GetLastInputVector"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetInputVector"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("(Deprecated) Return the input vector in world space."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPawnMovementComponent_NoRegister()
	{
		return UPawnMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPawnMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UNavMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPawnMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_AddInputVector());
				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_ConsumeInputVector());
				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_GetLastInputVector());
				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_GetPawnOwner());
				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_GetPendingInputVector());
				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_IsMoveInputIgnored());
				OuterClass->LinkChild(Z_Construct_UFunction_UPawnMovementComponent_K2_GetInputVector());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PawnOwner = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PawnOwner"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PawnOwner, UPawnMovementComponent), 0x0000080000000000, Z_Construct_UClass_APawn_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_AddInputVector()); // 1531118124
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_ConsumeInputVector()); // 1019129211
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_GetLastInputVector()); // 1792942172
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_GetPawnOwner()); // 948483646
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_GetPendingInputVector()); // 615550816
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_IsMoveInputIgnored()); // 352431978
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnMovementComponent_K2_GetInputVector()); // 3087132684
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/PawnMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("PawnMovementComponent can be used to update movement for an associated Pawn.\nIt also provides ways to accumulate and read directional input in a generic way (with AddInputVector(), ConsumeInputVector(), etc).\n@see APawn"));
				MetaData->SetValue(NewProp_PawnOwner, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/PawnMovementComponent.h"));
				MetaData->SetValue(NewProp_PawnOwner, TEXT("ToolTip"), TEXT("Pawn that owns this component."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPawnMovementComponent(Z_Construct_UClass_UPawnMovementComponent, TEXT("UPawnMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPawnMovementComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FNavAvoidanceMask()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FNavAvoidanceMask_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("NavAvoidanceMask"), sizeof(FNavAvoidanceMask), Get_Z_Construct_UScriptStruct_FNavAvoidanceMask_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NavAvoidanceMask"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FNavAvoidanceMask>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup31, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup31 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup31"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup31, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup31, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup30, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup30 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup30"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup30, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup30, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup29, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup29 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup29"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup29, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup29, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup28, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup28 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup28"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup28, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup28, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup27, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup27 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup27"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup27, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup27, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup26, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup26 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup26"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup26, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup26, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup25, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup25 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup25"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup25, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup25, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup24, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup24 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup24"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup24, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup24, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup23, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup23 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup23"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup23, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup23, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup22, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup22 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup22"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup22, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup22, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup21, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup21 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup21"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup21, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup21, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup20, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup20 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup20"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup20, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup20, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup19, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup19 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup19"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup19, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup19, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup18, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup18 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup18"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup18, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup18, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup17, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup17 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup17"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup17, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup17, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup16, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup16 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup16"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup16, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup16, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup15, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup15 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup15"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup15, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup15, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup14, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup14 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup14"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup14, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup14, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup13, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup13 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup13"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup13, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup13, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup12, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup12 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup12"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup12, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup12, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup11, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup11 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup11"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup11, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup11, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup10, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup10 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup10"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup10, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup10, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup9, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup9 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup9"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup9, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup9, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup8, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup8 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup8"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup8, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup8, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup7, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup7 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup7"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup7, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup7, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup6, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup6 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup6"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup6, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup6, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup5, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup5 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup5"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup5, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup5, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup4, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup4 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup4"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup4, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup4, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup3, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup3 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup3"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup3, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup3, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup2, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup2"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup2, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup2, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup1, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup1"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup1, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup1, FNavAvoidanceMask), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGroup0, FNavAvoidanceMask, uint8);
			UProperty* NewProp_bGroup0 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bGroup0"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGroup0, FNavAvoidanceMask), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bGroup0, FNavAvoidanceMask), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup31, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup31, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup30, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup30, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup29, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup29, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup28, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup28, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup27, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup27, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup26, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup26, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup25, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup25, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup24, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup24, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup23, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup23, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup22, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup22, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup21, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup21, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup20, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup20, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup19, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup19, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup18, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup18, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup17, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup17, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup16, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup16, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup15, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup15, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup14, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup14, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup13, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup13, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup12, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup12, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup11, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup11, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup10, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup10, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup9, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup9, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup8, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup8, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup7, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup7, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup6, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup6, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup5, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup5, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup4, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup4, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup3, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup3, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup2, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup2, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup1, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup1, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
			MetaData->SetValue(NewProp_bGroup0, TEXT("Category"), TEXT("Group"));
			MetaData->SetValue(NewProp_bGroup0, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationAvoidanceTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FNavAvoidanceMask_CRC() { return 900373836U; }
	UClass* Z_Construct_UClass_URVOAvoidanceInterface_NoRegister()
	{
		return URVOAvoidanceInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_URVOAvoidanceInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Engine();
			OuterClass = URVOAvoidanceInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20084081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("CannotImplementInterfaceInBlueprint"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_URVOAvoidanceInterface(Z_Construct_UClass_URVOAvoidanceInterface, TEXT("URVOAvoidanceInterface"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(URVOAvoidanceInterface);
	UClass* Z_Construct_UClass_UNetworkPredictionInterface_NoRegister()
	{
		return UNetworkPredictionInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UNetworkPredictionInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Engine();
			OuterClass = UNetworkPredictionInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20084081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("CannotImplementInterfaceInBlueprint"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNetworkPredictionInterface(Z_Construct_UClass_UNetworkPredictionInterface, TEXT("UNetworkPredictionInterface"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNetworkPredictionInterface);
	UScriptStruct* Z_Construct_UScriptStruct_FCharacterMovementComponentPreClothTickFunction()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FCharacterMovementComponentPreClothTickFunction_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("CharacterMovementComponentPreClothTickFunction"), sizeof(FCharacterMovementComponentPreClothTickFunction), Get_Z_Construct_UScriptStruct_FCharacterMovementComponentPreClothTickFunction_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CharacterMovementComponentPreClothTickFunction"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FTickFunction(), new UScriptStruct::TCppStructOps<FCharacterMovementComponentPreClothTickFunction>, EStructFlags(0x00000001));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Tick function that calls UCharacterMovementComponent::PreClothTick"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FCharacterMovementComponentPreClothTickFunction_CRC() { return 2785441473U; }
	UScriptStruct* Z_Construct_UScriptStruct_FFindFloorResult()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FFindFloorResult_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("FindFloorResult"), sizeof(FFindFloorResult), Get_Z_Construct_UScriptStruct_FFindFloorResult_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FindFloorResult"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FFindFloorResult>, EStructFlags(0x00000205));
			UProperty* NewProp_HitResult = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("HitResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitResult, FFindFloorResult), 0x0000008000020815, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_LineDist = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LineDist"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LineDist, FFindFloorResult), 0x0000000000020815);
			UProperty* NewProp_FloorDist = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloorDist"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FloorDist, FFindFloorResult), 0x0000000000020815);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLineTrace, FFindFloorResult, uint8);
			UProperty* NewProp_bLineTrace = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLineTrace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLineTrace, FFindFloorResult), 0x0000000000020815, CPP_BOOL_PROPERTY_BITMASK(bLineTrace, FFindFloorResult), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWalkableFloor, FFindFloorResult, uint8);
			UProperty* NewProp_bWalkableFloor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bWalkableFloor"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWalkableFloor, FFindFloorResult), 0x0000000000020815, CPP_BOOL_PROPERTY_BITMASK(bWalkableFloor, FFindFloorResult), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bBlockingHit, FFindFloorResult, uint8);
			UProperty* NewProp_bBlockingHit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bBlockingHit"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bBlockingHit, FFindFloorResult), 0x0000000000020815, CPP_BOOL_PROPERTY_BITMASK(bBlockingHit, FFindFloorResult), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Data about the floor for walking movement, used by CharacterMovementComponent."));
			MetaData->SetValue(NewProp_HitResult, TEXT("Category"), TEXT("CharacterFloor"));
			MetaData->SetValue(NewProp_HitResult, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_HitResult, TEXT("ToolTip"), TEXT("Hit result of the test that found a floor. Includes more specific data about the point of impact and surface normal at that point."));
			MetaData->SetValue(NewProp_LineDist, TEXT("Category"), TEXT("CharacterFloor"));
			MetaData->SetValue(NewProp_LineDist, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_LineDist, TEXT("ToolTip"), TEXT("The distance to the floor, computed from the trace. Only valid if bLineTrace is true."));
			MetaData->SetValue(NewProp_FloorDist, TEXT("Category"), TEXT("CharacterFloor"));
			MetaData->SetValue(NewProp_FloorDist, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_FloorDist, TEXT("ToolTip"), TEXT("The distance to the floor, computed from the swept capsule trace."));
			MetaData->SetValue(NewProp_bLineTrace, TEXT("Category"), TEXT("CharacterFloor"));
			MetaData->SetValue(NewProp_bLineTrace, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bLineTrace, TEXT("ToolTip"), TEXT("True if the hit found a valid walkable floor using a line trace (rather than a sweep test, which happens when the sweep test fails to yield a walkable surface)."));
			MetaData->SetValue(NewProp_bWalkableFloor, TEXT("Category"), TEXT("CharacterFloor"));
			MetaData->SetValue(NewProp_bWalkableFloor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bWalkableFloor, TEXT("ToolTip"), TEXT("True if the hit found a valid walkable floor."));
			MetaData->SetValue(NewProp_bBlockingHit, TEXT("Category"), TEXT("CharacterFloor"));
			MetaData->SetValue(NewProp_bBlockingHit, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bBlockingHit, TEXT("ToolTip"), TEXT("True if there was a blocking hit in the floor test."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFindFloorResult_CRC() { return 4291896185U; }
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_AddForce()
	{
		struct CharacterMovementComponent_eventAddForce_Parms
		{
			FVector Force;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddForce"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(CharacterMovementComponent_eventAddForce_Parms));
			UProperty* NewProp_Force = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Force"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Force, CharacterMovementComponent_eventAddForce_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add force to character. Forces are accumulated each tick and applied together\nso multiple calls to this function will accumulate.\nForces are scaled depending on timestep, so they can be applied each frame. If you want an\ninstantaneous force, use AddImpulse.\nAdding a force always takes the actor's mass into account.\nNote that changing the momentum of characters like this can change the movement mode.\n\n@param       Force                   Force to apply."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_AddImpulse()
	{
		struct CharacterMovementComponent_eventAddImpulse_Parms
		{
			FVector Impulse;
			bool bVelocityChange;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddImpulse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(CharacterMovementComponent_eventAddImpulse_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVelocityChange, CharacterMovementComponent_eventAddImpulse_Parms, bool);
			UProperty* NewProp_bVelocityChange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bVelocityChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVelocityChange, CharacterMovementComponent_eventAddImpulse_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bVelocityChange, CharacterMovementComponent_eventAddImpulse_Parms), sizeof(bool), true);
			UProperty* NewProp_Impulse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Impulse"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Impulse, CharacterMovementComponent_eventAddImpulse_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bVelocityChange"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add impulse to character. Impulses are accumulated each tick and applied together\nso multiple calls to this function will accumulate.\nAn impulse is an instantaneous force, usually applied once. If you want to continually apply\nforces each frame, use AddForce().\nNote that changing the momentum of characters like this can change the movement mode.\n\n@param       Impulse                         Impulse to apply.\n@param       bVelocityChange         Whether or not the impulse is relative to mass."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_CalcVelocity()
	{
		struct CharacterMovementComponent_eventCalcVelocity_Parms
		{
			float DeltaTime;
			float Friction;
			bool bFluid;
			float BrakingDeceleration;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CalcVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(CharacterMovementComponent_eventCalcVelocity_Parms));
			UProperty* NewProp_BrakingDeceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BrakingDeceleration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingDeceleration, CharacterMovementComponent_eventCalcVelocity_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFluid, CharacterMovementComponent_eventCalcVelocity_Parms, bool);
			UProperty* NewProp_bFluid = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFluid"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFluid, CharacterMovementComponent_eventCalcVelocity_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFluid, CharacterMovementComponent_eventCalcVelocity_Parms), sizeof(bool), true);
			UProperty* NewProp_Friction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Friction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Friction, CharacterMovementComponent_eventCalcVelocity_Parms), 0x0000000000000080);
			UProperty* NewProp_DeltaTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DeltaTime, CharacterMovementComponent_eventCalcVelocity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Updates Velocity and Acceleration based on the current state, applying the effects of friction and acceleration or deceleration. Does not apply gravity.\nThis is used internally during movement updates. Normally you don't need to call this from outside code, but you might want to use it for custom movement modes.\n\n@param       DeltaTime                                               time elapsed since last frame.\n@param       Friction                                                coefficient of friction when not accelerating, or in the direction opposite acceleration.\n@param       bFluid                                                  true if moving through a fluid, causing Friction to always be applied regardless of acceleration.\n@param       BrakingDeceleration                             deceleration applied when not accelerating, or when exceeding max velocity."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_CapsuleTouched()
	{
		struct CharacterMovementComponent_eventCapsuleTouched_Parms
		{
			AActor* Other;
			UPrimitiveComponent* OtherComp;
			int32 OtherBodyIndex;
			bool bFromSweep;
			FHitResult SweepResult;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CapsuleTouched"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00480400, 65535, sizeof(CharacterMovementComponent_eventCapsuleTouched_Parms));
			UProperty* NewProp_SweepResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SweepResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SweepResult, CharacterMovementComponent_eventCapsuleTouched_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFromSweep, CharacterMovementComponent_eventCapsuleTouched_Parms, bool);
			UProperty* NewProp_bFromSweep = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFromSweep"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFromSweep, CharacterMovementComponent_eventCapsuleTouched_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFromSweep, CharacterMovementComponent_eventCapsuleTouched_Parms), sizeof(bool), true);
			UProperty* NewProp_OtherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherBodyIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OtherBodyIndex, CharacterMovementComponent_eventCapsuleTouched_Parms), 0x0000000000000080);
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, CharacterMovementComponent_eventCapsuleTouched_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Other, CharacterMovementComponent_eventCapsuleTouched_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when the collision capsule touches another primitive component"));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientAckGoodMove()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientAckGoodMove"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01020C40, 65535, sizeof(CharacterMovementComponent_eventClientAckGoodMove_Parms));
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventClientAckGoodMove_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If no client adjustment is needed after processing received ServerMove(), ack the good move so client can remove it from SavedMoves"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustPosition()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientAdjustPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01820C40, 65535, sizeof(CharacterMovementComponent_eventClientAdjustPosition_Parms));
			UProperty* NewProp_ServerMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ServerMovementMode, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bBaseRelativePosition, CharacterMovementComponent_eventClientAdjustPosition_Parms, bool);
			UProperty* NewProp_bBaseRelativePosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bBaseRelativePosition"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bBaseRelativePosition, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bBaseRelativePosition, CharacterMovementComponent_eventClientAdjustPosition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasBase, CharacterMovementComponent_eventClientAdjustPosition_Parms, bool);
			UProperty* NewProp_bHasBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasBase"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasBase, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bHasBase, CharacterMovementComponent_eventClientAdjustPosition_Parms), sizeof(bool), true);
			UProperty* NewProp_NewBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewBaseBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(NewBaseBoneName, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080);
			UProperty* NewProp_NewBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewBase, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_NewVel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewVel, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_NewLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLoc"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewLoc, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventClientAdjustPosition_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicate position correction to client, associated with a timestamped servermove.  Client will replay subsequent moves after applying adjustment."));
			MetaData->SetValue(NewProp_NewBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustRootMotionPosition()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientAdjustRootMotionPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01820C40, 65535, sizeof(CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms));
			UProperty* NewProp_ServerMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ServerMovementMode, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bBaseRelativePosition, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms, bool);
			UProperty* NewProp_bBaseRelativePosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bBaseRelativePosition"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bBaseRelativePosition, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bBaseRelativePosition, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasBase, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms, bool);
			UProperty* NewProp_bHasBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasBase"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasBase, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bHasBase, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), sizeof(bool), true);
			UProperty* NewProp_ServerBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ServerBoneName, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080);
			UProperty* NewProp_ServerBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ServerBase, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_ServerVelZ = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerVelZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ServerVelZ, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080);
			UProperty* NewProp_ServerRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ServerRotation, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantizeNormal());
			UProperty* NewProp_ServerLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerLoc"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ServerLoc, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ServerMontageTrackPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerMontageTrackPosition"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ServerMontageTrackPosition, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080);
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventClientAdjustRootMotionPosition_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicate position correction to client when using root motion for movement."));
			MetaData->SetValue(NewProp_ServerBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ClientVeryShortAdjustPosition()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClientVeryShortAdjustPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x01820C40, 65535, sizeof(CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms));
			UProperty* NewProp_ServerMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ServerMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ServerMovementMode, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bBaseRelativePosition, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms, bool);
			UProperty* NewProp_bBaseRelativePosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bBaseRelativePosition"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bBaseRelativePosition, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bBaseRelativePosition, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasBase, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms, bool);
			UProperty* NewProp_bHasBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasBase"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasBase, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bHasBase, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), sizeof(bool), true);
			UProperty* NewProp_NewBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewBaseBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(NewBaseBoneName, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000000080);
			UProperty* NewProp_NewBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewBase, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_NewLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLoc"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewLoc, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventClientVeryShortAdjustPosition_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Bandwidth saving version, when velocity is zeroed"));
			MetaData->SetValue(NewProp_NewBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_DisableMovement()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DisableMovement"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Make movement impossible (sets movement mode to MOVE_None)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetAnalogInputModifier()
	{
		struct CharacterMovementComponent_eventGetAnalogInputModifier_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAnalogInputModifier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventGetAnalogInputModifier_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetAnalogInputModifier_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return Modifier [0..1] based on the magnitude of the last input vector, which is used to modify the acceleration and max speed during movement."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetCharacterOwner()
	{
		struct CharacterMovementComponent_eventGetCharacterOwner_Parms
		{
			ACharacter* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCharacterOwner"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventGetCharacterOwner_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetCharacterOwner_Parms), 0x0000000000000580, Z_Construct_UClass_ACharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the Character that owns UpdatedComponent."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetCurrentAcceleration()
	{
		struct CharacterMovementComponent_eventGetCurrentAcceleration_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentAcceleration"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(CharacterMovementComponent_eventGetCurrentAcceleration_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetCurrentAcceleration_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("Acceleration GetAcceleration"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return Current acceleration, computed from input vector each update."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetImpartedMovementBaseVelocity()
	{
		struct CharacterMovementComponent_eventGetImpartedMovementBaseVelocity_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetImpartedMovementBaseVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(CharacterMovementComponent_eventGetImpartedMovementBaseVelocity_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetImpartedMovementBaseVelocity_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If we have a movement base, get the velocity that should be imparted by that base, usually when jumping off of it.\nOnly applies the components of the velocity enabled by bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetMaxAcceleration()
	{
		struct CharacterMovementComponent_eventGetMaxAcceleration_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMaxAcceleration"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(CharacterMovementComponent_eventGetMaxAcceleration_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetMaxAcceleration_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return Maximum acceleration for the current state."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetMaxJumpHeight()
	{
		struct CharacterMovementComponent_eventGetMaxJumpHeight_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMaxJumpHeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(CharacterMovementComponent_eventGetMaxJumpHeight_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetMaxJumpHeight_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Compute the max jump height based on the JumpZVelocity velocity and gravity."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetMovementBase()
	{
		struct CharacterMovementComponent_eventGetMovementBase_Parms
		{
			UPrimitiveComponent* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMovementBase"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventGetMovementBase_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetMovementBase_Parms), 0x0000000000080588, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return PrimitiveComponent we are based on (standing and walking on)."));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetPerchRadiusThreshold()
	{
		struct CharacterMovementComponent_eventGetPerchRadiusThreshold_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPerchRadiusThreshold"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventGetPerchRadiusThreshold_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetPerchRadiusThreshold_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return The distance from the edge of the capsule within which we don't allow the character to perch on the edge of a surface."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_GetValidPerchRadius()
	{
		struct CharacterMovementComponent_eventGetValidPerchRadius_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetValidPerchRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventGetValidPerchRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventGetValidPerchRadius_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the radius within which we can stand on the edge of a surface without falling (if this is a walkable surface).\nSimply computed as the capsule radius minus the result of GetPerchRadiusThreshold()."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_IsWalkable()
	{
		struct CharacterMovementComponent_eventIsWalkable_Parms
		{
			FHitResult Hit;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsWalkable"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420400, 65535, sizeof(CharacterMovementComponent_eventIsWalkable_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, CharacterMovementComponent_eventIsWalkable_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, CharacterMovementComponent_eventIsWalkable_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, CharacterMovementComponent_eventIsWalkable_Parms), sizeof(bool), true);
			UProperty* NewProp_Hit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Hit"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Hit, CharacterMovementComponent_eventIsWalkable_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return true if the hit result should be considered a walkable surface for the character."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_IsWalking()
	{
		struct CharacterMovementComponent_eventIsWalking_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsWalking"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventIsWalking_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, CharacterMovementComponent_eventIsWalking_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, CharacterMovementComponent_eventIsWalking_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, CharacterMovementComponent_eventIsWalking_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if the character is in the 'Walking' movement mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_K2_GetModifiedMaxAcceleration()
	{
		struct CharacterMovementComponent_eventK2_GetModifiedMaxAcceleration_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_GetModifiedMaxAcceleration"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(CharacterMovementComponent_eventK2_GetModifiedMaxAcceleration_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventK2_GetModifiedMaxAcceleration_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("GetModifiedMaxAcceleration() is deprecated, apply your own modifiers to GetMaxAcceleration() if desired."));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetModifiedMaxAcceleration"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return Maximum acceleration for the current state, based on MaxAcceleration and any additional modifiers."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorAngle()
	{
		struct CharacterMovementComponent_eventK2_GetWalkableFloorAngle_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_GetWalkableFloorAngle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventK2_GetWalkableFloorAngle_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventK2_GetWalkableFloorAngle_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetWalkableFloorAngle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the max angle in degrees of a walkable surface for the character."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorZ()
	{
		struct CharacterMovementComponent_eventK2_GetWalkableFloorZ_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_GetWalkableFloorZ"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CharacterMovementComponent_eventK2_GetWalkableFloorZ_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CharacterMovementComponent_eventK2_GetWalkableFloorZ_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetWalkableFloorZ"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the Z component of the normal of the steepest walkable surface for the character. Any lower than this and it is not walkable."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMove()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMove"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(CharacterMovementComponent_eventServerMove_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_Native) UUInt32Property(CPP_PROPERTY_BASE(View, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080);
			UProperty* NewProp_CompressedMoveFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CompressedMoveFlags"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CompressedMoveFlags, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InAccel, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventServerMove_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDual()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveDual"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(CharacterMovementComponent_eventServerMoveDual_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_Native) UUInt32Property(CPP_PROPERTY_BASE(View, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_NewFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFlags"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewFlags, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InAccel, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_View0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View0"), RF_Public|RF_Transient|RF_Native) UUInt32Property(CPP_PROPERTY_BASE(View0, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_PendingFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PendingFlags"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PendingFlags, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			UProperty* NewProp_InAccel0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel0"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InAccel0, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp0"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp0, CharacterMovementComponent_eventServerMoveDual_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info for two moves."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDualHybridRootMotion()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveDualHybridRootMotion"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_Native) UUInt32Property(CPP_PROPERTY_BASE(View, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_NewFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFlags"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewFlags, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InAccel, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_View0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View0"), RF_Public|RF_Transient|RF_Native) UUInt32Property(CPP_PROPERTY_BASE(View0, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_PendingFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PendingFlags"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(PendingFlags, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			UProperty* NewProp_InAccel0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel0"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InAccel0, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp0"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp0, CharacterMovementComponent_eventServerMoveDualHybridRootMotion_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info for two moves. First move is non root motion, second is root motion."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveOld()
	{
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveOld"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(CharacterMovementComponent_eventServerMoveOld_Parms));
			UProperty* NewProp_OldMoveFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldMoveFlags"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(OldMoveFlags, CharacterMovementComponent_eventServerMoveOld_Parms), 0x0000000000000080);
			UProperty* NewProp_OldAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldAccel"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OldAccel, CharacterMovementComponent_eventServerMoveOld_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_OldTimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldTimeStamp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OldTimeStamp, CharacterMovementComponent_eventServerMoveOld_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Resending an (important) old move. Process it if not already processed."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceEnabled()
	{
		struct CharacterMovementComponent_eventSetAvoidanceEnabled_Parms
		{
			bool bEnable;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAvoidanceEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CharacterMovementComponent_eventSetAvoidanceEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnable, CharacterMovementComponent_eventSetAvoidanceEnabled_Parms, bool);
			UProperty* NewProp_bEnable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnable, CharacterMovementComponent_eventSetAvoidanceEnabled_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnable, CharacterMovementComponent_eventSetAvoidanceEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change avoidance state and registers in RVO manager if needed"));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceGroup()
	{
		struct CharacterMovementComponent_eventSetAvoidanceGroup_Parms
		{
			int32 GroupFlags;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAvoidanceGroup"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CharacterMovementComponent_eventSetAvoidanceGroup_Parms));
			UProperty* NewProp_GroupFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GroupFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GroupFlags, CharacterMovementComponent_eventSetAvoidanceGroup_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToAvoid()
	{
		struct CharacterMovementComponent_eventSetGroupsToAvoid_Parms
		{
			int32 GroupFlags;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGroupsToAvoid"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CharacterMovementComponent_eventSetGroupsToAvoid_Parms));
			UProperty* NewProp_GroupFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GroupFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GroupFlags, CharacterMovementComponent_eventSetGroupsToAvoid_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToIgnore()
	{
		struct CharacterMovementComponent_eventSetGroupsToIgnore_Parms
		{
			int32 GroupFlags;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGroupsToIgnore"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CharacterMovementComponent_eventSetGroupsToIgnore_Parms));
			UProperty* NewProp_GroupFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GroupFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GroupFlags, CharacterMovementComponent_eventSetGroupsToIgnore_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetMovementMode()
	{
		struct CharacterMovementComponent_eventSetMovementMode_Parms
		{
			TEnumAsByte<EMovementMode> NewMovementMode;
			uint8 NewCustomMode;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMovementMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(CharacterMovementComponent_eventSetMovementMode_Parms));
			UProperty* NewProp_NewCustomMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewCustomMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewCustomMode, CharacterMovementComponent_eventSetMovementMode_Parms), 0x0000000000000080);
			UProperty* NewProp_NewMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewMovementMode, CharacterMovementComponent_eventSetMovementMode_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_NewCustomMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change movement mode.\n\n@param NewMovementMode       The new movement mode\n@param NewCustomMode         The new custom sub-mode, only applicable if NewMovementMode is Custom."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorAngle()
	{
		struct CharacterMovementComponent_eventSetWalkableFloorAngle_Parms
		{
			float InWalkableFloorAngle;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetWalkableFloorAngle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CharacterMovementComponent_eventSetWalkableFloorAngle_Parms));
			UProperty* NewProp_InWalkableFloorAngle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWalkableFloorAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWalkableFloorAngle, CharacterMovementComponent_eventSetWalkableFloorAngle_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the max angle in degrees of a walkable surface for the character. Also computes WalkableFloorZ."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorZ()
	{
		struct CharacterMovementComponent_eventSetWalkableFloorZ_Parms
		{
			float InWalkableFloorZ;
		};
		UObject* Outer=Z_Construct_UClass_UCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetWalkableFloorZ"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CharacterMovementComponent_eventSetWalkableFloorZ_Parms));
			UProperty* NewProp_InWalkableFloorZ = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWalkableFloorZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWalkableFloorZ, CharacterMovementComponent_eventSetWalkableFloorZ_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|CharacterMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the Z component of the normal of the steepest walkable surface for the character. Also computes WalkableFloorAngle."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UCharacterMovementComponent_NoRegister()
	{
		return UCharacterMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UCharacterMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPawnMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UCharacterMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_AddForce());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_AddImpulse());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_CalcVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_CapsuleTouched());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ClientAckGoodMove());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustRootMotionPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ClientVeryShortAdjustPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_DisableMovement());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetAnalogInputModifier());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetCharacterOwner());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetCurrentAcceleration());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetImpartedMovementBaseVelocity());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetMaxAcceleration());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetMaxJumpHeight());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetMovementBase());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetPerchRadiusThreshold());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_GetValidPerchRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_IsWalkable());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_IsWalking());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_K2_GetModifiedMaxAcceleration());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorZ());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ServerMove());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDual());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDualHybridRootMotion());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveOld());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceGroup());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToAvoid());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToIgnore());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetMovementMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorZ());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWasSimulatingRootMotion, UCharacterMovementComponent, bool);
				UProperty* NewProp_bWasSimulatingRootMotion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWasSimulatingRootMotion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWasSimulatingRootMotion, UCharacterMovementComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bWasSimulatingRootMotion, UCharacterMovementComponent), sizeof(bool), true);
				UProperty* NewProp_RootMotionParams = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RootMotionParams"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RootMotionParams, UCharacterMovementComponent), 0x0000000000002000, Z_Construct_UScriptStruct_FRootMotionMovementParams());
				UProperty* NewProp_MinTimeBetweenTimeStampResets = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinTimeBetweenTimeStampResets"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinTimeBetweenTimeStampResets, UCharacterMovementComponent), 0x0000000000000000);
				UProperty* NewProp_PreClothComponentTick = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreClothComponentTick"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreClothComponentTick, UCharacterMovementComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FCharacterMovementComponentPreClothTickFunction());
				UProperty* NewProp_NavMeshProjectionHeightScaleDown = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavMeshProjectionHeightScaleDown"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NavMeshProjectionHeightScaleDown, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_NavMeshProjectionHeightScaleUp = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavMeshProjectionHeightScaleUp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NavMeshProjectionHeightScaleUp, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_NavMeshProjectionInterpSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavMeshProjectionInterpSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NavMeshProjectionInterpSpeed, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_NavMeshProjectionTimer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavMeshProjectionTimer"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NavMeshProjectionTimer, UCharacterMovementComponent), 0x0000000000002000);
				UProperty* NewProp_NavMeshProjectionInterval = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavMeshProjectionInterval"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NavMeshProjectionInterval, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_PendingLaunchVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PendingLaunchVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PendingLaunchVelocity, UCharacterMovementComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_AvoidanceWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AvoidanceWeight, UCharacterMovementComponent), 0x0000000000000015);
				UProperty* NewProp_GroupsToIgnore = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroupsToIgnore"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GroupsToIgnore, UCharacterMovementComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FNavAvoidanceMask());
				UProperty* NewProp_GroupsToAvoid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroupsToAvoid"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GroupsToAvoid, UCharacterMovementComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FNavAvoidanceMask());
				UProperty* NewProp_AvoidanceGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceGroup"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AvoidanceGroup, UCharacterMovementComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FNavAvoidanceMask());
				UProperty* NewProp_AvoidanceUID = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceUID"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(AvoidanceUID, UCharacterMovementComponent), 0x0000040000020015);
				UProperty* NewProp_RequestedVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RequestedVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RequestedVelocity, UCharacterMovementComponent), 0x0000000000002000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_AvoidanceConsiderationRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceConsiderationRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AvoidanceConsiderationRadius, UCharacterMovementComponent), 0x0000000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bProjectNavMeshWalking, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bProjectNavMeshWalking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bProjectNavMeshWalking"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bProjectNavMeshWalking, UCharacterMovementComponent), 0x0000080000000015, CPP_BOOL_PROPERTY_BITMASK(bProjectNavMeshWalking, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWasAvoidanceUpdated, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bWasAvoidanceUpdated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWasAvoidanceUpdated"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWasAvoidanceUpdated, UCharacterMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bWasAvoidanceUpdated, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRequestedMoveWithMaxSpeed, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bRequestedMoveWithMaxSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRequestedMoveWithMaxSpeed"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRequestedMoveWithMaxSpeed, UCharacterMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bRequestedMoveWithMaxSpeed, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasRequestedVelocity, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bHasRequestedVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasRequestedVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasRequestedVelocity, UCharacterMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bHasRequestedVelocity, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRequestedMoveUseAcceleration, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bRequestedMoveUseAcceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRequestedMoveUseAcceleration"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRequestedMoveUseAcceleration, UCharacterMovementComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bRequestedMoveUseAcceleration, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseRVOAvoidance, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bUseRVOAvoidance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseRVOAvoidance"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseRVOAvoidance, UCharacterMovementComponent), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bUseRVOAvoidance, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToLeaveNavWalking, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bWantsToLeaveNavWalking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWantsToLeaveNavWalking"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToLeaveNavWalking, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bWantsToLeaveNavWalking, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPerformingJumpOff, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bPerformingJumpOff = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPerformingJumpOff"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPerformingJumpOff, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bPerformingJumpOff, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseFlatBaseForFloorChecks, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bUseFlatBaseForFloorChecks = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseFlatBaseForFloorChecks"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseFlatBaseForFloorChecks, UCharacterMovementComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bUseFlatBaseForFloorChecks, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAlwaysCheckFloor, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bAlwaysCheckFloor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAlwaysCheckFloor"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAlwaysCheckFloor, UCharacterMovementComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bAlwaysCheckFloor, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFastAttachedMove, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bFastAttachedMove = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFastAttachedMove"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFastAttachedMove, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bFastAttachedMove, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreBaseRotation, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bIgnoreBaseRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreBaseRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreBaseRotation, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIgnoreBaseRotation, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCrouchMaintainsBaseLocation, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bCrouchMaintainsBaseLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCrouchMaintainsBaseLocation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCrouchMaintainsBaseLocation, UCharacterMovementComponent), 0x0000040000020805, CPP_BOOL_PROPERTY_BITMASK(bCrouchMaintainsBaseLocation, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToCrouch, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bWantsToCrouch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWantsToCrouch"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToCrouch, UCharacterMovementComponent), 0x0000000000020815, CPP_BOOL_PROPERTY_BITMASK(bWantsToCrouch, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCheatFlying, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bCheatFlying = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCheatFlying"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCheatFlying, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bCheatFlying, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNotifyApex, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bNotifyApex = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNotifyApex"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNotifyApex, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bNotifyApex, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNetworkMovementModeChanged, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bNetworkMovementModeChanged = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNetworkMovementModeChanged"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNetworkMovementModeChanged, UCharacterMovementComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bNetworkMovementModeChanged, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNetworkUpdateReceived, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bNetworkUpdateReceived = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNetworkUpdateReceived"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNetworkUpdateReceived, UCharacterMovementComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bNetworkUpdateReceived, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bJustTeleported, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bJustTeleported = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bJustTeleported"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bJustTeleported, UCharacterMovementComponent), 0x0000000000022805, CPP_BOOL_PROPERTY_BITMASK(bJustTeleported, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bImpartBaseAngularVelocity, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bImpartBaseAngularVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bImpartBaseAngularVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bImpartBaseAngularVelocity, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bImpartBaseAngularVelocity, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bImpartBaseVelocityZ, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bImpartBaseVelocityZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bImpartBaseVelocityZ"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bImpartBaseVelocityZ, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bImpartBaseVelocityZ, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bImpartBaseVelocityY, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bImpartBaseVelocityY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bImpartBaseVelocityY"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bImpartBaseVelocityY, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bImpartBaseVelocityY, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bImpartBaseVelocityX, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bImpartBaseVelocityX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bImpartBaseVelocityX"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bImpartBaseVelocityX, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bImpartBaseVelocityX, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bMaintainHorizontalGroundVelocity, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bMaintainHorizontalGroundVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bMaintainHorizontalGroundVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bMaintainHorizontalGroundVelocity, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bMaintainHorizontalGroundVelocity, UCharacterMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_GroundMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroundMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(GroundMovementMode, UCharacterMovementComponent), 0x0000000000002000, Z_Construct_UEnum_Engine_EMovementMode());
				UProperty* NewProp_DefaultWaterMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultWaterMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DefaultWaterMovementMode, UCharacterMovementComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_EMovementMode());
				UProperty* NewProp_DefaultLandMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultLandMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DefaultLandMovementMode, UCharacterMovementComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_EMovementMode());
				UProperty* NewProp_CurrentFloor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentFloor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CurrentFloor, UCharacterMovementComponent), 0x0000008000020815, Z_Construct_UScriptStruct_FFindFloorResult());
				UProperty* NewProp_JumpOutOfWaterPitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("JumpOutOfWaterPitch"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(JumpOutOfWaterPitch, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_LedgeCheckThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgeCheckThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LedgeCheckThreshold, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_NetworkSimulatedSmoothRotationTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NetworkSimulatedSmoothRotationTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NetworkSimulatedSmoothRotationTime, UCharacterMovementComponent), 0x0000040000010001);
				UProperty* NewProp_NetworkSimulatedSmoothLocationTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NetworkSimulatedSmoothLocationTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NetworkSimulatedSmoothLocationTime, UCharacterMovementComponent), 0x0000040000010001);
				UProperty* NewProp_MaxSimulationIterations = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSimulationIterations"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxSimulationIterations, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_MaxSimulationTimeStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSimulationTimeStep"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSimulationTimeStep, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_AnalogInputModifier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnalogInputModifier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AnalogInputModifier, UCharacterMovementComponent), 0x0000080000000000);
				UProperty* NewProp_PendingForceToApply = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PendingForceToApply"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PendingForceToApply, UCharacterMovementComponent), 0x0000080000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PendingImpulseToApply = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PendingImpulseToApply"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PendingImpulseToApply, UCharacterMovementComponent), 0x0000080000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_LastUpdateLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastUpdateLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LastUpdateLocation, UCharacterMovementComponent), 0x0000080000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Acceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Acceleration"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Acceleration, UCharacterMovementComponent), 0x0000080000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_UpperImpactNormalScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpperImpactNormalScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(UpperImpactNormalScale_DEPRECATED, UCharacterMovementComponent), 0x0000000020000000);
				UProperty* NewProp_CrouchedSpeedMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CrouchedSpeedMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CrouchedSpeedMultiplier_DEPRECATED, UCharacterMovementComponent), 0x0000000020000000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceBraking_DEPRECATED, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bForceBraking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceBraking"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceBraking_DEPRECATED, UCharacterMovementComponent), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bForceBraking_DEPRECATED, UCharacterMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_RepulsionForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RepulsionForce"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RepulsionForce, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxTouchForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxTouchForce"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxTouchForce, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MinTouchForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinTouchForce"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinTouchForce, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_TouchForceFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TouchForceFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TouchForceFactor, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_PushForcePointZOffsetFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PushForcePointZOffsetFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PushForcePointZOffsetFactor, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_PushForceFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PushForceFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PushForceFactor, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_InitialPushForceFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InitialPushForceFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InitialPushForceFactor, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_StandingDownwardForceScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StandingDownwardForceScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StandingDownwardForceScale, UCharacterMovementComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bScalePushForceToVelocity, UCharacterMovementComponent, bool);
				UProperty* NewProp_bScalePushForceToVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bScalePushForceToVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bScalePushForceToVelocity, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bScalePushForceToVelocity, UCharacterMovementComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPushForceScaledToMass, UCharacterMovementComponent, bool);
				UProperty* NewProp_bPushForceScaledToMass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPushForceScaledToMass"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPushForceScaledToMass, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bPushForceScaledToMass, UCharacterMovementComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTouchForceScaledToMass, UCharacterMovementComponent, bool);
				UProperty* NewProp_bTouchForceScaledToMass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bTouchForceScaledToMass"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTouchForceScaledToMass, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bTouchForceScaledToMass, UCharacterMovementComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnablePhysicsInteraction, UCharacterMovementComponent, bool);
				UProperty* NewProp_bEnablePhysicsInteraction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnablePhysicsInteraction"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnablePhysicsInteraction, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnablePhysicsInteraction, UCharacterMovementComponent), sizeof(bool), true);
				UProperty* NewProp_Mass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mass"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Mass, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_OutofWaterZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OutofWaterZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutofWaterZ, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_MaxOutOfWaterStepHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxOutOfWaterStepHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxOutOfWaterStepHeight, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_DeferredUpdatedMoveComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DeferredUpdatedMoveComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DeferredUpdatedMoveComponent, UCharacterMovementComponent), 0x0000000000080008, Z_Construct_UClass_USceneComponent_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDeferUpdateMoveComponent, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bDeferUpdateMoveComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDeferUpdateMoveComponent"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDeferUpdateMoveComponent, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDeferUpdateMoveComponent, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanWalkOffLedgesWhenCrouching, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bCanWalkOffLedgesWhenCrouching = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanWalkOffLedgesWhenCrouching"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanWalkOffLedgesWhenCrouching, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanWalkOffLedgesWhenCrouching, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanWalkOffLedges, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bCanWalkOffLedges = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanWalkOffLedges"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanWalkOffLedges, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanWalkOffLedges, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShrinkProxyCapsule, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bShrinkProxyCapsule = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShrinkProxyCapsule"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShrinkProxyCapsule, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bShrinkProxyCapsule, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceNextFloorCheck, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bForceNextFloorCheck = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceNextFloorCheck"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceNextFloorCheck, UCharacterMovementComponent), 0x0000040000020805, CPP_BOOL_PROPERTY_BITMASK(bForceNextFloorCheck, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRunPhysicsWithNoController, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bRunPhysicsWithNoController = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRunPhysicsWithNoController"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRunPhysicsWithNoController, UCharacterMovementComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bRunPhysicsWithNoController, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceMaxAccel, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bForceMaxAccel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceMaxAccel"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceMaxAccel, UCharacterMovementComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bForceMaxAccel, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableScopedMovementUpdates, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bEnableScopedMovementUpdates = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableScopedMovementUpdates"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableScopedMovementUpdates, UCharacterMovementComponent), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bEnableScopedMovementUpdates, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bMovementInProgress, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bMovementInProgress = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bMovementInProgress"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bMovementInProgress, UCharacterMovementComponent), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bMovementInProgress, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOrientRotationToMovement, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bOrientRotationToMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOrientRotationToMovement"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOrientRotationToMovement, UCharacterMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bOrientRotationToMovement, UCharacterMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerDesiredRotation, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bUseControllerDesiredRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerDesiredRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerDesiredRotation, UCharacterMovementComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bUseControllerDesiredRotation, UCharacterMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_RotationRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RotationRate"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RotationRate, UCharacterMovementComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_PerchAdditionalHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PerchAdditionalHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PerchAdditionalHeight, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_PerchRadiusThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PerchRadiusThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PerchRadiusThreshold, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_Buoyancy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Buoyancy"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Buoyancy, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_CrouchedHalfHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CrouchedHalfHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CrouchedHalfHeight, UCharacterMovementComponent), 0x0000000000000015);
				UProperty* NewProp_FallingLateralFriction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FallingLateralFriction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FallingLateralFriction, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_AirControlBoostVelocityThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AirControlBoostVelocityThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AirControlBoostVelocityThreshold, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_AirControlBoostMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AirControlBoostMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AirControlBoostMultiplier, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_AirControl = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AirControl"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AirControl, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_BrakingDecelerationFlying = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakingDecelerationFlying"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingDecelerationFlying, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_BrakingDecelerationSwimming = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakingDecelerationSwimming"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingDecelerationSwimming, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_BrakingDecelerationFalling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakingDecelerationFalling"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingDecelerationFalling, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_BrakingDecelerationWalking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakingDecelerationWalking"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingDecelerationWalking, UCharacterMovementComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseSeparateBrakingFriction, UCharacterMovementComponent, uint8);
				UProperty* NewProp_bUseSeparateBrakingFriction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseSeparateBrakingFriction"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseSeparateBrakingFriction, UCharacterMovementComponent), 0x0000000000010005, CPP_BOOL_PROPERTY_BITMASK(bUseSeparateBrakingFriction, UCharacterMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_BrakingFriction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakingFriction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingFriction, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_BrakingFrictionFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakingFrictionFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakingFrictionFactor, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxAcceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxAcceleration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxAcceleration, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxCustomMovementSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxCustomMovementSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxCustomMovementSpeed, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxFlySpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxFlySpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxFlySpeed, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxSwimSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSwimSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSwimSpeed, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxWalkSpeedCrouched = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxWalkSpeedCrouched"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxWalkSpeedCrouched, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxWalkSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxWalkSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxWalkSpeed, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_GroundFriction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroundFriction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GroundFriction, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, UCharacterMovementComponent), 0x0000000000000014);
				UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(MovementMode, UCharacterMovementComponent), 0x0000000000000014, Z_Construct_UEnum_Engine_EMovementMode());
				UProperty* NewProp_WalkableFloorZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WalkableFloorZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WalkableFloorZ, UCharacterMovementComponent), 0x0000000000020001);
				UProperty* NewProp_WalkableFloorAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WalkableFloorAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WalkableFloorAngle, UCharacterMovementComponent), 0x0000000000000001);
				UProperty* NewProp_JumpOffJumpZFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("JumpOffJumpZFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(JumpOffJumpZFactor, UCharacterMovementComponent), 0x0000040000000005);
				UProperty* NewProp_JumpZVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("JumpZVelocity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(JumpZVelocity, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxStepHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxStepHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxStepHeight, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_GravityScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GravityScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GravityScale, UCharacterMovementComponent), 0x0000000000000005);
				UProperty* NewProp_CharacterOwner = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CharacterOwner"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CharacterOwner, UCharacterMovementComponent), 0x0000080000000000, Z_Construct_UClass_ACharacter_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_AddForce()); // 1279541754
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_AddImpulse()); // 1691992070
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_CalcVelocity()); // 2112402101
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_CapsuleTouched()); // 1827392442
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ClientAckGoodMove()); // 3094663307
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustPosition()); // 2472856653
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ClientAdjustRootMotionPosition()); // 2122999876
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ClientVeryShortAdjustPosition()); // 4059622607
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_DisableMovement()); // 2300923514
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetAnalogInputModifier()); // 4011131793
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetCharacterOwner()); // 1684334930
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetCurrentAcceleration()); // 1489682689
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetImpartedMovementBaseVelocity()); // 465370110
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetMaxAcceleration()); // 3869971666
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetMaxJumpHeight()); // 1244893917
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetMovementBase()); // 2605008053
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetPerchRadiusThreshold()); // 3418538357
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_GetValidPerchRadius()); // 3818729477
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_IsWalkable()); // 4231259623
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_IsWalking()); // 3332853243
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_K2_GetModifiedMaxAcceleration()); // 939162944
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorAngle()); // 753465817
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_K2_GetWalkableFloorZ()); // 1081304445
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ServerMove()); // 2024333817
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDual()); // 2182741732
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveDualHybridRootMotion()); // 3828888913
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_ServerMoveOld()); // 576887955
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceEnabled()); // 2444671741
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetAvoidanceGroup()); // 466991422
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToAvoid()); // 3670529935
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetGroupsToIgnore()); // 2102253729
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetMovementMode()); // 4263716268
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorAngle()); // 2596574123
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCharacterMovementComponent_SetWalkableFloorZ()); // 1103569795
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_URVOAvoidanceInterface_NoRegister(), VTABLE_OFFSET(UCharacterMovementComponent, IRVOAvoidanceInterface), false ));
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UNetworkPredictionInterface_NoRegister(), VTABLE_OFFSET(UCharacterMovementComponent, INetworkPredictionInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("CharacterMovementComponent handles movement logic for the associated Character owner.\nIt supports various movement modes including: walking, falling, swimming, flying, custom.\n\nMovement is affected primarily by current Velocity and Acceleration. Acceleration is updated each frame\nbased on the input vector accumulated thus far (see UPawnMovementComponent::GetPendingInputVector()).\n\nNetworking is fully implemented, with server-client correction and prediction included.\n\n@see ACharacter, UPawnMovementComponent\n@see https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/Character/"));
				MetaData->SetValue(NewProp_bWasSimulatingRootMotion, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bWasSimulatingRootMotion, TEXT("ToolTip"), TEXT("True when SimulatedProxies are simulating RootMotion"));
				MetaData->SetValue(NewProp_RootMotionParams, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_RootMotionParams, TEXT("ToolTip"), TEXT("Root Motion movement params"));
				MetaData->SetValue(NewProp_MinTimeBetweenTimeStampResets, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MinTimeBetweenTimeStampResets, TEXT("ToolTip"), TEXT("Minimum time between client TimeStamp resets.\n       !! This has to be large enough so that we don't confuse the server if the client can stall or timeout.\n       We do this as we use floats for TimeStamps, and server derives DeltaTime from two TimeStamps.\n       As time goes on, accuracy decreases from those floating point numbers.\n       So we trigger a TimeStamp reset at regular intervals to maintain a high level of accuracy."));
				MetaData->SetValue(NewProp_PreClothComponentTick, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PreClothComponentTick, TEXT("ToolTip"), TEXT("Post-physics tick function for this character"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleDown, TEXT("Category"), TEXT("Character Movement: NavMesh Movement"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleDown, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleDown, TEXT("editcondition"), TEXT("bProjectNavMeshWalking"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleDown, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleDown, TEXT("ToolTip"), TEXT("Scale of the total capsule height to use for projection from navmesh to underlying geometry in the downward direction.\nIn other words, trace down to [CapsuleHeight * NavMeshProjectionHeightScaleDown] below nav mesh."));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleDown, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleUp, TEXT("Category"), TEXT("Character Movement: NavMesh Movement"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleUp, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleUp, TEXT("editcondition"), TEXT("bProjectNavMeshWalking"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleUp, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleUp, TEXT("ToolTip"), TEXT("Scale of the total capsule height to use for projection from navmesh to underlying geometry in the upward direction.\nIn other words, start the trace at [CapsuleHeight * NavMeshProjectionHeightScaleUp] above nav mesh."));
				MetaData->SetValue(NewProp_NavMeshProjectionHeightScaleUp, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterpSpeed, TEXT("Category"), TEXT("Character Movement: NavMesh Movement"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterpSpeed, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterpSpeed, TEXT("editcondition"), TEXT("bProjectNavMeshWalking"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterpSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterpSpeed, TEXT("ToolTip"), TEXT("Speed at which to interpolate agent navmesh offset between traces. 0: Instant (no interp) > 0: Interp speed\")"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterpSpeed, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NavMeshProjectionTimer, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterval, TEXT("Category"), TEXT("Character Movement: NavMesh Movement"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterval, TEXT("editcondition"), TEXT("bProjectNavMeshWalking"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterval, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NavMeshProjectionInterval, TEXT("ToolTip"), TEXT("How often we should raycast to project from navmesh to underlying geometry"));
				MetaData->SetValue(NewProp_PendingLaunchVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PendingLaunchVelocity, TEXT("ToolTip"), TEXT("Temporarily holds launch velocity when pawn is to be launched so it happens at end of movement."));
				MetaData->SetValue(NewProp_AvoidanceWeight, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceWeight, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceWeight, TEXT("ToolTip"), TEXT("De facto default value 0.5 (due to that being the default in the avoidance registration function), indicates RVO behavior."));
				MetaData->SetValue(NewProp_GroupsToIgnore, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_GroupsToIgnore, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_GroupsToIgnore, TEXT("ToolTip"), TEXT("Will NOT avoid other agents if they are in one of specified groups, higher priority than GroupsToAvoid"));
				MetaData->SetValue(NewProp_GroupsToAvoid, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_GroupsToAvoid, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_GroupsToAvoid, TEXT("ToolTip"), TEXT("Will avoid other agents if they are in one of specified groups"));
				MetaData->SetValue(NewProp_AvoidanceGroup, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceGroup, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceGroup, TEXT("ToolTip"), TEXT("Moving actor's group mask"));
				MetaData->SetValue(NewProp_AvoidanceUID, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceUID, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceUID, TEXT("ToolTip"), TEXT("No default value, for now it's assumed to be valid if GetAvoidanceManager() returns non-NULL."));
				MetaData->SetValue(NewProp_RequestedVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_RequestedVelocity, TEXT("ToolTip"), TEXT("Velocity requested by path following.\n@see RequestDirectMove()"));
				MetaData->SetValue(NewProp_AvoidanceConsiderationRadius, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceConsiderationRadius, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bProjectNavMeshWalking, TEXT("Category"), TEXT("Character Movement: NavMesh Movement"));
				MetaData->SetValue(NewProp_bProjectNavMeshWalking, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bProjectNavMeshWalking, TEXT("ToolTip"), TEXT("Whether to raycast to underlying geometry to better conform navmesh-walking characters"));
				MetaData->SetValue(NewProp_bWasAvoidanceUpdated, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bWasAvoidanceUpdated, TEXT("ToolTip"), TEXT("Was avoidance updated in this frame?"));
				MetaData->SetValue(NewProp_bRequestedMoveWithMaxSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bRequestedMoveWithMaxSpeed, TEXT("ToolTip"), TEXT("Was acceleration requested to be always max speed?"));
				MetaData->SetValue(NewProp_bHasRequestedVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bHasRequestedVelocity, TEXT("ToolTip"), TEXT("Was velocity requested by path following?"));
				MetaData->SetValue(NewProp_bRequestedMoveUseAcceleration, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bRequestedMoveUseAcceleration, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bRequestedMoveUseAcceleration, TEXT("ToolTip"), TEXT("Should use acceleration for path following?\nIf true, acceleration is applied when path following to reach the target velocity.\nIf false, path following velocity is set directly, disregarding acceleration."));
				MetaData->SetValue(NewProp_bUseRVOAvoidance, TEXT("Category"), TEXT("Character Movement: Avoidance"));
				MetaData->SetValue(NewProp_bUseRVOAvoidance, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bUseRVOAvoidance, TEXT("ToolTip"), TEXT("If set, component will use RVO avoidance"));
				MetaData->SetValue(NewProp_bWantsToLeaveNavWalking, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bWantsToLeaveNavWalking, TEXT("ToolTip"), TEXT("Used to safely leave NavWalking movement mode"));
				MetaData->SetValue(NewProp_bPerformingJumpOff, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bPerformingJumpOff, TEXT("ToolTip"), TEXT("Used to prevent reentry of JumpOff()"));
				MetaData->SetValue(NewProp_bUseFlatBaseForFloorChecks, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bUseFlatBaseForFloorChecks, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bUseFlatBaseForFloorChecks, TEXT("ToolTip"), TEXT("Performs floor checks as if the character is using a shape with a flat base.\nThis avoids the situation where characters slowly lower off the side of a ledge (as their capsule 'balances' on the edge)."));
				MetaData->SetValue(NewProp_bAlwaysCheckFloor, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bAlwaysCheckFloor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bAlwaysCheckFloor, TEXT("ToolTip"), TEXT("Whether we always force floor checks for stationary Characters while walking.\nNormally floor checks are avoided if possible when not moving, but this can be used to force them if there are use-cases where they are being skipped erroneously\n(such as objects moving up into the character from below)."));
				MetaData->SetValue(NewProp_bFastAttachedMove, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bFastAttachedMove, TEXT("ToolTip"), TEXT("Set this to true if riding on a moving base that you know is clear from non-moving world obstructions.\nOptimization to avoid sweeps during based movement, use with care."));
				MetaData->SetValue(NewProp_bIgnoreBaseRotation, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bIgnoreBaseRotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bIgnoreBaseRotation, TEXT("ToolTip"), TEXT("Whether the character ignores changes in rotation of the base it is standing on.\nIf true, the character maintains current world rotation.\nIf false, the character rotates with the moving base."));
				MetaData->SetValue(NewProp_bCrouchMaintainsBaseLocation, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bCrouchMaintainsBaseLocation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bCrouchMaintainsBaseLocation, TEXT("ToolTip"), TEXT("If true, crouching should keep the base of the capsule in place by lowering the center of the shrunken capsule. If false, the base of the capsule moves up and the center stays in place.\nThe same behavior applies when the character uncrouches: if true, the base is kept in the same location and the center moves up. If false, the capsule grows and only moves up if the base impacts something.\nBy default this variable is set when the movement mode changes: set to true when walking and false otherwise. Feel free to override the behavior when the movement mode changes."));
				MetaData->SetValue(NewProp_bWantsToCrouch, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bWantsToCrouch, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bWantsToCrouch, TEXT("ToolTip"), TEXT("If true, try to crouch (or keep crouching) on next update. If false, try to stop crouching on next update."));
				MetaData->SetValue(NewProp_bCheatFlying, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bCheatFlying, TEXT("ToolTip"), TEXT("Instantly stop when in flying mode and no acceleration is being applied."));
				MetaData->SetValue(NewProp_bNotifyApex, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_bNotifyApex, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bNotifyApex, TEXT("ToolTip"), TEXT("if true, event NotifyJumpApex() to CharacterOwner's controller when at apex of jump.  Is cleared when event is triggered."));
				MetaData->SetValue(NewProp_bNetworkMovementModeChanged, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bNetworkMovementModeChanged, TEXT("ToolTip"), TEXT("True when the networked movement mode has been replicated."));
				MetaData->SetValue(NewProp_bNetworkUpdateReceived, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bNetworkUpdateReceived, TEXT("ToolTip"), TEXT("True when a network replication update is received for simulated proxies."));
				MetaData->SetValue(NewProp_bJustTeleported, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bJustTeleported, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bJustTeleported, TEXT("ToolTip"), TEXT("Used by movement code to determine if a change in position is based on normal movement or a teleport. If not a teleport, velocity can be recomputed based on the change in position."));
				MetaData->SetValue(NewProp_bImpartBaseAngularVelocity, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_bImpartBaseAngularVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bImpartBaseAngularVelocity, TEXT("ToolTip"), TEXT("If true, impart the base component's tangential components of angular velocity when jumping or falling off it.\nOnly those components of the velocity allowed by the separate component settings (bImpartBaseVelocityX etc) will be applied.\n@see bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityZ, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityZ, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityZ, TEXT("ToolTip"), TEXT("If true, impart the base actor's Z velocity when falling off it (which includes jumping)"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityY, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityY, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityY, TEXT("ToolTip"), TEXT("If true, impart the base actor's Y velocity when falling off it (which includes jumping)"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityX, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityX, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bImpartBaseVelocityX, TEXT("ToolTip"), TEXT("If true, impart the base actor's X velocity when falling off it (which includes jumping)"));
				MetaData->SetValue(NewProp_bMaintainHorizontalGroundVelocity, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bMaintainHorizontalGroundVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bMaintainHorizontalGroundVelocity, TEXT("ToolTip"), TEXT("If true, walking movement always maintains horizontal velocity when moving up ramps, which causes movement up ramps to be faster parallel to the ramp surface.\nIf false, then walking movement maintains velocity magnitude parallel to the ramp surface."));
				MetaData->SetValue(NewProp_GroundMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_GroundMovementMode, TEXT("ToolTip"), TEXT("Ground movement mode to switch to after falling and resuming ground movement.\nOnly allowed values are: MOVE_Walking, MOVE_NavWalking.\n@see SetGroundMovementMode(), GetGroundMovementMode()"));
				MetaData->SetValue(NewProp_DefaultWaterMovementMode, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_DefaultWaterMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_DefaultWaterMovementMode, TEXT("ToolTip"), TEXT("Default movement mode when in water. Used at player startup or when teleported.\n@see DefaultLandMovementMode\n@see bRunPhysicsWithNoController"));
				MetaData->SetValue(NewProp_DefaultLandMovementMode, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_DefaultLandMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_DefaultLandMovementMode, TEXT("ToolTip"), TEXT("Default movement mode when not in water. Used at player startup or when teleported.\n@see DefaultWaterMovementMode\n@see bRunPhysicsWithNoController"));
				MetaData->SetValue(NewProp_CurrentFloor, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_CurrentFloor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CurrentFloor, TEXT("ToolTip"), TEXT("Information about the floor the Character is standing on (updated only during walking movement)."));
				MetaData->SetValue(NewProp_JumpOutOfWaterPitch, TEXT("Category"), TEXT("Character Movement: Swimming"));
				MetaData->SetValue(NewProp_JumpOutOfWaterPitch, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_JumpOutOfWaterPitch, TEXT("ToolTip"), TEXT("When exiting water, jump if control pitch angle is this high or above."));
				MetaData->SetValue(NewProp_LedgeCheckThreshold, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_LedgeCheckThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgeCheckThreshold, TEXT("ToolTip"), TEXT("Used in determining if pawn is going off ledge.  If the ledge is \"shorter\" than this value then the pawn will be able to walk off it. *"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("ClampMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("ToolTip"), TEXT("How long to take to smoothly interpolate from the old pawn rotation on the client to the corrected one sent by the server."));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothRotationTime, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("ClampMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("ToolTip"), TEXT("How long to take to smoothly interpolate from the old pawn position on the client to the corrected one sent by the server."));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_NetworkSimulatedSmoothLocationTime, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ClampMax"), TEXT("25"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ClampMin"), TEXT("1"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ToolTip"), TEXT("Max number of iterations used for each discrete simulation step.\nUsed primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).\nIncreasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationTimeStep"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("UIMax"), TEXT("25"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ClampMax"), TEXT("0.50"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ClampMin"), TEXT("0.0166"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ToolTip"), TEXT("Max time delta for each discrete simulation step.\nUsed primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).\nLowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationIterations"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("UIMax"), TEXT("0.50"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("UIMin"), TEXT("0.0166"));
				MetaData->SetValue(NewProp_AnalogInputModifier, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AnalogInputModifier, TEXT("ToolTip"), TEXT("Modifier to applied to values such as acceleration and max speed due to analog input."));
				MetaData->SetValue(NewProp_PendingForceToApply, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PendingForceToApply, TEXT("ToolTip"), TEXT("Accumulated force to be added next tick."));
				MetaData->SetValue(NewProp_PendingImpulseToApply, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PendingImpulseToApply, TEXT("ToolTip"), TEXT("Accumulated impulse to be added next tick."));
				MetaData->SetValue(NewProp_LastUpdateLocation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LastUpdateLocation, TEXT("ToolTip"), TEXT("Location after last PerformMovement update. Used internally to detect changes in position from outside character movement to try to validate the current floor."));
				MetaData->SetValue(NewProp_Acceleration, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_Acceleration, TEXT("ToolTip"), TEXT("Current acceleration vector (with magnitude).\nThis is calculated each update based on the input vector and the constraints of MaxAcceleration and the current movement mode."));
				MetaData->SetValue(NewProp_UpperImpactNormalScale, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CrouchedSpeedMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CrouchedSpeedMultiplier, TEXT("ToolTip"), TEXT("Multiplier to max ground speed to use when crouched"));
				MetaData->SetValue(NewProp_bForceBraking, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bForceBraking, TEXT("ToolTip"), TEXT("Deprecated properties"));
				MetaData->SetValue(NewProp_RepulsionForce, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_RepulsionForce, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_RepulsionForce, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_RepulsionForce, TEXT("ToolTip"), TEXT("Force per kg applied constantly to all overlapping components."));
				MetaData->SetValue(NewProp_MaxTouchForce, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_MaxTouchForce, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_MaxTouchForce, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxTouchForce, TEXT("ToolTip"), TEXT("Maximum force applied to touched physics objects. If < 0.0f, there is no maximum."));
				MetaData->SetValue(NewProp_MinTouchForce, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_MinTouchForce, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_MinTouchForce, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MinTouchForce, TEXT("ToolTip"), TEXT("Minimum Force applied to touched physics objects. If < 0.0f, there is no minimum."));
				MetaData->SetValue(NewProp_TouchForceFactor, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_TouchForceFactor, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_TouchForceFactor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_TouchForceFactor, TEXT("ToolTip"), TEXT("Force to apply to physics objects that are touched by the player."));
				MetaData->SetValue(NewProp_PushForcePointZOffsetFactor, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_PushForcePointZOffsetFactor, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_PushForcePointZOffsetFactor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PushForcePointZOffsetFactor, TEXT("ToolTip"), TEXT("Z-Offset for the position the force is applied to. 0.0f is the center of the physics object, 1.0f is the top and -1.0f is the bottom of the object."));
				MetaData->SetValue(NewProp_PushForcePointZOffsetFactor, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_PushForcePointZOffsetFactor, TEXT("UIMin"), TEXT("-1.0"));
				MetaData->SetValue(NewProp_PushForceFactor, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_PushForceFactor, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_PushForceFactor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PushForceFactor, TEXT("ToolTip"), TEXT("Force to apply when the player collides with a blocking physics object."));
				MetaData->SetValue(NewProp_InitialPushForceFactor, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_InitialPushForceFactor, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_InitialPushForceFactor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_InitialPushForceFactor, TEXT("ToolTip"), TEXT("Initial impulse force to apply when the player bounces into a blocking physics object."));
				MetaData->SetValue(NewProp_StandingDownwardForceScale, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_StandingDownwardForceScale, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_StandingDownwardForceScale, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_StandingDownwardForceScale, TEXT("ToolTip"), TEXT("Force applied to objects we stand on (due to Mass and Gravity) is scaled by this amount."));
				MetaData->SetValue(NewProp_bScalePushForceToVelocity, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_bScalePushForceToVelocity, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_bScalePushForceToVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bScalePushForceToVelocity, TEXT("ToolTip"), TEXT("If enabled, the applied push force will try to get the physics object to the same velocity than the player, not faster. This will only\n              scale the force down, it will never apply more force than defined by PushForceFactor."));
				MetaData->SetValue(NewProp_bPushForceScaledToMass, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_bPushForceScaledToMass, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_bPushForceScaledToMass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bPushForceScaledToMass, TEXT("ToolTip"), TEXT("If enabled, the PushForceFactor is applied per kg mass of the affected object."));
				MetaData->SetValue(NewProp_bTouchForceScaledToMass, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_bTouchForceScaledToMass, TEXT("editcondition"), TEXT("bEnablePhysicsInteraction"));
				MetaData->SetValue(NewProp_bTouchForceScaledToMass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bTouchForceScaledToMass, TEXT("ToolTip"), TEXT("If enabled, the TouchForceFactor is applied per kg mass of the affected object."));
				MetaData->SetValue(NewProp_bEnablePhysicsInteraction, TEXT("Category"), TEXT("Character Movement: Physics Interaction"));
				MetaData->SetValue(NewProp_bEnablePhysicsInteraction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bEnablePhysicsInteraction, TEXT("ToolTip"), TEXT("If enabled, the player will interact with physics objects when walking into them."));
				MetaData->SetValue(NewProp_Mass, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_Mass, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Mass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_Mass, TEXT("ToolTip"), TEXT("Mass of pawn (for when momentum is imparted to it)."));
				MetaData->SetValue(NewProp_Mass, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_OutofWaterZ, TEXT("Category"), TEXT("Character Movement: Swimming"));
				MetaData->SetValue(NewProp_OutofWaterZ, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_OutofWaterZ, TEXT("ToolTip"), TEXT("Z velocity applied when pawn tries to get out of water"));
				MetaData->SetValue(NewProp_MaxOutOfWaterStepHeight, TEXT("Category"), TEXT("Character Movement: Swimming"));
				MetaData->SetValue(NewProp_MaxOutOfWaterStepHeight, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxOutOfWaterStepHeight, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxOutOfWaterStepHeight, TEXT("ToolTip"), TEXT("Maximum step height for getting out of water"));
				MetaData->SetValue(NewProp_MaxOutOfWaterStepHeight, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_DeferredUpdatedMoveComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DeferredUpdatedMoveComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_DeferredUpdatedMoveComponent, TEXT("ToolTip"), TEXT("What to update CharacterOwner and UpdatedComponent after movement ends"));
				MetaData->SetValue(NewProp_bDeferUpdateMoveComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bDeferUpdateMoveComponent, TEXT("ToolTip"), TEXT("true to update CharacterOwner and UpdatedComponent after movement ends"));
				MetaData->SetValue(NewProp_bCanWalkOffLedgesWhenCrouching, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bCanWalkOffLedgesWhenCrouching, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bCanWalkOffLedgesWhenCrouching, TEXT("ToolTip"), TEXT("If true, Character can walk off a ledge when crouching."));
				MetaData->SetValue(NewProp_bCanWalkOffLedges, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bCanWalkOffLedges, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bCanWalkOffLedges, TEXT("ToolTip"), TEXT("If true, Character can walk off a ledge."));
				MetaData->SetValue(NewProp_bShrinkProxyCapsule, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bShrinkProxyCapsule, TEXT("ToolTip"), TEXT("If true, the capsule needs to be shrunk on this simulated proxy, to avoid replication rounding putting us in geometry.\nWhenever this is set to true, this will cause the capsule to be shrunk again on the next update, and then set to false."));
				MetaData->SetValue(NewProp_bForceNextFloorCheck, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_bForceNextFloorCheck, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bForceNextFloorCheck, TEXT("ToolTip"), TEXT("Force the Character in MOVE_Walking to do a check for a valid floor even if he hasn't moved. Cleared after next floor check.\nNormally if bAlwaysCheckFloor is false we try to avoid the floor check unless some conditions are met, but this can be used to force the next check to always run."));
				MetaData->SetValue(NewProp_bRunPhysicsWithNoController, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bRunPhysicsWithNoController, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bRunPhysicsWithNoController, TEXT("ToolTip"), TEXT("If true, movement will be performed even if there is no Controller for the Character owner.\nNormally without a Controller, movement will be aborted and velocity and acceleration are zeroed if the character is walking.\nCharacters that are spawned without a Controller but with this flag enabled will initialize the movement mode to DefaultLandMovementMode or DefaultWaterMovementMode appropriately.\n@see DefaultLandMovementMode, DefaultWaterMovementMode"));
				MetaData->SetValue(NewProp_bForceMaxAccel, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bForceMaxAccel, TEXT("ToolTip"), TEXT("Ignores size of acceleration component, and forces max acceleration to drive character at full velocity."));
				MetaData->SetValue(NewProp_bEnableScopedMovementUpdates, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bEnableScopedMovementUpdates, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bEnableScopedMovementUpdates, TEXT("ToolTip"), TEXT("If true, high-level movement updates will be wrapped in a movement scope that accumulates updates and defers a bulk of the work until the end.\nWhen enabled, touch and hit events will not be triggered until the end of multiple moves within an update, which can improve performance.\n\n@see FScopedMovementUpdate"));
				MetaData->SetValue(NewProp_bMovementInProgress, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bMovementInProgress, TEXT("ToolTip"), TEXT("True during movement update.\nUsed internally so that attempts to change CharacterOwner and UpdatedComponent are deferred until after an update.\n@see IsMovementInProgress()"));
				MetaData->SetValue(NewProp_bOrientRotationToMovement, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bOrientRotationToMovement, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bOrientRotationToMovement, TEXT("ToolTip"), TEXT("If true, rotate the Character toward the direction of acceleration, using RotationRate as the rate of rotation change. Overrides UseControllerDesiredRotation.\nNormally you will want to make sure that other settings are cleared, such as bUseControllerRotationYaw on the Character."));
				MetaData->SetValue(NewProp_bUseControllerDesiredRotation, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bUseControllerDesiredRotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bUseControllerDesiredRotation, TEXT("ToolTip"), TEXT("If true, smoothly rotate the Character toward the Controller's desired rotation, using RotationRate as the rate of rotation change. Overridden by OrientRotationToMovement."));
				MetaData->SetValue(NewProp_RotationRate, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_RotationRate, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_RotationRate, TEXT("ToolTip"), TEXT("Change in rotation per second, used when UseControllerDesiredRotation or OrientRotationToMovement are true."));
				MetaData->SetValue(NewProp_PerchAdditionalHeight, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_PerchAdditionalHeight, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_PerchAdditionalHeight, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PerchAdditionalHeight, TEXT("ToolTip"), TEXT("When perching on a ledge, add this additional distance to MaxStepHeight when determining how high above a walkable floor we can perch.\nNote that we still enforce MaxStepHeight to start the step up; this just allows the character to hang off the edge or step slightly higher off the floor.\n(@see PerchRadiusThreshold)"));
				MetaData->SetValue(NewProp_PerchAdditionalHeight, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_PerchRadiusThreshold, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_PerchRadiusThreshold, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_PerchRadiusThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_PerchRadiusThreshold, TEXT("ToolTip"), TEXT("Don't allow the character to perch on the edge of a surface if the contact is this close to the edge of the capsule.\nNote that characters will not fall off if they are within MaxStepHeight of a walkable surface below."));
				MetaData->SetValue(NewProp_PerchRadiusThreshold, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Buoyancy, TEXT("Category"), TEXT("Character Movement: Swimming"));
				MetaData->SetValue(NewProp_Buoyancy, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_Buoyancy, TEXT("ToolTip"), TEXT("Water buoyancy. A ratio (1.0 = neutral buoyancy, 0.0 = no buoyancy)"));
				MetaData->SetValue(NewProp_CrouchedHalfHeight, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_CrouchedHalfHeight, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CrouchedHalfHeight, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CrouchedHalfHeight, TEXT("ToolTip"), TEXT("Collision half-height when crouching (component scale is applied separately)"));
				MetaData->SetValue(NewProp_CrouchedHalfHeight, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_FallingLateralFriction, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_FallingLateralFriction, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_FallingLateralFriction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_FallingLateralFriction, TEXT("ToolTip"), TEXT("Friction to apply to lateral air movement when falling.\nIf bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero).\n@see BrakingFriction, bUseSeparateBrakingFriction"));
				MetaData->SetValue(NewProp_FallingLateralFriction, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_AirControlBoostVelocityThreshold, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_AirControlBoostVelocityThreshold, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_AirControlBoostVelocityThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AirControlBoostVelocityThreshold, TEXT("ToolTip"), TEXT("When falling, if lateral velocity magnitude is less than this value, AirControl is multiplied by AirControlBoostMultiplier.\nSetting this to zero will disable air control boosting."));
				MetaData->SetValue(NewProp_AirControlBoostVelocityThreshold, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_AirControlBoostMultiplier, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_AirControlBoostMultiplier, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_AirControlBoostMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AirControlBoostMultiplier, TEXT("ToolTip"), TEXT("When falling, multiplier applied to AirControl when lateral velocity is less than AirControlBoostVelocityThreshold.\nSetting this to zero will disable air control boosting. Final result is clamped at 1."));
				MetaData->SetValue(NewProp_AirControlBoostMultiplier, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_AirControl, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_AirControl, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_AirControl, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AirControl, TEXT("ToolTip"), TEXT("When falling, amount of lateral movement control available to the character.\n0 = no control, 1 = full control at max speed of MaxWalkSpeed."));
				MetaData->SetValue(NewProp_AirControl, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationFlying, TEXT("Category"), TEXT("Character Movement: Flying"));
				MetaData->SetValue(NewProp_BrakingDecelerationFlying, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationFlying, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakingDecelerationFlying, TEXT("ToolTip"), TEXT("Deceleration when flying and not applying acceleration.\n@see MaxAcceleration"));
				MetaData->SetValue(NewProp_BrakingDecelerationFlying, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationSwimming, TEXT("Category"), TEXT("Character Movement: Swimming"));
				MetaData->SetValue(NewProp_BrakingDecelerationSwimming, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationSwimming, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakingDecelerationSwimming, TEXT("ToolTip"), TEXT("Deceleration when swimming and not applying acceleration.\n@see MaxAcceleration"));
				MetaData->SetValue(NewProp_BrakingDecelerationSwimming, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationFalling, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_BrakingDecelerationFalling, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationFalling, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakingDecelerationFalling, TEXT("ToolTip"), TEXT("Lateral deceleration when falling and not applying acceleration.\n@see MaxAcceleration"));
				MetaData->SetValue(NewProp_BrakingDecelerationFalling, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationWalking, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_BrakingDecelerationWalking, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingDecelerationWalking, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakingDecelerationWalking, TEXT("ToolTip"), TEXT("Deceleration when walking and not applying acceleration. This is a constant opposing force that directly lowers velocity by a constant value.\n@see GroundFriction, MaxAcceleration"));
				MetaData->SetValue(NewProp_BrakingDecelerationWalking, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_bUseSeparateBrakingFriction, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_bUseSeparateBrakingFriction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bUseSeparateBrakingFriction, TEXT("ToolTip"), TEXT("If true, BrakingFriction will be used to slow the character to a stop (when there is no Acceleration).\nIf false, braking uses the same friction passed to CalcVelocity() (ie GroundFriction when walking), multiplied by BrakingFrictionFactor.\nThis setting applies to all movement modes; if only desired in certain modes, consider toggling it when movement modes change.\n@see BrakingFriction"));
				MetaData->SetValue(NewProp_BrakingFriction, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_BrakingFriction, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingFriction, TEXT("EditCondition"), TEXT("bUseSeparateBrakingFriction"));
				MetaData->SetValue(NewProp_BrakingFriction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakingFriction, TEXT("ToolTip"), TEXT("Friction (drag) coefficient applied when braking (whenever Acceleration = 0, or if character is exceeding max speed); actual value used is this multiplied by BrakingFrictionFactor.\nWhen braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.\nBraking is composed of friction (velocity-dependent drag) and constant deceleration.\nThis is the current value, used in all movement modes; if this is not desired, override it or bUseSeparateBrakingFriction when movement mode changes.\n@note Only used if bUseSeparateBrakingFriction setting is true, otherwise current friction such as GroundFriction is used.\n@see bUseSeparateBrakingFriction, BrakingFrictionFactor, GroundFriction, BrakingDecelerationWalking"));
				MetaData->SetValue(NewProp_BrakingFriction, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingFrictionFactor, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_BrakingFrictionFactor, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_BrakingFrictionFactor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakingFrictionFactor, TEXT("ToolTip"), TEXT("Factor used to multiply actual value of friction used when braking.\nThis applies to any friction value that is currently used, which may depend on bUseSeparateBrakingFriction.\n@note This is 2 by default for historical reasons, a value of 1 gives the true drag equation.\n@see bUseSeparateBrakingFriction, GroundFriction, BrakingFriction"));
				MetaData->SetValue(NewProp_BrakingFrictionFactor, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxAcceleration, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_MaxAcceleration, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxAcceleration, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxAcceleration, TEXT("ToolTip"), TEXT("Max Acceleration (rate of change of velocity)"));
				MetaData->SetValue(NewProp_MaxAcceleration, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxCustomMovementSpeed, TEXT("Category"), TEXT("Character Movement: Custom Movement"));
				MetaData->SetValue(NewProp_MaxCustomMovementSpeed, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxCustomMovementSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxCustomMovementSpeed, TEXT("ToolTip"), TEXT("The maximum speed when using Custom movement mode."));
				MetaData->SetValue(NewProp_MaxCustomMovementSpeed, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxFlySpeed, TEXT("Category"), TEXT("Character Movement: Flying"));
				MetaData->SetValue(NewProp_MaxFlySpeed, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxFlySpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxFlySpeed, TEXT("ToolTip"), TEXT("The maximum flying speed."));
				MetaData->SetValue(NewProp_MaxFlySpeed, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxSwimSpeed, TEXT("Category"), TEXT("Character Movement: Swimming"));
				MetaData->SetValue(NewProp_MaxSwimSpeed, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxSwimSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSwimSpeed, TEXT("ToolTip"), TEXT("The maximum swimming speed."));
				MetaData->SetValue(NewProp_MaxSwimSpeed, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxWalkSpeedCrouched, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_MaxWalkSpeedCrouched, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxWalkSpeedCrouched, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxWalkSpeedCrouched, TEXT("ToolTip"), TEXT("The maximum ground speed when walking and crouched."));
				MetaData->SetValue(NewProp_MaxWalkSpeedCrouched, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxWalkSpeed, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_MaxWalkSpeed, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxWalkSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxWalkSpeed, TEXT("ToolTip"), TEXT("The maximum ground speed when walking. Also determines maximum lateral speed when falling."));
				MetaData->SetValue(NewProp_MaxWalkSpeed, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_GroundFriction, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_GroundFriction, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_GroundFriction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_GroundFriction, TEXT("ToolTip"), TEXT("Setting that affects movement control. Higher values allow faster changes in direction.\nIf bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero), where it is multiplied by BrakingFrictionFactor.\nWhen braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.\nThis can be used to simulate slippery surfaces such as ice or oil by changing the value (possibly based on the material pawn is standing on).\n@see BrakingDecelerationWalking, BrakingFriction, bUseSeparateBrakingFriction, BrakingFrictionFactor"));
				MetaData->SetValue(NewProp_GroundFriction, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("Category"), TEXT("Character Movement: MovementMode"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("ToolTip"), TEXT("Current custom sub-mode if MovementMode is set to Custom.\nThis is automatically replicated through the Character owner and for client-server movement functions.\n@see SetMovementMode()"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("Category"), TEXT("Character Movement: MovementMode"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("ToolTip"), TEXT("Actor's current movement mode (walking, falling, etc).\n   - walking:  Walking on a surface, under the effects of friction, and able to \"step up\" barriers. Vertical velocity is zero.\n   - falling:  Falling under the effects of gravity, after jumping or walking off the edge of a surface.\n   - flying:   Flying, ignoring the effects of gravity.\n   - swimming: Swimming through a fluid volume, under the effects of gravity and buoyancy.\n   - custom:   User-defined custom movement mode, including many possible sub-modes.\nThis is automatically replicated through the Character owner and for client-server movement functions.\n@see SetMovementMode(), CustomMovementMode"));
				MetaData->SetValue(NewProp_WalkableFloorZ, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_WalkableFloorZ, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_WalkableFloorZ, TEXT("ToolTip"), TEXT("Minimum Z value for floor normal. If less, not a walkable surface. Computed from WalkableFloorAngle."));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("ClampMax"), TEXT("90.0"));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("ToolTip"), TEXT("Max angle in degrees of a walkable surface. Any greater than this and it is too steep to be walkable."));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("UIMax"), TEXT("90.0"));
				MetaData->SetValue(NewProp_WalkableFloorAngle, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_JumpOffJumpZFactor, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_JumpOffJumpZFactor, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_JumpOffJumpZFactor, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_JumpOffJumpZFactor, TEXT("ToolTip"), TEXT("Fraction of JumpZVelocity to use when automatically \"jumping off\" of a base actor that's not allowed to be a base for a character. (For example, if you're not allowed to stand on other players.)"));
				MetaData->SetValue(NewProp_JumpOffJumpZFactor, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_JumpZVelocity, TEXT("Category"), TEXT("Character Movement: Jumping / Falling"));
				MetaData->SetValue(NewProp_JumpZVelocity, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_JumpZVelocity, TEXT("DisplayName"), TEXT("Jump Z Velocity"));
				MetaData->SetValue(NewProp_JumpZVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_JumpZVelocity, TEXT("ToolTip"), TEXT("Initial velocity (instantaneous vertical acceleration) when jumping."));
				MetaData->SetValue(NewProp_JumpZVelocity, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxStepHeight, TEXT("Category"), TEXT("Character Movement: Walking"));
				MetaData->SetValue(NewProp_MaxStepHeight, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_MaxStepHeight, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxStepHeight, TEXT("ToolTip"), TEXT("Maximum height character can step up"));
				MetaData->SetValue(NewProp_MaxStepHeight, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_GravityScale, TEXT("Category"), TEXT("Character Movement (General Settings)"));
				MetaData->SetValue(NewProp_GravityScale, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_GravityScale, TEXT("ToolTip"), TEXT("Custom gravity scale. Gravity is multiplied by this amount for the character."));
				MetaData->SetValue(NewProp_CharacterOwner, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/CharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CharacterOwner, TEXT("ToolTip"), TEXT("Character movement component belongs to"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UCharacterMovementComponent(Z_Construct_UClass_UCharacterMovementComponent, TEXT("UCharacterMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UCharacterMovementComponent);
	UClass* Z_Construct_UClass_UFloatingPawnMovement_NoRegister()
	{
		return UFloatingPawnMovement::StaticClass();
	}
	UClass* Z_Construct_UClass_UFloatingPawnMovement()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPawnMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UFloatingPawnMovement::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPositionCorrected, UFloatingPawnMovement, uint8);
				UProperty* NewProp_bPositionCorrected = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPositionCorrected"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPositionCorrected, UFloatingPawnMovement), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bPositionCorrected, UFloatingPawnMovement), sizeof(uint8), false);
				UProperty* NewProp_TurningBoost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TurningBoost"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TurningBoost, UFloatingPawnMovement), 0x0000000000000005);
				UProperty* NewProp_Deceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Deceleration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Deceleration, UFloatingPawnMovement), 0x0000000000000005);
				UProperty* NewProp_Acceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Acceleration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Acceleration, UFloatingPawnMovement), 0x0000000000000005);
				UProperty* NewProp_MaxSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSpeed, UFloatingPawnMovement), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("FloatingPawnMovement is a movement component that provides simple movement for any Pawn class.\nLimits on speed and acceleration are provided, while gravity is not implemented.\n\nNormally the root component of the owning actor is moved, however another component may be selected (see SetUpdatedComponent()).\nDuring swept (non-teleporting) movement only collision of UpdatedComponent is considered, attached components will teleport to the end location ignoring collision."));
				MetaData->SetValue(NewProp_bPositionCorrected, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(NewProp_bPositionCorrected, TEXT("ToolTip"), TEXT("Set to true when a position correction is applied. Used to avoid recalculating velocity when this occurs."));
				MetaData->SetValue(NewProp_TurningBoost, TEXT("Category"), TEXT("FloatingPawnMovement"));
				MetaData->SetValue(NewProp_TurningBoost, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_TurningBoost, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(NewProp_TurningBoost, TEXT("ToolTip"), TEXT("Setting affecting extra force applied when changing direction, making turns have less drift and become more responsive.\nVelocity magnitude is not allowed to increase, that only happens due to normal acceleration. It may decrease with large direction changes.\nLarger values apply extra force to reach the target direction more quickly, while a zero value disables any extra turn force."));
				MetaData->SetValue(NewProp_TurningBoost, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Deceleration, TEXT("Category"), TEXT("FloatingPawnMovement"));
				MetaData->SetValue(NewProp_Deceleration, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(NewProp_Deceleration, TEXT("ToolTip"), TEXT("Deceleration applied when there is no input (rate of change of velocity)"));
				MetaData->SetValue(NewProp_Acceleration, TEXT("Category"), TEXT("FloatingPawnMovement"));
				MetaData->SetValue(NewProp_Acceleration, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(NewProp_Acceleration, TEXT("ToolTip"), TEXT("Acceleration applied by input (rate of change of velocity)"));
				MetaData->SetValue(NewProp_MaxSpeed, TEXT("Category"), TEXT("FloatingPawnMovement"));
				MetaData->SetValue(NewProp_MaxSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/FloatingPawnMovement.h"));
				MetaData->SetValue(NewProp_MaxSpeed, TEXT("ToolTip"), TEXT("Maximum velocity magnitude allowed for the controlled Pawn."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UFloatingPawnMovement(Z_Construct_UClass_UFloatingPawnMovement, TEXT("UFloatingPawnMovement"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UFloatingPawnMovement);
	UClass* Z_Construct_UClass_USpectatorPawnMovement_NoRegister()
	{
		return USpectatorPawnMovement::StaticClass();
	}
	UClass* Z_Construct_UClass_USpectatorPawnMovement()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UFloatingPawnMovement();
			Z_Construct_UPackage_Engine();
			OuterClass = USpectatorPawnMovement::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreTimeDilation, USpectatorPawnMovement, uint8);
				UProperty* NewProp_bIgnoreTimeDilation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreTimeDilation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreTimeDilation, USpectatorPawnMovement), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bIgnoreTimeDilation, USpectatorPawnMovement), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/SpectatorPawnMovement.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpectatorPawnMovement.h"));
				MetaData->SetValue(NewProp_bIgnoreTimeDilation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpectatorPawnMovement.h"));
				MetaData->SetValue(NewProp_bIgnoreTimeDilation, TEXT("ToolTip"), TEXT("If true, component moves at full speed no matter the time dilation. Default is false."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USpectatorPawnMovement(Z_Construct_UClass_USpectatorPawnMovement, TEXT("USpectatorPawnMovement"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USpectatorPawnMovement);
	UScriptStruct* Z_Construct_UScriptStruct_FVehicleInputRate()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FVehicleInputRate_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("VehicleInputRate"), sizeof(FVehicleInputRate), Get_Z_Construct_UScriptStruct_FVehicleInputRate_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VehicleInputRate"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FVehicleInputRate>, EStructFlags(0x00000201));
			UProperty* NewProp_FallRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FallRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FallRate, FVehicleInputRate), 0x0000000000000001);
			UProperty* NewProp_RiseRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RiseRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RiseRate, FVehicleInputRate), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_FallRate, TEXT("Category"), TEXT("VehicleInputRate"));
			MetaData->SetValue(NewProp_FallRate, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_FallRate, TEXT("ToolTip"), TEXT("Rate at which the input value falls"));
			MetaData->SetValue(NewProp_RiseRate, TEXT("Category"), TEXT("VehicleInputRate"));
			MetaData->SetValue(NewProp_RiseRate, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_RiseRate, TEXT("ToolTip"), TEXT("Rate at which the input value rises"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVehicleInputRate_CRC() { return 4020157610U; }
	UScriptStruct* Z_Construct_UScriptStruct_FReplicatedVehicleState()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FReplicatedVehicleState_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ReplicatedVehicleState"), sizeof(FReplicatedVehicleState), Get_Z_Construct_UScriptStruct_FReplicatedVehicleState_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReplicatedVehicleState"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FReplicatedVehicleState>, EStructFlags(0x00000201));
			UProperty* NewProp_CurrentGear = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CurrentGear"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(CurrentGear, FReplicatedVehicleState), 0x0000000000000000);
			UProperty* NewProp_HandbrakeInput = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("HandbrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HandbrakeInput, FReplicatedVehicleState), 0x0000000000000000);
			UProperty* NewProp_BrakeInput = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakeInput, FReplicatedVehicleState), 0x0000000000000000);
			UProperty* NewProp_ThrottleInput = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ThrottleInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ThrottleInput, FReplicatedVehicleState), 0x0000000000000000);
			UProperty* NewProp_SteeringInput = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SteeringInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SteeringInput, FReplicatedVehicleState), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_CurrentGear, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_CurrentGear, TEXT("ToolTip"), TEXT("state replication: current gear"));
			MetaData->SetValue(NewProp_HandbrakeInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_HandbrakeInput, TEXT("ToolTip"), TEXT("input replication: handbrake"));
			MetaData->SetValue(NewProp_BrakeInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_BrakeInput, TEXT("ToolTip"), TEXT("input replication: brake"));
			MetaData->SetValue(NewProp_ThrottleInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_ThrottleInput, TEXT("ToolTip"), TEXT("input replication: throttle"));
			MetaData->SetValue(NewProp_SteeringInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_SteeringInput, TEXT("ToolTip"), TEXT("input replication: steering"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FReplicatedVehicleState_CRC() { return 4024225517U; }
	UScriptStruct* Z_Construct_UScriptStruct_FWheelSetup()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FWheelSetup_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("WheelSetup"), sizeof(FWheelSetup), Get_Z_Construct_UScriptStruct_FWheelSetup_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WheelSetup"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FWheelSetup>, EStructFlags(0x00000201));
			UProperty* NewProp_AdditionalOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AdditionalOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AdditionalOffset, FWheelSetup), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, FWheelSetup), 0x0000000000000001);
			UProperty* NewProp_WheelClass = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("WheelClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(WheelClass, FWheelSetup), 0x0004000000000001, Z_Construct_UClass_UVehicleWheel_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Vehicle-specific wheel setup"));
			MetaData->SetValue(NewProp_AdditionalOffset, TEXT("Category"), TEXT("WheelSetup"));
			MetaData->SetValue(NewProp_AdditionalOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_AdditionalOffset, TEXT("ToolTip"), TEXT("Additional offset to give the wheels for this axle."));
			MetaData->SetValue(NewProp_BoneName, TEXT("Category"), TEXT("WheelSetup"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ToolTip"), TEXT("Bone name on mesh to create wheel at"));
			MetaData->SetValue(NewProp_WheelClass, TEXT("Category"), TEXT("WheelSetup"));
			MetaData->SetValue(NewProp_WheelClass, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(NewProp_WheelClass, TEXT("ToolTip"), TEXT("The wheel class to use"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FWheelSetup_CRC() { return 1016002817U; }
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetCurrentGear()
	{
		struct WheeledVehicleMovementComponent_eventGetCurrentGear_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentGear"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(WheeledVehicleMovementComponent_eventGetCurrentGear_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, WheeledVehicleMovementComponent_eventGetCurrentGear_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get current gear"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineMaxRotationSpeed()
	{
		struct WheeledVehicleMovementComponent_eventGetEngineMaxRotationSpeed_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEngineMaxRotationSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(WheeledVehicleMovementComponent_eventGetEngineMaxRotationSpeed_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, WheeledVehicleMovementComponent_eventGetEngineMaxRotationSpeed_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get current engine's max rotation speed"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineRotationSpeed()
	{
		struct WheeledVehicleMovementComponent_eventGetEngineRotationSpeed_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEngineRotationSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(WheeledVehicleMovementComponent_eventGetEngineRotationSpeed_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, WheeledVehicleMovementComponent_eventGetEngineRotationSpeed_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get current engine's rotation speed"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetForwardSpeed()
	{
		struct WheeledVehicleMovementComponent_eventGetForwardSpeed_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetForwardSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(WheeledVehicleMovementComponent_eventGetForwardSpeed_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, WheeledVehicleMovementComponent_eventGetForwardSpeed_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How fast the vehicle is moving forward"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetTargetGear()
	{
		struct WheeledVehicleMovementComponent_eventGetTargetGear_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetGear"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(WheeledVehicleMovementComponent_eventGetTargetGear_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, WheeledVehicleMovementComponent_eventGetTargetGear_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get target gear"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetUseAutoGears()
	{
		struct WheeledVehicleMovementComponent_eventGetUseAutoGears_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUseAutoGears"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(WheeledVehicleMovementComponent_eventGetUseAutoGears_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, WheeledVehicleMovementComponent_eventGetUseAutoGears_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, WheeledVehicleMovementComponent_eventGetUseAutoGears_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, WheeledVehicleMovementComponent_eventGetUseAutoGears_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Are gears being changed automatically?"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_ServerUpdateState()
	{
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerUpdateState"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x80280CC0, 65535, sizeof(WheeledVehicleMovementComponent_eventServerUpdateState_Parms));
			UProperty* NewProp_CurrentGear = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CurrentGear"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(CurrentGear, WheeledVehicleMovementComponent_eventServerUpdateState_Parms), 0x0000000000000080);
			UProperty* NewProp_InHandbrakeInput = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InHandbrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InHandbrakeInput, WheeledVehicleMovementComponent_eventServerUpdateState_Parms), 0x0000000000000080);
			UProperty* NewProp_InBrakeInput = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InBrakeInput, WheeledVehicleMovementComponent_eventServerUpdateState_Parms), 0x0000000000000080);
			UProperty* NewProp_InThrottleInput = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InThrottleInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InThrottleInput, WheeledVehicleMovementComponent_eventServerUpdateState_Parms), 0x0000000000000080);
			UProperty* NewProp_InSteeringInput = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSteeringInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InSteeringInput, WheeledVehicleMovementComponent_eventServerUpdateState_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Pass current state to server"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceEnabled()
	{
		struct WheeledVehicleMovementComponent_eventSetAvoidanceEnabled_Parms
		{
			bool bEnable;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAvoidanceEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetAvoidanceEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnable, WheeledVehicleMovementComponent_eventSetAvoidanceEnabled_Parms, bool);
			UProperty* NewProp_bEnable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnable, WheeledVehicleMovementComponent_eventSetAvoidanceEnabled_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnable, WheeledVehicleMovementComponent_eventSetAvoidanceEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change avoidance state and register with RVO manager if necessary"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceGroup()
	{
		struct WheeledVehicleMovementComponent_eventSetAvoidanceGroup_Parms
		{
			int32 GroupFlags;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAvoidanceGroup"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetAvoidanceGroup_Parms));
			UProperty* NewProp_GroupFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GroupFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GroupFlags, WheeledVehicleMovementComponent_eventSetAvoidanceGroup_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearDown()
	{
		struct WheeledVehicleMovementComponent_eventSetGearDown_Parms
		{
			bool bNewGearDown;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGearDown"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetGearDown_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewGearDown, WheeledVehicleMovementComponent_eventSetGearDown_Parms, bool);
			UProperty* NewProp_bNewGearDown = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewGearDown"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewGearDown, WheeledVehicleMovementComponent_eventSetGearDown_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewGearDown, WheeledVehicleMovementComponent_eventSetGearDown_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the user input for gear down"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearUp()
	{
		struct WheeledVehicleMovementComponent_eventSetGearUp_Parms
		{
			bool bNewGearUp;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGearUp"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetGearUp_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewGearUp, WheeledVehicleMovementComponent_eventSetGearUp_Parms, bool);
			UProperty* NewProp_bNewGearUp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewGearUp"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewGearUp, WheeledVehicleMovementComponent_eventSetGearUp_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewGearUp, WheeledVehicleMovementComponent_eventSetGearUp_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the user input for gear up"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToAvoid()
	{
		struct WheeledVehicleMovementComponent_eventSetGroupsToAvoid_Parms
		{
			int32 GroupFlags;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGroupsToAvoid"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetGroupsToAvoid_Parms));
			UProperty* NewProp_GroupFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GroupFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GroupFlags, WheeledVehicleMovementComponent_eventSetGroupsToAvoid_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToIgnore()
	{
		struct WheeledVehicleMovementComponent_eventSetGroupsToIgnore_Parms
		{
			int32 GroupFlags;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGroupsToIgnore"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetGroupsToIgnore_Parms));
			UProperty* NewProp_GroupFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GroupFlags"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GroupFlags, WheeledVehicleMovementComponent_eventSetGroupsToIgnore_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Pawn|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetHandbrakeInput()
	{
		struct WheeledVehicleMovementComponent_eventSetHandbrakeInput_Parms
		{
			bool bNewHandbrake;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetHandbrakeInput"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetHandbrakeInput_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewHandbrake, WheeledVehicleMovementComponent_eventSetHandbrakeInput_Parms, bool);
			UProperty* NewProp_bNewHandbrake = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewHandbrake"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewHandbrake, WheeledVehicleMovementComponent_eventSetHandbrakeInput_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewHandbrake, WheeledVehicleMovementComponent_eventSetHandbrakeInput_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the user input for handbrake"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetSteeringInput()
	{
		struct WheeledVehicleMovementComponent_eventSetSteeringInput_Parms
		{
			float Steering;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSteeringInput"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetSteeringInput_Parms));
			UProperty* NewProp_Steering = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Steering"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Steering, WheeledVehicleMovementComponent_eventSetSteeringInput_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the user input for the vehicle steering"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetTargetGear()
	{
		struct WheeledVehicleMovementComponent_eventSetTargetGear_Parms
		{
			int32 GearNum;
			bool bImmediate;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTargetGear"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetTargetGear_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bImmediate, WheeledVehicleMovementComponent_eventSetTargetGear_Parms, bool);
			UProperty* NewProp_bImmediate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bImmediate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bImmediate, WheeledVehicleMovementComponent_eventSetTargetGear_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bImmediate, WheeledVehicleMovementComponent_eventSetTargetGear_Parms), sizeof(bool), true);
			UProperty* NewProp_GearNum = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GearNum"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(GearNum, WheeledVehicleMovementComponent_eventSetTargetGear_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the user input for gear (-1 reverse, 0 neutral, 1+ forward)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetThrottleInput()
	{
		struct WheeledVehicleMovementComponent_eventSetThrottleInput_Parms
		{
			float Throttle;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetThrottleInput"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetThrottleInput_Parms));
			UProperty* NewProp_Throttle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Throttle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Throttle, WheeledVehicleMovementComponent_eventSetThrottleInput_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the user input for the vehicle throttle"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetUseAutoGears()
	{
		struct WheeledVehicleMovementComponent_eventSetUseAutoGears_Parms
		{
			bool bUseAuto;
		};
		UObject* Outer=Z_Construct_UClass_UWheeledVehicleMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetUseAutoGears"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(WheeledVehicleMovementComponent_eventSetUseAutoGears_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseAuto, WheeledVehicleMovementComponent_eventSetUseAutoGears_Parms, bool);
			UProperty* NewProp_bUseAuto = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUseAuto"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseAuto, WheeledVehicleMovementComponent_eventSetUseAutoGears_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUseAuto, WheeledVehicleMovementComponent_eventSetUseAutoGears_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|WheeledVehicleMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the flag that will be used to select auto-gears"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent_NoRegister()
	{
		return UWheeledVehicleMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPawnMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UWheeledVehicleMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetCurrentGear());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineMaxRotationSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineRotationSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetForwardSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetTargetGear());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetUseAutoGears());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_ServerUpdateState());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceGroup());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearDown());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearUp());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToAvoid());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToIgnore());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetHandbrakeInput());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetSteeringInput());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetTargetGear());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetThrottleInput());
				OuterClass->LinkChild(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetUseAutoGears());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWasAvoidanceUpdated, UWheeledVehicleMovementComponent, uint8);
				UProperty* NewProp_bWasAvoidanceUpdated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWasAvoidanceUpdated"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWasAvoidanceUpdated, UWheeledVehicleMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bWasAvoidanceUpdated, UWheeledVehicleMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_SteeringInputRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SteeringInputRate"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SteeringInputRate, UWheeledVehicleMovementComponent), 0x00000c0000000001, Z_Construct_UScriptStruct_FVehicleInputRate());
				UProperty* NewProp_HandbrakeInputRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HandbrakeInputRate"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HandbrakeInputRate, UWheeledVehicleMovementComponent), 0x00000c0000000001, Z_Construct_UScriptStruct_FVehicleInputRate());
				UProperty* NewProp_BrakeInputRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakeInputRate"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BrakeInputRate, UWheeledVehicleMovementComponent), 0x00000c0000000001, Z_Construct_UScriptStruct_FVehicleInputRate());
				UProperty* NewProp_ThrottleInputRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThrottleInputRate"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ThrottleInputRate, UWheeledVehicleMovementComponent), 0x00000c0000000001, Z_Construct_UScriptStruct_FVehicleInputRate());
				UProperty* NewProp_WrongDirectionThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WrongDirectionThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WrongDirectionThreshold, UWheeledVehicleMovementComponent), 0x0000080000000001);
				UProperty* NewProp_StopThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StopThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StopThreshold, UWheeledVehicleMovementComponent), 0x0000080000000001);
				UProperty* NewProp_IdleBrakeInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IdleBrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(IdleBrakeInput, UWheeledVehicleMovementComponent), 0x0000080000000001);
				UProperty* NewProp_HandbrakeInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HandbrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HandbrakeInput, UWheeledVehicleMovementComponent), 0x0000080000002000);
				UProperty* NewProp_BrakeInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrakeInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BrakeInput, UWheeledVehicleMovementComponent), 0x0000080000002000);
				UProperty* NewProp_ThrottleInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThrottleInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ThrottleInput, UWheeledVehicleMovementComponent), 0x0000080000002000);
				UProperty* NewProp_SteeringInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SteeringInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SteeringInput, UWheeledVehicleMovementComponent), 0x0000080000002000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRawGearDownInput, UWheeledVehicleMovementComponent, uint8);
				UProperty* NewProp_bRawGearDownInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRawGearDownInput"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRawGearDownInput, UWheeledVehicleMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bRawGearDownInput, UWheeledVehicleMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRawGearUpInput, UWheeledVehicleMovementComponent, uint8);
				UProperty* NewProp_bRawGearUpInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRawGearUpInput"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRawGearUpInput, UWheeledVehicleMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bRawGearUpInput, UWheeledVehicleMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRawHandbrakeInput, UWheeledVehicleMovementComponent, uint8);
				UProperty* NewProp_bRawHandbrakeInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRawHandbrakeInput"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRawHandbrakeInput, UWheeledVehicleMovementComponent), 0x0000080000002000, CPP_BOOL_PROPERTY_BITMASK(bRawHandbrakeInput, UWheeledVehicleMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_RawThrottleInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RawThrottleInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RawThrottleInput, UWheeledVehicleMovementComponent), 0x0000080000002000);
				UProperty* NewProp_RawSteeringInput = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RawSteeringInput"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RawSteeringInput, UWheeledVehicleMovementComponent), 0x0000080000002000);
				UProperty* NewProp_ReplicatedState = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedState"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReplicatedState, UWheeledVehicleMovementComponent), 0x0000080000002020, Z_Construct_UScriptStruct_FReplicatedVehicleState());
				UProperty* NewProp_PendingLaunchVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PendingLaunchVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PendingLaunchVelocity, UWheeledVehicleMovementComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_AvoidanceWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AvoidanceWeight, UWheeledVehicleMovementComponent), 0x0000000000000015);
				UProperty* NewProp_GroupsToIgnore = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroupsToIgnore"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GroupsToIgnore, UWheeledVehicleMovementComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FNavAvoidanceMask());
				UProperty* NewProp_GroupsToAvoid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroupsToAvoid"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GroupsToAvoid, UWheeledVehicleMovementComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FNavAvoidanceMask());
				UProperty* NewProp_AvoidanceGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceGroup"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AvoidanceGroup, UWheeledVehicleMovementComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FNavAvoidanceMask());
				UProperty* NewProp_AvoidanceUID = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceUID"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(AvoidanceUID, UWheeledVehicleMovementComponent), 0x0000040000020015);
				UProperty* NewProp_RVOThrottleStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RVOThrottleStep"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RVOThrottleStep, UWheeledVehicleMovementComponent), 0x0000000000000005);
				UProperty* NewProp_RVOSteeringStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RVOSteeringStep"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RVOSteeringStep, UWheeledVehicleMovementComponent), 0x0000000000000005);
				UProperty* NewProp_AvoidanceConsiderationRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceConsiderationRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AvoidanceConsiderationRadius, UWheeledVehicleMovementComponent), 0x0000000000000005);
				UProperty* NewProp_RVOAvoidanceHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RVOAvoidanceHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RVOAvoidanceHeight, UWheeledVehicleMovementComponent), 0x0000000000000005);
				UProperty* NewProp_RVOAvoidanceRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RVOAvoidanceRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RVOAvoidanceRadius, UWheeledVehicleMovementComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseRVOAvoidance, UWheeledVehicleMovementComponent, uint8);
				UProperty* NewProp_bUseRVOAvoidance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseRVOAvoidance"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseRVOAvoidance, UWheeledVehicleMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseRVOAvoidance, UWheeledVehicleMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_Wheels = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Wheels"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Wheels, UWheeledVehicleMovementComponent), 0x0000000000202014);
				UProperty* NewProp_Wheels_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Wheels, TEXT("Wheels"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UVehicleWheel_NoRegister());
				UProperty* NewProp_HighForwardSpeedSubStepCount = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HighForwardSpeedSubStepCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HighForwardSpeedSubStepCount, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_LowForwardSpeedSubStepCount = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LowForwardSpeedSubStepCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(LowForwardSpeedSubStepCount, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_ThresholdLongitudinalSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThresholdLongitudinalSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ThresholdLongitudinalSpeed, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_MaxNormalizedTireLoadFiltered = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxNormalizedTireLoadFiltered"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxNormalizedTireLoadFiltered, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_MaxNormalizedTireLoad = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxNormalizedTireLoad"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxNormalizedTireLoad, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_MinNormalizedTireLoadFiltered = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinNormalizedTireLoadFiltered"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinNormalizedTireLoadFiltered, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_MinNormalizedTireLoad = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinNormalizedTireLoad"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinNormalizedTireLoad, UWheeledVehicleMovementComponent), 0x0000040000000001);
				UProperty* NewProp_InertiaTensorScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InertiaTensorScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InertiaTensorScale, UWheeledVehicleMovementComponent), 0x0000040000000001, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_DebugDragMagnitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugDragMagnitude"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DebugDragMagnitude, UWheeledVehicleMovementComponent), 0x0000000000002000);
				UProperty* NewProp_MaxEngineRPM = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxEngineRPM"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxEngineRPM, UWheeledVehicleMovementComponent), 0x0000000000002000);
				UProperty* NewProp_EstimatedMaxEngineSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EstimatedMaxEngineSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(EstimatedMaxEngineSpeed, UWheeledVehicleMovementComponent), 0x0000000000002000);
				UProperty* NewProp_DragArea = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DragArea"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DragArea, UWheeledVehicleMovementComponent), 0x0000000000002000);
				UProperty* NewProp_ChassisHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChassisHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ChassisHeight, UWheeledVehicleMovementComponent), 0x0000000000000001);
				UProperty* NewProp_ChassisWidth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChassisWidth"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ChassisWidth, UWheeledVehicleMovementComponent), 0x0000000000000001);
				UProperty* NewProp_DragCoefficient = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DragCoefficient"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DragCoefficient, UWheeledVehicleMovementComponent), 0x0000000000000001);
				UProperty* NewProp_Mass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mass"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Mass, UWheeledVehicleMovementComponent), 0x0000000000000001);
				UProperty* NewProp_WheelSetups = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WheelSetups"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(WheelSetups, UWheeledVehicleMovementComponent), 0x0000000000000001);
				UProperty* NewProp_WheelSetups_Inner = new(EC_InternalUseOnlyConstructor, NewProp_WheelSetups, TEXT("WheelSetups"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FWheelSetup());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetCurrentGear()); // 66344927
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineMaxRotationSpeed()); // 3806912227
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetEngineRotationSpeed()); // 3468023400
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetForwardSpeed()); // 2233190606
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetTargetGear()); // 1014851631
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_GetUseAutoGears()); // 1071489126
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_ServerUpdateState()); // 854644457
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceEnabled()); // 722338471
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetAvoidanceGroup()); // 820515250
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearDown()); // 1267266848
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGearUp()); // 957436424
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToAvoid()); // 750246194
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetGroupsToIgnore()); // 805352691
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetHandbrakeInput()); // 1255856809
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetSteeringInput()); // 1092870119
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetTargetGear()); // 3293951308
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetThrottleInput()); // 2534944221
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UWheeledVehicleMovementComponent_SetUseAutoGears()); // 2926549384
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_URVOAvoidanceInterface_NoRegister(), VTABLE_OFFSET(UWheeledVehicleMovementComponent, IRVOAvoidanceInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("PlanarMovement Components|Movement|Planar Activation Components|Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Component to handle the vehicle simulation for an actor."));
				MetaData->SetValue(NewProp_bWasAvoidanceUpdated, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_bWasAvoidanceUpdated, TEXT("ToolTip"), TEXT("Was avoidance updated in this frame?"));
				MetaData->SetValue(NewProp_SteeringInputRate, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_SteeringInputRate, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_SteeringInputRate, TEXT("ToolTip"), TEXT("Rate at which input steering can rise and fall"));
				MetaData->SetValue(NewProp_HandbrakeInputRate, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_HandbrakeInputRate, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_HandbrakeInputRate, TEXT("ToolTip"), TEXT("Rate at which input handbrake can rise and fall"));
				MetaData->SetValue(NewProp_BrakeInputRate, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_BrakeInputRate, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakeInputRate, TEXT("ToolTip"), TEXT("Rate at which input brake can rise and fall"));
				MetaData->SetValue(NewProp_ThrottleInputRate, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_ThrottleInputRate, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_ThrottleInputRate, TEXT("ToolTip"), TEXT("Rate at which input throttle can rise and fall"));
				MetaData->SetValue(NewProp_WrongDirectionThreshold, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_WrongDirectionThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_WrongDirectionThreshold, TEXT("ToolTip"), TEXT("Auto-brake when vehicle forward speed is opposite of player input by at least this much (cm/s)"));
				MetaData->SetValue(NewProp_StopThreshold, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_StopThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_StopThreshold, TEXT("ToolTip"), TEXT("Auto-brake when absolute vehicle forward speed is less than this (cm/s)"));
				MetaData->SetValue(NewProp_IdleBrakeInput, TEXT("Category"), TEXT("VehicleInput"));
				MetaData->SetValue(NewProp_IdleBrakeInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_IdleBrakeInput, TEXT("ToolTip"), TEXT("How much to press the brake when the player has release throttle"));
				MetaData->SetValue(NewProp_HandbrakeInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_HandbrakeInput, TEXT("ToolTip"), TEXT("Handbrake output to physics system. Range 0...1"));
				MetaData->SetValue(NewProp_BrakeInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_BrakeInput, TEXT("ToolTip"), TEXT("Brake output to physics system. Range 0...1"));
				MetaData->SetValue(NewProp_ThrottleInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_ThrottleInput, TEXT("ToolTip"), TEXT("Accelerator output to physics system. Range 0...1"));
				MetaData->SetValue(NewProp_SteeringInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_SteeringInput, TEXT("ToolTip"), TEXT("Steering output to physics system. Range -1...1"));
				MetaData->SetValue(NewProp_bRawGearDownInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_bRawGearDownInput, TEXT("ToolTip"), TEXT("True if the player is holding gear down"));
				MetaData->SetValue(NewProp_bRawGearUpInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_bRawGearUpInput, TEXT("ToolTip"), TEXT("True if the player is holding gear up"));
				MetaData->SetValue(NewProp_bRawHandbrakeInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_bRawHandbrakeInput, TEXT("ToolTip"), TEXT("True if the player is holding the handbrake"));
				MetaData->SetValue(NewProp_RawThrottleInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_RawThrottleInput, TEXT("ToolTip"), TEXT("What the player has the accelerator set to. Range -1...1"));
				MetaData->SetValue(NewProp_RawSteeringInput, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_RawSteeringInput, TEXT("ToolTip"), TEXT("What the player has the steering set to. Range -1...1"));
				MetaData->SetValue(NewProp_ReplicatedState, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_ReplicatedState, TEXT("ToolTip"), TEXT("replicated state of vehicle"));
				MetaData->SetValue(NewProp_PendingLaunchVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_PendingLaunchVelocity, TEXT("ToolTip"), TEXT("Temporarily holds launch velocity when pawn is to be launched so it happens at end of movement."));
				MetaData->SetValue(NewProp_AvoidanceWeight, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceWeight, TEXT("ToolTip"), TEXT("De facto default value 0.5 (due to that being the default in the avoidance registration function), indicates RVO behavior."));
				MetaData->SetValue(NewProp_GroupsToIgnore, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_GroupsToIgnore, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_GroupsToIgnore, TEXT("ToolTip"), TEXT("Will NOT avoid other agents if they are in one of specified groups, higher priority than GroupsToAvoid"));
				MetaData->SetValue(NewProp_GroupsToAvoid, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_GroupsToAvoid, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_GroupsToAvoid, TEXT("ToolTip"), TEXT("Will avoid other agents if they are in one of specified groups"));
				MetaData->SetValue(NewProp_AvoidanceGroup, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceGroup, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceGroup, TEXT("ToolTip"), TEXT("Moving actor's group mask"));
				MetaData->SetValue(NewProp_AvoidanceUID, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceUID, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceUID, TEXT("ToolTip"), TEXT("No default value, for now it's assumed to be valid if GetAvoidanceManager() returns non-NULL."));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("ClampMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("ToolTip"), TEXT("Value by which to alter throttle per frame based on calculated avoidance"));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_RVOThrottleStep, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("ClampMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("ToolTip"), TEXT("Value by which to alter steering per frame based on calculated avoidance"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_RVOSteeringStep, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_AvoidanceConsiderationRadius, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_AvoidanceConsiderationRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_AvoidanceConsiderationRadius, TEXT("ToolTip"), TEXT("Area Radius to consider for RVO avoidance"));
				MetaData->SetValue(NewProp_RVOAvoidanceHeight, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_RVOAvoidanceHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_RVOAvoidanceHeight, TEXT("ToolTip"), TEXT("Vehicle Height to use for RVO avoidance (usually vehicle height)"));
				MetaData->SetValue(NewProp_RVOAvoidanceRadius, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_RVOAvoidanceRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_RVOAvoidanceRadius, TEXT("ToolTip"), TEXT("Vehicle Radius to use for RVO avoidance (usually half of vehicle width)"));
				MetaData->SetValue(NewProp_bUseRVOAvoidance, TEXT("Category"), TEXT("Avoidance"));
				MetaData->SetValue(NewProp_bUseRVOAvoidance, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_bUseRVOAvoidance, TEXT("ToolTip"), TEXT("If set, component will use RVO avoidance"));
				MetaData->SetValue(NewProp_Wheels, TEXT("Category"), TEXT("Vehicle"));
				MetaData->SetValue(NewProp_Wheels, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_Wheels, TEXT("ToolTip"), TEXT("Our instanced wheels"));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("ClampMax"), TEXT("10"));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("ClampMin"), TEXT("1"));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("ToolTip"), TEXT("The sub-step count above the threshold longitudinal speed has a default of 1."));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("UIMax"), TEXT("5"));
				MetaData->SetValue(NewProp_HighForwardSpeedSubStepCount, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("ClampMax"), TEXT("10"));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("ClampMin"), TEXT("1"));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("ToolTip"), TEXT("The sub-step count below the threshold longitudinal speed has a default of 3."));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("UIMax"), TEXT("5"));
				MetaData->SetValue(NewProp_LowForwardSpeedSubStepCount, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("ClampMax"), TEXT("1000.0"));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("ClampMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("ToolTip"), TEXT("PhysX sub-steps\n    More sub-steps provides better stability but with greater computational cost.\n    Typically, vehicles require more sub-steps at very low forward speeds.\n    The threshold longitudinal speed has a default value of 5 metres per second."));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("UIMax"), TEXT("10.0"));
				MetaData->SetValue(NewProp_ThresholdLongitudinalSpeed, TEXT("UIMin"), TEXT("1.0"));
				MetaData->SetValue(NewProp_MaxNormalizedTireLoadFiltered, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_MaxNormalizedTireLoadFiltered, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxNormalizedTireLoadFiltered, TEXT("ToolTip"), TEXT("Clamp normalized tire load to this value"));
				MetaData->SetValue(NewProp_MaxNormalizedTireLoad, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_MaxNormalizedTireLoad, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxNormalizedTireLoad, TEXT("ToolTip"), TEXT("Clamp normalized tire load to this value"));
				MetaData->SetValue(NewProp_MinNormalizedTireLoadFiltered, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_MinNormalizedTireLoadFiltered, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_MinNormalizedTireLoadFiltered, TEXT("ToolTip"), TEXT("Clamp normalized tire load to this value"));
				MetaData->SetValue(NewProp_MinNormalizedTireLoad, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_MinNormalizedTireLoad, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_MinNormalizedTireLoad, TEXT("ToolTip"), TEXT("Clamp normalized tire load to this value"));
				MetaData->SetValue(NewProp_InertiaTensorScale, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_InertiaTensorScale, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_InertiaTensorScale, TEXT("ToolTip"), TEXT("Scales the vehicle's inertia in each direction (forward, right, up)"));
				MetaData->SetValue(NewProp_DebugDragMagnitude, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_DebugDragMagnitude, TEXT("ToolTip"), TEXT("Debug drag magnitude last applied"));
				MetaData->SetValue(NewProp_MaxEngineRPM, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxEngineRPM, TEXT("ToolTip"), TEXT("Max RPM for engine"));
				MetaData->SetValue(NewProp_EstimatedMaxEngineSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_EstimatedMaxEngineSpeed, TEXT("ToolTip"), TEXT("Estimated mad speed for engine"));
				MetaData->SetValue(NewProp_DragArea, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_DragArea, TEXT("ToolTip"), TEXT("Drag area in cm^2"));
				MetaData->SetValue(NewProp_ChassisHeight, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_ChassisHeight, TEXT("ClampMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_ChassisHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_ChassisHeight, TEXT("ToolTip"), TEXT("Chassis height used for drag force computation (cm)"));
				MetaData->SetValue(NewProp_ChassisHeight, TEXT("UIMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_ChassisWidth, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_ChassisWidth, TEXT("ClampMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_ChassisWidth, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_ChassisWidth, TEXT("ToolTip"), TEXT("Chassis width used for drag force computation (cm)"));
				MetaData->SetValue(NewProp_ChassisWidth, TEXT("UIMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_DragCoefficient, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_DragCoefficient, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_DragCoefficient, TEXT("ToolTip"), TEXT("DragCoefficient of the vehicle chassis."));
				MetaData->SetValue(NewProp_Mass, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_Mass, TEXT("ClampMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_Mass, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_Mass, TEXT("ToolTip"), TEXT("Mass to set the vehicle chassis to. It's much easier to tweak vehicle settings when\nthe mass doesn't change due to tweaks with the physics asset. [kg]"));
				MetaData->SetValue(NewProp_Mass, TEXT("UIMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_WheelSetups, TEXT("Category"), TEXT("VehicleSetup"));
				MetaData->SetValue(NewProp_WheelSetups, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent.h"));
				MetaData->SetValue(NewProp_WheelSetups, TEXT("ToolTip"), TEXT("Wheels to create"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UWheeledVehicleMovementComponent(Z_Construct_UClass_UWheeledVehicleMovementComponent, TEXT("UWheeledVehicleMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UWheeledVehicleMovementComponent);
	UEnum* Z_Construct_UEnum_Engine_EVehicleDifferential4W()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EVehicleDifferential4W_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EVehicleDifferential4W"), 0, Get_Z_Construct_UEnum_Engine_EVehicleDifferential4W_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EVehicleDifferential4W"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::LimitedSlip_4W")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::LimitedSlip_FrontDrive")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::LimitedSlip_RearDrive")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::Open_4W")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::Open_FrontDrive")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::Open_RearDrive")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVehicleDifferential4W::EVehicleDifferential4W_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EVehicleDifferential4W_CRC() { return 550402955U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVehicleTransmissionData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FVehicleTransmissionData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("VehicleTransmissionData"), sizeof(FVehicleTransmissionData), Get_Z_Construct_UScriptStruct_FVehicleTransmissionData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VehicleTransmissionData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FVehicleTransmissionData>, EStructFlags(0x00000001));
			UProperty* NewProp_ClutchStrength = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ClutchStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ClutchStrength, FVehicleTransmissionData), 0x0000040000000001);
			UProperty* NewProp_NeutralGearUpRatio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NeutralGearUpRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NeutralGearUpRatio, FVehicleTransmissionData), 0x0000040000000001);
			UProperty* NewProp_ReverseGearRatio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ReverseGearRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReverseGearRatio, FVehicleTransmissionData), 0x0000040000000001);
			UProperty* NewProp_ForwardGears = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ForwardGears"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ForwardGears, FVehicleTransmissionData), 0x0000040000000001);
			UProperty* NewProp_ForwardGears_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ForwardGears, TEXT("ForwardGears"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVehicleGearData());
			UProperty* NewProp_FinalRatio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FinalRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FinalRatio, FVehicleTransmissionData), 0x0000040000000001);
			UProperty* NewProp_GearAutoBoxLatency = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GearAutoBoxLatency"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GearAutoBoxLatency, FVehicleTransmissionData), 0x0000000000000001);
			UProperty* NewProp_GearSwitchTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GearSwitchTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GearSwitchTime, FVehicleTransmissionData), 0x0000000000000001);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseGearAutoBox, FVehicleTransmissionData, bool);
			UProperty* NewProp_bUseGearAutoBox = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bUseGearAutoBox"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseGearAutoBox, FVehicleTransmissionData), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bUseGearAutoBox, FVehicleTransmissionData), sizeof(bool), true);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_ClutchStrength, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_ClutchStrength, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_ClutchStrength, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_ClutchStrength, TEXT("ToolTip"), TEXT("Strength of clutch (Kgm^2/s)"));
			MetaData->SetValue(NewProp_ClutchStrength, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("ToolTip"), TEXT("Value of engineRevs/maxEngineRevs that is high enough to increment gear"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_NeutralGearUpRatio, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_ReverseGearRatio, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_ReverseGearRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_ReverseGearRatio, TEXT("ToolTip"), TEXT("Reverse gear ratio"));
			MetaData->SetValue(NewProp_ForwardGears, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_ForwardGears, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_ForwardGears, TEXT("ToolTip"), TEXT("Forward gear ratios (up to 30)"));
			MetaData->SetValue(NewProp_FinalRatio, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_FinalRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_FinalRatio, TEXT("ToolTip"), TEXT("The final gear ratio multiplies the transmission gear ratios."));
			MetaData->SetValue(NewProp_GearAutoBoxLatency, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_GearAutoBoxLatency, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_GearAutoBoxLatency, TEXT("editcondition"), TEXT("bUseGearAutoBox"));
			MetaData->SetValue(NewProp_GearAutoBoxLatency, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_GearAutoBoxLatency, TEXT("ToolTip"), TEXT("Minimum time it takes the automatic transmission to initiate a gear change (seconds)"));
			MetaData->SetValue(NewProp_GearAutoBoxLatency, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_GearSwitchTime, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_GearSwitchTime, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_GearSwitchTime, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_GearSwitchTime, TEXT("ToolTip"), TEXT("Time it takes to switch gears (seconds)"));
			MetaData->SetValue(NewProp_GearSwitchTime, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_bUseGearAutoBox, TEXT("Category"), TEXT("VehicleSetup"));
			MetaData->SetValue(NewProp_bUseGearAutoBox, TEXT("DisplayName"), TEXT("Automatic Transmission"));
			MetaData->SetValue(NewProp_bUseGearAutoBox, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_bUseGearAutoBox, TEXT("ToolTip"), TEXT("Whether to use automatic transmission"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVehicleTransmissionData_CRC() { return 3956810639U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVehicleGearData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FVehicleGearData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("VehicleGearData"), sizeof(FVehicleGearData), Get_Z_Construct_UScriptStruct_FVehicleGearData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VehicleGearData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FVehicleGearData>, EStructFlags(0x00000001));
			UProperty* NewProp_UpRatio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("UpRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(UpRatio, FVehicleGearData), 0x0000000000000001);
			UProperty* NewProp_DownRatio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DownRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DownRatio, FVehicleGearData), 0x0000000000000001);
			UProperty* NewProp_Ratio = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Ratio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Ratio, FVehicleGearData), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("ToolTip"), TEXT("Value of engineRevs/maxEngineRevs that is high enough to gear up"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_UpRatio, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("ToolTip"), TEXT("Value of engineRevs/maxEngineRevs that is low enough to gear down"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_DownRatio, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_Ratio, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_Ratio, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_Ratio, TEXT("ToolTip"), TEXT("Determines the amount of torque multiplication"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVehicleGearData_CRC() { return 3471293309U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVehicleEngineData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FVehicleEngineData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("VehicleEngineData"), sizeof(FVehicleEngineData), Get_Z_Construct_UScriptStruct_FVehicleEngineData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VehicleEngineData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FVehicleEngineData>, EStructFlags(0x00000001));
			UProperty* NewProp_DampingRateZeroThrottleClutchDisengaged = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DampingRateZeroThrottleClutchDisengaged"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DampingRateZeroThrottleClutchDisengaged, FVehicleEngineData), 0x0000040000000001);
			UProperty* NewProp_DampingRateZeroThrottleClutchEngaged = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DampingRateZeroThrottleClutchEngaged"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DampingRateZeroThrottleClutchEngaged, FVehicleEngineData), 0x0000040000000001);
			UProperty* NewProp_DampingRateFullThrottle = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DampingRateFullThrottle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DampingRateFullThrottle, FVehicleEngineData), 0x0000040000000001);
			UProperty* NewProp_MOI = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MOI"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MOI, FVehicleEngineData), 0x0000000000000001);
			UProperty* NewProp_MaxRPM = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxRPM"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxRPM, FVehicleEngineData), 0x0000000000000001);
			UProperty* NewProp_TorqueCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TorqueCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TorqueCurve, FVehicleEngineData), 0x0000000000000001, Z_Construct_UScriptStruct_FRuntimeFloatCurve());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchDisengaged, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchDisengaged, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchDisengaged, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchDisengaged, TEXT("ToolTip"), TEXT("Damping rate of engine in at zero throttle when the clutch is disengaged (in neutral gear) (Kgm^2/s)"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchDisengaged, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchEngaged, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchEngaged, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchEngaged, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchEngaged, TEXT("ToolTip"), TEXT("Damping rate of engine in at zero throttle when the clutch is engaged (Kgm^2/s)"));
			MetaData->SetValue(NewProp_DampingRateZeroThrottleClutchEngaged, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DampingRateFullThrottle, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_DampingRateFullThrottle, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DampingRateFullThrottle, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_DampingRateFullThrottle, TEXT("ToolTip"), TEXT("Damping rate of engine when full throttle is applied (Kgm^2/s)"));
			MetaData->SetValue(NewProp_DampingRateFullThrottle, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_MOI, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_MOI, TEXT("ClampMin"), TEXT("0.01"));
			MetaData->SetValue(NewProp_MOI, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_MOI, TEXT("ToolTip"), TEXT("Moment of inertia of the engine around the axis of rotation (Kgm^2)."));
			MetaData->SetValue(NewProp_MOI, TEXT("UIMin"), TEXT("0.01"));
			MetaData->SetValue(NewProp_MaxRPM, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_MaxRPM, TEXT("ClampMin"), TEXT("0.01"));
			MetaData->SetValue(NewProp_MaxRPM, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_MaxRPM, TEXT("ToolTip"), TEXT("Maximum revolutions per minute of the engine"));
			MetaData->SetValue(NewProp_MaxRPM, TEXT("UIMin"), TEXT("0.01"));
			MetaData->SetValue(NewProp_TorqueCurve, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_TorqueCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_TorqueCurve, TEXT("ToolTip"), TEXT("Torque (Nm) at a given RPM"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVehicleEngineData_CRC() { return 1684760284U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVehicleDifferential4WData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FVehicleDifferential4WData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("VehicleDifferential4WData"), sizeof(FVehicleDifferential4WData), Get_Z_Construct_UScriptStruct_FVehicleDifferential4WData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VehicleDifferential4WData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FVehicleDifferential4WData>, EStructFlags(0x00000001));
			UProperty* NewProp_RearBias = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RearBias"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RearBias, FVehicleDifferential4WData), 0x0000000000000001);
			UProperty* NewProp_FrontBias = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FrontBias"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrontBias, FVehicleDifferential4WData), 0x0000000000000001);
			UProperty* NewProp_CentreBias = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CentreBias"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CentreBias, FVehicleDifferential4WData), 0x0000000000000001);
			UProperty* NewProp_RearLeftRightSplit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RearLeftRightSplit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RearLeftRightSplit, FVehicleDifferential4WData), 0x0000000000000001);
			UProperty* NewProp_FrontLeftRightSplit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FrontLeftRightSplit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrontLeftRightSplit, FVehicleDifferential4WData), 0x0000000000000001);
			UProperty* NewProp_FrontRearSplit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FrontRearSplit"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrontRearSplit, FVehicleDifferential4WData), 0x0000000000000001);
			UProperty* NewProp_DifferentialType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DifferentialType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DifferentialType, FVehicleDifferential4WData), 0x0000000000000001, Z_Construct_UEnum_Engine_EVehicleDifferential4W());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_RearBias, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_RearBias, TEXT("ClampMin"), TEXT("1.0"));
			MetaData->SetValue(NewProp_RearBias, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_RearBias, TEXT("ToolTip"), TEXT("Maximum allowed ratio of rear-left and rear-right wheel rotation speeds (range: 1..inf, works only with LimitedSlip_4W, LimitedSlip_FrontDrive)"));
			MetaData->SetValue(NewProp_RearBias, TEXT("UIMin"), TEXT("1.0"));
			MetaData->SetValue(NewProp_FrontBias, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_FrontBias, TEXT("ClampMin"), TEXT("1.0"));
			MetaData->SetValue(NewProp_FrontBias, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_FrontBias, TEXT("ToolTip"), TEXT("Maximum allowed ratio of front-left and front-right wheel rotation speeds (range: 1..inf, works only with LimitedSlip_4W, LimitedSlip_FrontDrive)"));
			MetaData->SetValue(NewProp_FrontBias, TEXT("UIMin"), TEXT("1.0"));
			MetaData->SetValue(NewProp_CentreBias, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_CentreBias, TEXT("ClampMin"), TEXT("1.0"));
			MetaData->SetValue(NewProp_CentreBias, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_CentreBias, TEXT("ToolTip"), TEXT("Maximum allowed ratio of average front wheel rotation speed and rear wheel rotation speeds (range: 1..inf, works only with LimitedSlip_4W)"));
			MetaData->SetValue(NewProp_CentreBias, TEXT("UIMin"), TEXT("1.0"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("ToolTip"), TEXT("Ratio of torque split between rear-left and rear-right (>0.5 means more to rear-left, <0.5 means more to rear-right, works only with 4W and LimitedSlip_RearDrive)"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_RearLeftRightSplit, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("ToolTip"), TEXT("Ratio of torque split between front-left and front-right (>0.5 means more to front-left, <0.5 means more to front-right, works only with 4W and LimitedSlip_FrontDrive)"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_FrontLeftRightSplit, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("ClampMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("ClampMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("ToolTip"), TEXT("Ratio of torque split between front and rear (>0.5 means more to front, <0.5 means more to rear, works only with 4W type)"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("UIMax"), TEXT("1.0"));
			MetaData->SetValue(NewProp_FrontRearSplit, TEXT("UIMin"), TEXT("0.0"));
			MetaData->SetValue(NewProp_DifferentialType, TEXT("Category"), TEXT("Setup"));
			MetaData->SetValue(NewProp_DifferentialType, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
			MetaData->SetValue(NewProp_DifferentialType, TEXT("ToolTip"), TEXT("Type of differential"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVehicleDifferential4WData_CRC() { return 1522955655U; }
	UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent4W_NoRegister()
	{
		return UWheeledVehicleMovementComponent4W::StaticClass();
	}
	UClass* Z_Construct_UClass_UWheeledVehicleMovementComponent4W()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UWheeledVehicleMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UWheeledVehicleMovementComponent4W::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_AckermannAccuracy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AckermannAccuracy"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AckermannAccuracy, UWheeledVehicleMovementComponent4W), 0x0000040000000001);
				UProperty* NewProp_SteeringCurve = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SteeringCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SteeringCurve, UWheeledVehicleMovementComponent4W), 0x0000000000000001, Z_Construct_UScriptStruct_FRuntimeFloatCurve());
				UProperty* NewProp_TransmissionSetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TransmissionSetup"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TransmissionSetup, UWheeledVehicleMovementComponent4W), 0x0000000000000001, Z_Construct_UScriptStruct_FVehicleTransmissionData());
				UProperty* NewProp_DifferentialSetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DifferentialSetup"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(DifferentialSetup, UWheeledVehicleMovementComponent4W), 0x0000000000000001, Z_Construct_UScriptStruct_FVehicleDifferential4WData());
				UProperty* NewProp_EngineSetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EngineSetup"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EngineSetup, UWheeledVehicleMovementComponent4W), 0x0000000000000001, Z_Construct_UScriptStruct_FVehicleEngineData());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("PlanarMovement Components|Movement|Planar Activation Components|Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("Category"), TEXT("SteeringSetup"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("ClampMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("ToolTip"), TEXT("Accuracy of Ackermann steer calculation (range: 0..1)"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_AckermannAccuracy, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_SteeringCurve, TEXT("Category"), TEXT("SteeringSetup"));
				MetaData->SetValue(NewProp_SteeringCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(NewProp_SteeringCurve, TEXT("ToolTip"), TEXT("Maximum steering versus forward speed (km/h)"));
				MetaData->SetValue(NewProp_TransmissionSetup, TEXT("Category"), TEXT("MechanicalSetup"));
				MetaData->SetValue(NewProp_TransmissionSetup, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(NewProp_TransmissionSetup, TEXT("ToolTip"), TEXT("Transmission data"));
				MetaData->SetValue(NewProp_DifferentialSetup, TEXT("Category"), TEXT("MechanicalSetup"));
				MetaData->SetValue(NewProp_DifferentialSetup, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(NewProp_DifferentialSetup, TEXT("ToolTip"), TEXT("Differential"));
				MetaData->SetValue(NewProp_EngineSetup, TEXT("Category"), TEXT("MechanicalSetup"));
				MetaData->SetValue(NewProp_EngineSetup, TEXT("ModuleRelativePath"), TEXT("Classes/Vehicles/WheeledVehicleMovementComponent4W.h"));
				MetaData->SetValue(NewProp_EngineSetup, TEXT("ToolTip"), TEXT("Engine"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UWheeledVehicleMovementComponent4W(Z_Construct_UClass_UWheeledVehicleMovementComponent4W, TEXT("UWheeledVehicleMovementComponent4W"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UWheeledVehicleMovementComponent4W);
	UFunction* Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature()
	{
		struct ProjectileMovementComponent_eventOnProjectileStopDelegate_Parms
		{
			FHitResult ImpactResult;
		};
		UObject* Outer=Z_Construct_UClass_UProjectileMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnProjectileStopDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00530000, 65535, sizeof(ProjectileMovementComponent_eventOnProjectileStopDelegate_Parms));
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, ProjectileMovementComponent_eventOnProjectileStopDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature()
	{
		struct ProjectileMovementComponent_eventOnProjectileBounceDelegate_Parms
		{
			FHitResult ImpactResult;
			FVector ImpactVelocity;
		};
		UObject* Outer=Z_Construct_UClass_UProjectileMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnProjectileBounceDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00D30000, 65535, sizeof(ProjectileMovementComponent_eventOnProjectileBounceDelegate_Parms));
			UProperty* NewProp_ImpactVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactVelocity, ProjectileMovementComponent_eventOnProjectileBounceDelegate_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ImpactResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpactResult, ProjectileMovementComponent_eventOnProjectileBounceDelegate_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UProjectileMovementComponent_LimitVelocity()
	{
		struct ProjectileMovementComponent_eventLimitVelocity_Parms
		{
			FVector NewVelocity;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UProjectileMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LimitVelocity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54880401, 65535, sizeof(ProjectileMovementComponent_eventLimitVelocity_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, ProjectileMovementComponent_eventLimitVelocity_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_NewVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewVelocity, ProjectileMovementComponent_eventLimitVelocity_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|ProjectileMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Don't allow velocity magnitude to exceed MaxSpeed, if MaxSpeed is non-zero."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UProjectileMovementComponent_SetVelocityInLocalSpace()
	{
		struct ProjectileMovementComponent_eventSetVelocityInLocalSpace_Parms
		{
			FVector NewVelocity;
		};
		UObject* Outer=Z_Construct_UClass_UProjectileMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetVelocityInLocalSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ProjectileMovementComponent_eventSetVelocityInLocalSpace_Parms));
			UProperty* NewProp_NewVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewVelocity, ProjectileMovementComponent_eventSetVelocityInLocalSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|ProjectileMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the velocity to the new value, rotated into Actor space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UProjectileMovementComponent_StopSimulating()
	{
		struct ProjectileMovementComponent_eventStopSimulating_Parms
		{
			FHitResult HitResult;
		};
		UObject* Outer=Z_Construct_UClass_UProjectileMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopSimulating"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420400, 65535, sizeof(ProjectileMovementComponent_eventStopSimulating_Parms));
			UProperty* NewProp_HitResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitResult"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitResult, ProjectileMovementComponent_eventStopSimulating_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Game|Components|ProjectileMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clears the reference to UpdatedComponent, fires stop event (OnProjectileStop), and stops ticking (if bAutoUpdateTickRegistration is true)."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UProjectileMovementComponent_NoRegister()
	{
		return UProjectileMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UProjectileMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UProjectileMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UProjectileMovementComponent_LimitVelocity());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UFunction_UProjectileMovementComponent_SetVelocityInLocalSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_UProjectileMovementComponent_StopSimulating());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MaxSimulationIterations = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSimulationIterations"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxSimulationIterations, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_MaxSimulationTimeStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSimulationTimeStep"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSimulationTimeStep, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_HomingTargetComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HomingTargetComponent"), RF_Public|RF_Transient|RF_Native) UWeakObjectProperty(CPP_PROPERTY_BASE(HomingTargetComponent, UProjectileMovementComponent), 0x00040000000a080d, Z_Construct_UClass_USceneComponent_NoRegister());
				UProperty* NewProp_HomingAccelerationMagnitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HomingAccelerationMagnitude"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HomingAccelerationMagnitude, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_OnProjectileStop = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnProjectileStop"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnProjectileStop, UProjectileMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature());
				UProperty* NewProp_OnProjectileBounce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnProjectileBounce"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnProjectileBounce, UProjectileMovementComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature());
				UProperty* NewProp_BounceVelocityStopSimulatingThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BounceVelocityStopSimulatingThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BounceVelocityStopSimulatingThreshold, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_Friction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Friction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Friction, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_Bounciness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Bounciness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Bounciness, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_Buoyancy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Buoyancy"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Buoyancy, UProjectileMovementComponent), 0x0000000000000000);
				UProperty* NewProp_ProjectileGravityScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProjectileGravityScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ProjectileGravityScale, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_PreviousHitNormal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviousHitNormal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviousHitNormal, UProjectileMovementComponent), 0x0000000000020815, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PreviousHitTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviousHitTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PreviousHitTime, UProjectileMovementComponent), 0x0000000000020815);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsSliding, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bIsSliding = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsSliding"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsSliding, UProjectileMovementComponent), 0x0000000000020815, CPP_BOOL_PROPERTY_BITMASK(bIsSliding, UProjectileMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bBounceAngleAffectsFriction, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bBounceAngleAffectsFriction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bBounceAngleAffectsFriction"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bBounceAngleAffectsFriction, UProjectileMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bBounceAngleAffectsFriction, UProjectileMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsHomingProjectile, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bIsHomingProjectile = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsHomingProjectile"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsHomingProjectile, UProjectileMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsHomingProjectile, UProjectileMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForceSubStepping, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bForceSubStepping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bForceSubStepping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForceSubStepping, UProjectileMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bForceSubStepping, UProjectileMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInitialVelocityInLocalSpace, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bInitialVelocityInLocalSpace = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInitialVelocityInLocalSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInitialVelocityInLocalSpace, UProjectileMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bInitialVelocityInLocalSpace, UProjectileMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldBounce, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bShouldBounce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldBounce"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldBounce, UProjectileMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShouldBounce, UProjectileMovementComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRotationFollowsVelocity, UProjectileMovementComponent, uint8);
				UProperty* NewProp_bRotationFollowsVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRotationFollowsVelocity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRotationFollowsVelocity, UProjectileMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bRotationFollowsVelocity, UProjectileMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_MaxSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxSpeed, UProjectileMovementComponent), 0x0000000000000005);
				UProperty* NewProp_InitialSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InitialSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InitialSpeed, UProjectileMovementComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UProjectileMovementComponent_LimitVelocity()); // 137893849
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature()); // 3142526594
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature()); // 1810011044
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UProjectileMovementComponent_SetVelocityInLocalSpace()); // 2772278103
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UProjectileMovementComponent_StopSimulating()); // 1259334743
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("ProjectileMovementComponent updates the position of another component during its tick.\n\nBehavior such as bouncing after impacts and homing toward a target are supported.\n\nNormally the root component of the owning actor is moved, however another component may be selected (see SetUpdatedComponent()).\nIf the updated component is simulating physics, only the initial launch parameters (when initial velocity is non-zero)\nwill affect the projectile, and the physics sim will take over from there.\n\n@see UMovementComponent"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("Category"), TEXT("ProjectileSimulation"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ClampMax"), TEXT("25"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ClampMin"), TEXT("1"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("ToolTip"), TEXT("Max number of iterations used for each discrete simulation step.\nIncreasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationTimeStep, bForceSubStepping"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("UIMax"), TEXT("25"));
				MetaData->SetValue(NewProp_MaxSimulationIterations, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("Category"), TEXT("ProjectileSimulation"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ClampMax"), TEXT("0.50"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ClampMin"), TEXT("0.0166"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("ToolTip"), TEXT("Max time delta for each discrete simulation step.\nLowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationIterations, bForceSubStepping"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("UIMax"), TEXT("0.50"));
				MetaData->SetValue(NewProp_MaxSimulationTimeStep, TEXT("UIMin"), TEXT("0.0166"));
				MetaData->SetValue(NewProp_HomingTargetComponent, TEXT("Category"), TEXT("Homing"));
				MetaData->SetValue(NewProp_HomingTargetComponent, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_HomingTargetComponent, TEXT("ToolTip"), TEXT("The current target we are homing towards. Can only be set at runtime (when projectile is spawned or updating).\n@see bIsHomingProjectile"));
				MetaData->SetValue(NewProp_HomingAccelerationMagnitude, TEXT("Category"), TEXT("Homing"));
				MetaData->SetValue(NewProp_HomingAccelerationMagnitude, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_HomingAccelerationMagnitude, TEXT("ToolTip"), TEXT("The magnitude of our acceleration towards the homing target. Overall velocity magnitude will still be limited by MaxSpeed."));
				MetaData->SetValue(NewProp_OnProjectileStop, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_OnProjectileStop, TEXT("ToolTip"), TEXT("Called when projectile has come to a stop (velocity is below simulation threshold, bounces are disabled, or it is forcibly stopped)."));
				MetaData->SetValue(NewProp_OnProjectileBounce, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_OnProjectileBounce, TEXT("ToolTip"), TEXT("Called when projectile impacts something and bounces are enabled."));
				MetaData->SetValue(NewProp_BounceVelocityStopSimulatingThreshold, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_BounceVelocityStopSimulatingThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_BounceVelocityStopSimulatingThreshold, TEXT("ToolTip"), TEXT("If velocity is below this threshold after a bounce, stops simulating and triggers the OnProjectileStop event.\nIgnored if bShouldBounce is false, in which case the projectile stops simulating on the first impact.\n@see StopSimulating(), OnProjectileStop"));
				MetaData->SetValue(NewProp_Friction, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_Friction, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Friction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_Friction, TEXT("ToolTip"), TEXT("Coefficient of friction, affecting the resistance to sliding along a surface.\nNormal range is [0,1] : 0.0 = no friction, 1.0+ = very high friction.\nAlso affects the percentage of velocity maintained after the bounce in the direction tangent to the normal of impact.\nIgnored if bShouldBounce is false.\n@see bBounceAngleAffectsFriction"));
				MetaData->SetValue(NewProp_Friction, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Bounciness, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_Bounciness, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Bounciness, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_Bounciness, TEXT("ToolTip"), TEXT("Percentage of velocity maintained after the bounce in the direction of the normal of impact (coefficient of restitution).\n1.0 = no velocity lost, 0.0 = no bounce. Ignored if bShouldBounce is false."));
				MetaData->SetValue(NewProp_Bounciness, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Buoyancy, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_Buoyancy, TEXT("ToolTip"), TEXT("Buoyancy of UpdatedComponent in fluid. 0.0=sinks as fast as in air, 1.0=neutral buoyancy"));
				MetaData->SetValue(NewProp_ProjectileGravityScale, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_ProjectileGravityScale, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_ProjectileGravityScale, TEXT("ToolTip"), TEXT("Custom gravity scale for this projectile. Set to 0 for no gravity."));
				MetaData->SetValue(NewProp_PreviousHitNormal, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_PreviousHitNormal, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_PreviousHitNormal, TEXT("ToolTip"), TEXT("Saved HitResult Normal from previous simulation step that resulted in an impact. If PreviousHitTime is 1.0, then the hit was not in the last step."));
				MetaData->SetValue(NewProp_PreviousHitTime, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_PreviousHitTime, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_PreviousHitTime, TEXT("ToolTip"), TEXT("Saved HitResult Time (0 to 1) from previous simulation step. Equal to 1.0 when there was no impact."));
				MetaData->SetValue(NewProp_bIsSliding, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_bIsSliding, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bIsSliding, TEXT("ToolTip"), TEXT("If true, projectile is sliding / rolling along a surface."));
				MetaData->SetValue(NewProp_bBounceAngleAffectsFriction, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_bBounceAngleAffectsFriction, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bBounceAngleAffectsFriction, TEXT("ToolTip"), TEXT("Controls the effects of friction on velocity parallel to the impact surface when bouncing.\nIf true, friction will be modified based on the angle of impact, making friction higher for perpendicular impacts and lower for glancing impacts.\nIf false, a bounce will retain a proportion of tangential velocity equal to (1.0 - Friction), acting as a \"horizontal restitution\"."));
				MetaData->SetValue(NewProp_bIsHomingProjectile, TEXT("Category"), TEXT("Homing"));
				MetaData->SetValue(NewProp_bIsHomingProjectile, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bIsHomingProjectile, TEXT("ToolTip"), TEXT("If true, we will accelerate toward our homing target. HomingTargetComponent must be set after the projectile is spawned.\n@see HomingTargetComponent, HomingAccelerationMagnitude"));
				MetaData->SetValue(NewProp_bForceSubStepping, TEXT("Category"), TEXT("ProjectileSimulation"));
				MetaData->SetValue(NewProp_bForceSubStepping, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bForceSubStepping, TEXT("ToolTip"), TEXT("If true, forces sub-stepping to break up movement into discrete smaller steps to improve accuracy of the trajectory.\nObjects that move in a straight line typically do *not* need to set this, as movement always uses continuous collision detection (sweeps) so collision is not missed.\nSub-stepping is automatically enabled when under the effects of gravity or when homing towards a target.\n@see MaxSimulationTimeStep, MaxSimulationIterations"));
				MetaData->SetValue(NewProp_bInitialVelocityInLocalSpace, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_bInitialVelocityInLocalSpace, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bInitialVelocityInLocalSpace, TEXT("ToolTip"), TEXT("If true, the initial Velocity is interpreted as being in local space upon startup.\n@see SetVelocityInLocalSpace()"));
				MetaData->SetValue(NewProp_bShouldBounce, TEXT("Category"), TEXT("ProjectileBounces"));
				MetaData->SetValue(NewProp_bShouldBounce, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bShouldBounce, TEXT("ToolTip"), TEXT("If true, simple bounces will be simulated. Set this to false to stop simulating on contact."));
				MetaData->SetValue(NewProp_bRotationFollowsVelocity, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_bRotationFollowsVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_bRotationFollowsVelocity, TEXT("ToolTip"), TEXT("If true, this projectile will have its rotation updated each frame to match the direction of its velocity."));
				MetaData->SetValue(NewProp_MaxSpeed, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_MaxSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxSpeed, TEXT("ToolTip"), TEXT("Limit on speed of projectile (0 means no limit)."));
				MetaData->SetValue(NewProp_InitialSpeed, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_InitialSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/ProjectileMovementComponent.h"));
				MetaData->SetValue(NewProp_InitialSpeed, TEXT("ToolTip"), TEXT("Initial speed of projectile. If greater than zero, this will override the initial Velocity value and instead treat Velocity as a direction."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UProjectileMovementComponent(Z_Construct_UClass_UProjectileMovementComponent, TEXT("UProjectileMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UProjectileMovementComponent);
	UClass* Z_Construct_UClass_URotatingMovementComponent_NoRegister()
	{
		return URotatingMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_URotatingMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMovementComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = URotatingMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRotationInLocalSpace, URotatingMovementComponent, uint8);
				UProperty* NewProp_bRotationInLocalSpace = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRotationInLocalSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRotationInLocalSpace, URotatingMovementComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bRotationInLocalSpace, URotatingMovementComponent), sizeof(uint8), false);
				UProperty* NewProp_PivotTranslation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PivotTranslation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PivotTranslation, URotatingMovementComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_RotationRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RotationRate"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RotationRate, URotatingMovementComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FRotator());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Velocity ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/RotatingMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/RotatingMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Performs continuous rotation of a component at a specific rotation rate.\nRotation can optionally be offset around a pivot point.\nCollision testing is not performed during movement."));
				MetaData->SetValue(NewProp_bRotationInLocalSpace, TEXT("Category"), TEXT("RotatingComponent"));
				MetaData->SetValue(NewProp_bRotationInLocalSpace, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/RotatingMovementComponent.h"));
				MetaData->SetValue(NewProp_bRotationInLocalSpace, TEXT("ToolTip"), TEXT("Whether rotation is applied in local or world space."));
				MetaData->SetValue(NewProp_PivotTranslation, TEXT("Category"), TEXT("RotatingComponent"));
				MetaData->SetValue(NewProp_PivotTranslation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/RotatingMovementComponent.h"));
				MetaData->SetValue(NewProp_PivotTranslation, TEXT("ToolTip"), TEXT("Translation of pivot point around which we rotate, relative to current rotation.\nFor instance, with PivotTranslation set to (X=+100, Y=0, Z=0), rotation will occur\naround the point +100 units along the local X axis from the center of the object,\nrather than around the object's origin (the default)."));
				MetaData->SetValue(NewProp_RotationRate, TEXT("Category"), TEXT("RotatingComponent"));
				MetaData->SetValue(NewProp_RotationRate, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/RotatingMovementComponent.h"));
				MetaData->SetValue(NewProp_RotationRate, TEXT("ToolTip"), TEXT("How fast to update roll/pitch/yaw of the component we update."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_URotatingMovementComponent(Z_Construct_UClass_URotatingMovementComponent, TEXT("URotatingMovementComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(URotatingMovementComponent);
	UClass* Z_Construct_UClass_UNavigationInvokerComponent_NoRegister()
	{
		return UNavigationInvokerComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavigationInvokerComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavigationInvokerComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TileRemovalRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TileRemovalRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TileRemovalRadius, UNavigationInvokerComponent), 0x0000080000000001);
				UProperty* NewProp_TileGenerationRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TileGenerationRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TileGenerationRadius, UNavigationInvokerComponent), 0x0000080000000001);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavigationInvokerComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationInvokerComponent.h"));
				MetaData->SetValue(NewProp_TileRemovalRadius, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_TileRemovalRadius, TEXT("ClampMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_TileRemovalRadius, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationInvokerComponent.h"));
				MetaData->SetValue(NewProp_TileRemovalRadius, TEXT("UIMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_TileGenerationRadius, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_TileGenerationRadius, TEXT("ClampMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_TileGenerationRadius, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationInvokerComponent.h"));
				MetaData->SetValue(NewProp_TileGenerationRadius, TEXT("UIMin"), TEXT("0.1"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavigationInvokerComponent(Z_Construct_UClass_UNavigationInvokerComponent, TEXT("UNavigationInvokerComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavigationInvokerComponent);
	UFunction* Z_Construct_UFunction_UNavRelevantComponent_SetNavigationRelevancy()
	{
		struct NavRelevantComponent_eventSetNavigationRelevancy_Parms
		{
			bool bRelevant;
		};
		UObject* Outer=Z_Construct_UClass_UNavRelevantComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNavigationRelevancy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(NavRelevantComponent_eventSetNavigationRelevancy_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRelevant, NavRelevantComponent_eventSetNavigationRelevancy_Parms, bool);
			UProperty* NewProp_bRelevant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bRelevant"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRelevant, NavRelevantComponent_eventSetNavigationRelevancy_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bRelevant, NavRelevantComponent_eventSetNavigationRelevancy_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AI|Navigation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavRelevantComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UNavRelevantComponent_NoRegister()
	{
		return UNavRelevantComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavRelevantComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavRelevantComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UNavRelevantComponent_SetNavigationRelevancy());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CachedNavParent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedNavParent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CachedNavParent, UNavRelevantComponent), 0x0000080000002000, Z_Construct_UClass_UObject_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAttachToOwnersRoot, UNavRelevantComponent, uint8);
				UProperty* NewProp_bAttachToOwnersRoot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAttachToOwnersRoot"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAttachToOwnersRoot, UNavRelevantComponent), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bAttachToOwnersRoot, UNavRelevantComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNavigationRelevant, UNavRelevantComponent, uint8);
				UProperty* NewProp_bNavigationRelevant = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNavigationRelevant"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNavigationRelevant, UNavRelevantComponent), 0x0000080000000000, CPP_BOOL_PROPERTY_BITMASK(bNavigationRelevant, UNavRelevantComponent), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UNavRelevantComponent_SetNavigationRelevancy()); // 1644495415
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UNavRelevantInterface_NoRegister(), VTABLE_OFFSET(UNavRelevantComponent, INavRelevantInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavRelevantComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavRelevantComponent.h"));
				MetaData->SetValue(NewProp_CachedNavParent, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavRelevantComponent.h"));
				MetaData->SetValue(NewProp_bAttachToOwnersRoot, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavRelevantComponent.h"));
				MetaData->SetValue(NewProp_bAttachToOwnersRoot, TEXT("ToolTip"), TEXT("attach navigation data to entry for owner's root component (depends on its relevancy)"));
				MetaData->SetValue(NewProp_bNavigationRelevant, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavRelevantComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavRelevantComponent(Z_Construct_UClass_UNavRelevantComponent, TEXT("UNavRelevantComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavRelevantComponent);
	UClass* Z_Construct_UClass_UNavLinkCustomInterface_NoRegister()
	{
		return UNavLinkCustomInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavLinkCustomInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavLinkCustomInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20084081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("CannotImplementInterfaceInBlueprint"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavLinkCustomInterface(Z_Construct_UClass_UNavLinkCustomInterface, TEXT("UNavLinkCustomInterface"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavLinkCustomInterface);
	UClass* Z_Construct_UClass_UNavLinkCustomComponent_NoRegister()
	{
		return UNavLinkCustomComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavLinkCustomComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UNavRelevantComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavLinkCustomComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BroadcastChannel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BroadcastChannel"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BroadcastChannel, UNavLinkCustomComponent), 0x0000080000000001, Z_Construct_UEnum_Engine_ECollisionChannel());
				UProperty* NewProp_BroadcastInterval = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BroadcastInterval"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BroadcastInterval, UNavLinkCustomComponent), 0x0000080000000001);
				UProperty* NewProp_BroadcastRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BroadcastRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BroadcastRadius, UNavLinkCustomComponent), 0x0000080000000001);
				UProperty* NewProp_ObstacleAreaClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ObstacleAreaClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(ObstacleAreaClass, UNavLinkCustomComponent), 0x0004080000000001, Z_Construct_UClass_UNavArea_NoRegister());
				UProperty* NewProp_ObstacleExtent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ObstacleExtent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ObstacleExtent, UNavLinkCustomComponent), 0x0000080000000001, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_ObstacleOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ObstacleOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ObstacleOffset, UNavLinkCustomComponent), 0x0000080000000001, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateBoxObstacle, UNavLinkCustomComponent, uint8);
				UProperty* NewProp_bCreateBoxObstacle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateBoxObstacle"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateBoxObstacle, UNavLinkCustomComponent), 0x0000080000000001, CPP_BOOL_PROPERTY_BITMASK(bCreateBoxObstacle, UNavLinkCustomComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNotifyWhenDisabled, UNavLinkCustomComponent, uint8);
				UProperty* NewProp_bNotifyWhenDisabled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNotifyWhenDisabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNotifyWhenDisabled, UNavLinkCustomComponent), 0x0000080000000001, CPP_BOOL_PROPERTY_BITMASK(bNotifyWhenDisabled, UNavLinkCustomComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNotifyWhenEnabled, UNavLinkCustomComponent, uint8);
				UProperty* NewProp_bNotifyWhenEnabled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNotifyWhenEnabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNotifyWhenEnabled, UNavLinkCustomComponent), 0x0000080000000001, CPP_BOOL_PROPERTY_BITMASK(bNotifyWhenEnabled, UNavLinkCustomComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLinkEnabled, UNavLinkCustomComponent, uint8);
				UProperty* NewProp_bLinkEnabled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLinkEnabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLinkEnabled, UNavLinkCustomComponent), 0x0000080000000001, CPP_BOOL_PROPERTY_BITMASK(bLinkEnabled, UNavLinkCustomComponent), sizeof(uint8), false);
				UProperty* NewProp_LinkDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LinkDirection"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LinkDirection, UNavLinkCustomComponent), 0x0000080000000001, Z_Construct_UEnum_Engine_ENavLinkDirection());
				UProperty* NewProp_LinkRelativeEnd = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LinkRelativeEnd"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LinkRelativeEnd, UNavLinkCustomComponent), 0x0000080000000001, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_LinkRelativeStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LinkRelativeStart"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LinkRelativeStart, UNavLinkCustomComponent), 0x0000080000000001, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_DisabledAreaClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DisabledAreaClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(DisabledAreaClass, UNavLinkCustomComponent), 0x0004080000000001, Z_Construct_UClass_UNavArea_NoRegister());
				UProperty* NewProp_EnabledAreaClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnabledAreaClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(EnabledAreaClass, UNavLinkCustomComponent), 0x0004080000000001, Z_Construct_UClass_UNavArea_NoRegister());
				UProperty* NewProp_NavLinkUserId = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NavLinkUserId"), RF_Public|RF_Transient|RF_Native) UUInt32Property(CPP_PROPERTY_BASE(NavLinkUserId, UNavLinkCustomComponent), 0x0000080000000000);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UNavLinkCustomInterface_NoRegister(), VTABLE_OFFSET(UNavLinkCustomComponent, INavLinkCustomInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Encapsulates NavLinkCustomInterface interface, can be used with Actors not relevant for navigation\n\nAdditional functionality:\n- can be toggled\n- can create obstacle area for easier/forced separation of link end points\n- can broadcast state changes to nearby agents"));
				MetaData->SetValue(NewProp_BroadcastChannel, TEXT("Category"), TEXT("Broadcast"));
				MetaData->SetValue(NewProp_BroadcastChannel, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_BroadcastChannel, TEXT("ToolTip"), TEXT("trace channel for state change broadcast"));
				MetaData->SetValue(NewProp_BroadcastInterval, TEXT("Category"), TEXT("Broadcast"));
				MetaData->SetValue(NewProp_BroadcastInterval, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_BroadcastInterval, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_BroadcastInterval, TEXT("ToolTip"), TEXT("interval for state change broadcast (0 = single broadcast)"));
				MetaData->SetValue(NewProp_BroadcastInterval, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_BroadcastRadius, TEXT("Category"), TEXT("Broadcast"));
				MetaData->SetValue(NewProp_BroadcastRadius, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_BroadcastRadius, TEXT("ToolTip"), TEXT("radius of state change broadcast"));
				MetaData->SetValue(NewProp_ObstacleAreaClass, TEXT("Category"), TEXT("Obstacle"));
				MetaData->SetValue(NewProp_ObstacleAreaClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_ObstacleAreaClass, TEXT("ToolTip"), TEXT("area class for simple box obstacle"));
				MetaData->SetValue(NewProp_ObstacleExtent, TEXT("Category"), TEXT("Obstacle"));
				MetaData->SetValue(NewProp_ObstacleExtent, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_ObstacleExtent, TEXT("ToolTip"), TEXT("extent of simple box obstacle"));
				MetaData->SetValue(NewProp_ObstacleOffset, TEXT("Category"), TEXT("Obstacle"));
				MetaData->SetValue(NewProp_ObstacleOffset, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_ObstacleOffset, TEXT("ToolTip"), TEXT("offset of simple box obstacle"));
				MetaData->SetValue(NewProp_bCreateBoxObstacle, TEXT("Category"), TEXT("Obstacle"));
				MetaData->SetValue(NewProp_bCreateBoxObstacle, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_bCreateBoxObstacle, TEXT("ToolTip"), TEXT("if set, box obstacle area will be added to generation"));
				MetaData->SetValue(NewProp_bNotifyWhenDisabled, TEXT("Category"), TEXT("Broadcast"));
				MetaData->SetValue(NewProp_bNotifyWhenDisabled, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_bNotifyWhenDisabled, TEXT("ToolTip"), TEXT("should link notify nearby agents when it changes state to disabled"));
				MetaData->SetValue(NewProp_bNotifyWhenEnabled, TEXT("Category"), TEXT("Broadcast"));
				MetaData->SetValue(NewProp_bNotifyWhenEnabled, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_bNotifyWhenEnabled, TEXT("ToolTip"), TEXT("should link notify nearby agents when it changes state to enabled"));
				MetaData->SetValue(NewProp_bLinkEnabled, TEXT("Category"), TEXT("SmartLink"));
				MetaData->SetValue(NewProp_bLinkEnabled, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_bLinkEnabled, TEXT("ToolTip"), TEXT("is link currently in enabled state? (area class)"));
				MetaData->SetValue(NewProp_LinkDirection, TEXT("Category"), TEXT("SmartLink"));
				MetaData->SetValue(NewProp_LinkDirection, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_LinkDirection, TEXT("ToolTip"), TEXT("direction of link"));
				MetaData->SetValue(NewProp_LinkRelativeEnd, TEXT("Category"), TEXT("SmartLink"));
				MetaData->SetValue(NewProp_LinkRelativeEnd, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_LinkRelativeEnd, TEXT("ToolTip"), TEXT("end point, relative to owner"));
				MetaData->SetValue(NewProp_LinkRelativeStart, TEXT("Category"), TEXT("SmartLink"));
				MetaData->SetValue(NewProp_LinkRelativeStart, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_LinkRelativeStart, TEXT("ToolTip"), TEXT("start point, relative to owner"));
				MetaData->SetValue(NewProp_DisabledAreaClass, TEXT("Category"), TEXT("SmartLink"));
				MetaData->SetValue(NewProp_DisabledAreaClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_DisabledAreaClass, TEXT("ToolTip"), TEXT("area class to use when link is disabled"));
				MetaData->SetValue(NewProp_EnabledAreaClass, TEXT("Category"), TEXT("SmartLink"));
				MetaData->SetValue(NewProp_EnabledAreaClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_EnabledAreaClass, TEXT("ToolTip"), TEXT("area class to use when link is enabled"));
				MetaData->SetValue(NewProp_NavLinkUserId, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkCustomComponent.h"));
				MetaData->SetValue(NewProp_NavLinkUserId, TEXT("ToolTip"), TEXT("link Id assigned by navigation system"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavLinkCustomComponent(Z_Construct_UClass_UNavLinkCustomComponent, TEXT("UNavLinkCustomComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavLinkCustomComponent);
	UClass* Z_Construct_UClass_UNavModifierComponent_NoRegister()
	{
		return UNavModifierComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavModifierComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UNavRelevantComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavModifierComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_FailsafeExtent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FailsafeExtent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FailsafeExtent, UNavModifierComponent), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_AreaClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AreaClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(AreaClass, UNavModifierComponent), 0x0004000000000001, Z_Construct_UClass_UNavArea_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavModifierComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavModifierComponent.h"));
				MetaData->SetValue(NewProp_FailsafeExtent, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_FailsafeExtent, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavModifierComponent.h"));
				MetaData->SetValue(NewProp_FailsafeExtent, TEXT("ToolTip"), TEXT("box extent used ONLY when owning actor doesn't have collision component"));
				MetaData->SetValue(NewProp_AreaClass, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_AreaClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavModifierComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavModifierComponent(Z_Construct_UClass_UNavModifierComponent, TEXT("UNavModifierComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavModifierComponent);
	UFunction* Z_Construct_UFunction_UPawnNoiseEmitterComponent_MakeNoise()
	{
		struct PawnNoiseEmitterComponent_eventMakeNoise_Parms
		{
			AActor* NoiseMaker;
			float Loudness;
			FVector NoiseLocation;
		};
		UObject* Outer=Z_Construct_UClass_UPawnNoiseEmitterComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MakeNoise"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20404, 65535, sizeof(PawnNoiseEmitterComponent_eventMakeNoise_Parms));
			UProperty* NewProp_NoiseLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NoiseLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NoiseLocation, PawnNoiseEmitterComponent_eventMakeNoise_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Loudness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Loudness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Loudness, PawnNoiseEmitterComponent_eventMakeNoise_Parms), 0x0000000000000080);
			UProperty* NewProp_NoiseMaker = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NoiseMaker"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NoiseMaker, PawnNoiseEmitterComponent_eventMakeNoise_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|PawnNoiseEmitter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Cache noises instigated by the owning pawn for AI sensing\n@param NoiseMaker - is the actual actor which made the noise\n@param Loudness - is the relative loudness of the noise (0.0 to 1.0)\n@param NoiseLocation - is the position of the noise"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPawnNoiseEmitterComponent_NoRegister()
	{
		return UPawnNoiseEmitterComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPawnNoiseEmitterComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPawnNoiseEmitterComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPawnNoiseEmitterComponent_MakeNoise());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LastLocalNoiseTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastLocalNoiseTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastLocalNoiseTime, UPawnNoiseEmitterComponent), 0x0000000000000000);
				UProperty* NewProp_LastLocalNoiseVolume = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastLocalNoiseVolume"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastLocalNoiseVolume, UPawnNoiseEmitterComponent), 0x0000000000000000);
				UProperty* NewProp_LastRemoteNoiseTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastRemoteNoiseTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastRemoteNoiseTime, UPawnNoiseEmitterComponent), 0x0000000000000000);
				UProperty* NewProp_LastRemoteNoiseVolume = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastRemoteNoiseVolume"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LastRemoteNoiseVolume, UPawnNoiseEmitterComponent), 0x0000000000000000);
				UProperty* NewProp_NoiseLifetime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NoiseLifetime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NoiseLifetime, UPawnNoiseEmitterComponent), 0x0000000000000005);
				UProperty* NewProp_LastRemoteNoisePosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LastRemoteNoisePosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LastRemoteNoisePosition, UPawnNoiseEmitterComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAIPerceptionSystemCompatibilityMode, UPawnNoiseEmitterComponent, uint8);
				UProperty* NewProp_bAIPerceptionSystemCompatibilityMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAIPerceptionSystemCompatibilityMode"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAIPerceptionSystemCompatibilityMode, UPawnNoiseEmitterComponent), 0x00000c0000010001, CPP_BOOL_PROPERTY_BITMASK(bAIPerceptionSystemCompatibilityMode, UPawnNoiseEmitterComponent), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPawnNoiseEmitterComponent_MakeNoise()); // 2219479678
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("AI"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("PawnNoiseEmitterComponent tracks noise event data used by SensingComponents to hear a Pawn.\nThis component is intended to exist on either a Pawn or its Controller. It does nothing on network clients."));
				MetaData->SetValue(NewProp_LastLocalNoiseTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_LastLocalNoiseTime, TEXT("ToolTip"), TEXT("Time of last local noise update"));
				MetaData->SetValue(NewProp_LastLocalNoiseVolume, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_LastLocalNoiseVolume, TEXT("ToolTip"), TEXT("Most recent noise made by this pawn at its own location"));
				MetaData->SetValue(NewProp_LastRemoteNoiseTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_LastRemoteNoiseTime, TEXT("ToolTip"), TEXT("Time of last remote noise update"));
				MetaData->SetValue(NewProp_LastRemoteNoiseVolume, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_LastRemoteNoiseVolume, TEXT("ToolTip"), TEXT("Most recent volume of noise made by this pawn not at its own location"));
				MetaData->SetValue(NewProp_NoiseLifetime, TEXT("Category"), TEXT("Noise Settings"));
				MetaData->SetValue(NewProp_NoiseLifetime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_NoiseLifetime, TEXT("ToolTip"), TEXT("After this amount of time, new sound events will overwrite previous sounds even if they are not louder (allows old sounds to decay)"));
				MetaData->SetValue(NewProp_LastRemoteNoisePosition, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_LastRemoteNoisePosition, TEXT("ToolTip"), TEXT("Most recent noise made by this pawn not at its own location"));
				MetaData->SetValue(NewProp_bAIPerceptionSystemCompatibilityMode, TEXT("Category"), TEXT("AI|Perception"));
				MetaData->SetValue(NewProp_bAIPerceptionSystemCompatibilityMode, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PawnNoiseEmitterComponent.h"));
				MetaData->SetValue(NewProp_bAIPerceptionSystemCompatibilityMode, TEXT("ToolTip"), TEXT("If set to true (default value) will notify AIPerceptionSystem about noise events\notherwise only PawnSensingComponents will be able to pick up noises generated by this component"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPawnNoiseEmitterComponent(Z_Construct_UClass_UPawnNoiseEmitterComponent, TEXT("UPawnNoiseEmitterComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPawnNoiseEmitterComponent);
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_GetTargetLocationAndRotation()
	{
		struct PhysicsHandleComponent_eventGetTargetLocationAndRotation_Parms
		{
			FVector TargetLocation;
			FRotator TargetRotation;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetLocationAndRotation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20403, 65535, sizeof(PhysicsHandleComponent_eventGetTargetLocationAndRotation_Parms));
			UProperty* NewProp_TargetRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TargetRotation, PhysicsHandleComponent_eventGetTargetLocationAndRotation_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_TargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TargetLocation, PhysicsHandleComponent_eventGetTargetLocationAndRotation_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current location and rotation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_GrabComponent()
	{
		struct PhysicsHandleComponent_eventGrabComponent_Parms
		{
			UPrimitiveComponent* Component;
			FName InBoneName;
			FVector GrabLocation;
			bool bConstrainRotation;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GrabComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820403, 65535, sizeof(PhysicsHandleComponent_eventGrabComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConstrainRotation, PhysicsHandleComponent_eventGrabComponent_Parms, bool);
			UProperty* NewProp_bConstrainRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bConstrainRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConstrainRotation, PhysicsHandleComponent_eventGrabComponent_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bConstrainRotation, PhysicsHandleComponent_eventGrabComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_GrabLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrabLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GrabLocation, PhysicsHandleComponent_eventGrabComponent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InBoneName, PhysicsHandleComponent_eventGrabComponent_Parms), 0x0000000000000080);
			UProperty* NewProp_Component = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Component"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Component, PhysicsHandleComponent_eventGrabComponent_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grab the specified component"));
			MetaData->SetValue(NewProp_Component, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_ReleaseComponent()
	{
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReleaseComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Release the currently held component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularDamping()
	{
		struct PhysicsHandleComponent_eventSetAngularDamping_Parms
		{
			float NewAngularDamping;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularDamping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsHandleComponent_eventSetAngularDamping_Parms));
			UProperty* NewProp_NewAngularDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAngularDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewAngularDamping, PhysicsHandleComponent_eventSetAngularDamping_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set angular damping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularStiffness()
	{
		struct PhysicsHandleComponent_eventSetAngularStiffness_Parms
		{
			float NewAngularStiffness;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAngularStiffness"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsHandleComponent_eventSetAngularStiffness_Parms));
			UProperty* NewProp_NewAngularStiffness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAngularStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewAngularStiffness, PhysicsHandleComponent_eventSetAngularStiffness_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set angular stiffness"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetInterpolationSpeed()
	{
		struct PhysicsHandleComponent_eventSetInterpolationSpeed_Parms
		{
			float NewInterpolationSpeed;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetInterpolationSpeed"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsHandleComponent_eventSetInterpolationSpeed_Parms));
			UProperty* NewProp_NewInterpolationSpeed = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInterpolationSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewInterpolationSpeed, PhysicsHandleComponent_eventSetInterpolationSpeed_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set interpolation speed"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearDamping()
	{
		struct PhysicsHandleComponent_eventSetLinearDamping_Parms
		{
			float NewLinearDamping;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearDamping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsHandleComponent_eventSetLinearDamping_Parms));
			UProperty* NewProp_NewLinearDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLinearDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewLinearDamping, PhysicsHandleComponent_eventSetLinearDamping_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set linear damping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearStiffness()
	{
		struct PhysicsHandleComponent_eventSetLinearStiffness_Parms
		{
			float NewLinearStiffness;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLinearStiffness"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PhysicsHandleComponent_eventSetLinearStiffness_Parms));
			UProperty* NewProp_NewLinearStiffness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLinearStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewLinearStiffness, PhysicsHandleComponent_eventSetLinearStiffness_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set linear stiffness"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocation()
	{
		struct PhysicsHandleComponent_eventSetTargetLocation_Parms
		{
			FVector NewLocation;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTargetLocation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820403, 65535, sizeof(PhysicsHandleComponent_eventSetTargetLocation_Parms));
			UProperty* NewProp_NewLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewLocation, PhysicsHandleComponent_eventSetTargetLocation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the target location"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocationAndRotation()
	{
		struct PhysicsHandleComponent_eventSetTargetLocationAndRotation_Parms
		{
			FVector NewLocation;
			FRotator NewRotation;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTargetLocationAndRotation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820403, 65535, sizeof(PhysicsHandleComponent_eventSetTargetLocationAndRotation_Parms));
			UProperty* NewProp_NewRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewRotation, PhysicsHandleComponent_eventSetTargetLocationAndRotation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_NewLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewLocation, PhysicsHandleComponent_eventSetTargetLocationAndRotation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set target location and rotation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetRotation()
	{
		struct PhysicsHandleComponent_eventSetTargetRotation_Parms
		{
			FRotator NewRotation;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsHandleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTargetRotation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820403, 65535, sizeof(PhysicsHandleComponent_eventSetTargetRotation_Parms));
			UProperty* NewProp_NewRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewRotation, PhysicsHandleComponent_eventSetTargetRotation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|PhysicsHandle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the target rotation"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPhysicsHandleComponent_NoRegister()
	{
		return UPhysicsHandleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPhysicsHandleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPhysicsHandleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A82080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_GetTargetLocationAndRotation());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_GrabComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_ReleaseComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetInterpolationSpeed());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocationAndRotation());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetRotation());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_InterpolationSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InterpolationSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InterpolationSpeed, UPhysicsHandleComponent), 0x0000000000000015);
				UProperty* NewProp_AngularStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AngularStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularStiffness, UPhysicsHandleComponent), 0x0000000000000015);
				UProperty* NewProp_AngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AngularDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AngularDamping, UPhysicsHandleComponent), 0x0000000000000015);
				UProperty* NewProp_LinearStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LinearStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearStiffness, UPhysicsHandleComponent), 0x0000000000000015);
				UProperty* NewProp_LinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LinearDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LinearDamping, UPhysicsHandleComponent), 0x0000000000000015);
				UProperty* NewProp_GrabbedComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GrabbedComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(GrabbedComponent, UPhysicsHandleComponent), 0x0000000000080008, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_GetTargetLocationAndRotation()); // 1491922571
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_GrabComponent()); // 4007316172
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_ReleaseComponent()); // 178797568
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularDamping()); // 1174580648
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetAngularStiffness()); // 258464589
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetInterpolationSpeed()); // 619105469
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearDamping()); // 609444691
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetLinearStiffness()); // 3147070161
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocation()); // 3322594315
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetLocationAndRotation()); // 735765875
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsHandleComponent_SetTargetRotation()); // 1086374537
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Utility object for moving physics objects around."));
				MetaData->SetValue(NewProp_InterpolationSpeed, TEXT("Category"), TEXT("PhysicsHandle"));
				MetaData->SetValue(NewProp_InterpolationSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(NewProp_InterpolationSpeed, TEXT("ToolTip"), TEXT("How quickly we interpolate the physics target transform"));
				MetaData->SetValue(NewProp_AngularStiffness, TEXT("Category"), TEXT("PhysicsHandle"));
				MetaData->SetValue(NewProp_AngularStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(NewProp_AngularStiffness, TEXT("ToolTip"), TEXT("Angular stiffness of the handle spring"));
				MetaData->SetValue(NewProp_AngularDamping, TEXT("Category"), TEXT("PhysicsHandle"));
				MetaData->SetValue(NewProp_AngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(NewProp_AngularDamping, TEXT("ToolTip"), TEXT("Angular stiffness of the handle spring"));
				MetaData->SetValue(NewProp_LinearStiffness, TEXT("Category"), TEXT("PhysicsHandle"));
				MetaData->SetValue(NewProp_LinearStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(NewProp_LinearStiffness, TEXT("ToolTip"), TEXT("Linear stiffness of the handle spring"));
				MetaData->SetValue(NewProp_LinearDamping, TEXT("Category"), TEXT("PhysicsHandle"));
				MetaData->SetValue(NewProp_LinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(NewProp_LinearDamping, TEXT("ToolTip"), TEXT("Linear damping of the handle spring."));
				MetaData->SetValue(NewProp_GrabbedComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_GrabbedComponent, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsHandleComponent.h"));
				MetaData->SetValue(NewProp_GrabbedComponent, TEXT("ToolTip"), TEXT("Component we are currently holding"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPhysicsHandleComponent(Z_Construct_UClass_UPhysicsHandleComponent, TEXT("UPhysicsHandleComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPhysicsHandleComponent);
	UFunction* Z_Construct_UDelegateFunction_UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature()
	{
		UObject* Outer=Z_Construct_UClass_UPlatformEventsComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlatformEventDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPlatformEventsComponent_IsInLaptopMode()
	{
		struct PlatformEventsComponent_eventIsInLaptopMode_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPlatformEventsComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInLaptopMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PlatformEventsComponent_eventIsInLaptopMode_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PlatformEventsComponent_eventIsInLaptopMode_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PlatformEventsComponent_eventIsInLaptopMode_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PlatformEventsComponent_eventIsInLaptopMode_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Activation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check whether a convertible laptop is laptop mode.\n\n@return true if in laptop mode, false otherwise or if not a convertible laptop.\n@see IsInTabletMode, SupportsConvertibleLaptops"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPlatformEventsComponent_IsInTabletMode()
	{
		struct PlatformEventsComponent_eventIsInTabletMode_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPlatformEventsComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInTabletMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PlatformEventsComponent_eventIsInTabletMode_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PlatformEventsComponent_eventIsInTabletMode_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PlatformEventsComponent_eventIsInTabletMode_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PlatformEventsComponent_eventIsInTabletMode_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Activation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check whether a convertible laptop is laptop mode.\n\n@return true if in tablet mode, false otherwise or if not a convertible laptop.\n@see IsInLaptopMode, SupportsConvertibleLaptops"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPlatformEventsComponent_SupportsConvertibleLaptops()
	{
		struct PlatformEventsComponent_eventSupportsConvertibleLaptops_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPlatformEventsComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SupportsConvertibleLaptops"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PlatformEventsComponent_eventSupportsConvertibleLaptops_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, PlatformEventsComponent_eventSupportsConvertibleLaptops_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, PlatformEventsComponent_eventSupportsConvertibleLaptops_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, PlatformEventsComponent_eventSupportsConvertibleLaptops_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Activation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check whether the platform supports convertible laptops.\n\nNote: This does not necessarily mean that the platform is a convertible laptop.\nFor example, convertible laptops running Windows 7 or older will return false,\nand regular laptops running Windows 8 or newer will return true.\n\n@return true for convertible laptop platforms, false otherwise.\n@see IsInLaptopMode, IsInTabletMode"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPlatformEventsComponent_NoRegister()
	{
		return UPlatformEventsComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPlatformEventsComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPlatformEventsComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPlatformEventsComponent_IsInLaptopMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UPlatformEventsComponent_IsInTabletMode());
				OuterClass->LinkChild(Z_Construct_UDelegateFunction_UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature());
				OuterClass->LinkChild(Z_Construct_UFunction_UPlatformEventsComponent_SupportsConvertibleLaptops());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PlatformChangedToTabletModeDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlatformChangedToTabletModeDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(PlatformChangedToTabletModeDelegate, UPlatformEventsComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature());
				UProperty* NewProp_PlatformChangedToLaptopModeDelegate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlatformChangedToLaptopModeDelegate"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(PlatformChangedToLaptopModeDelegate, UPlatformEventsComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPlatformEventsComponent_IsInLaptopMode()); // 3925287634
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPlatformEventsComponent_IsInTabletMode()); // 303206141
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UDelegateFunction_UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature()); // 1012726112
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPlatformEventsComponent_SupportsConvertibleLaptops()); // 159081727
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Activation Components|Activation Collision ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PlatformEventsComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Component to handle receiving notifications from the OS about platform events."));
				MetaData->SetValue(NewProp_PlatformChangedToTabletModeDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
				MetaData->SetValue(NewProp_PlatformChangedToTabletModeDelegate, TEXT("ToolTip"), TEXT("This is called when a convertible laptop changed into tablet mode."));
				MetaData->SetValue(NewProp_PlatformChangedToLaptopModeDelegate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlatformEventsComponent.h"));
				MetaData->SetValue(NewProp_PlatformChangedToLaptopModeDelegate, TEXT("ToolTip"), TEXT("This is called when a convertible laptop changed into laptop mode."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPlatformEventsComponent(Z_Construct_UClass_UPlatformEventsComponent, TEXT("UPlatformEventsComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPlatformEventsComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FAtmospherePrecomputeParameters()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAtmospherePrecomputeParameters_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AtmospherePrecomputeParameters"), sizeof(FAtmospherePrecomputeParameters), Get_Z_Construct_UScriptStruct_FAtmospherePrecomputeParameters_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AtmospherePrecomputeParameters"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAtmospherePrecomputeParameters>, EStructFlags(0x00000001));
			UProperty* NewProp_InscatterNuNum = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InscatterNuNum"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InscatterNuNum, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_InscatterMuSNum = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InscatterMuSNum"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InscatterMuSNum, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_InscatterMuNum = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InscatterMuNum"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InscatterMuNum, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_InscatterAltitudeSampleNum = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InscatterAltitudeSampleNum"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InscatterAltitudeSampleNum, FAtmospherePrecomputeParameters), 0x0000000000000015);
			UProperty* NewProp_IrradianceTexHeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("IrradianceTexHeight"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(IrradianceTexHeight, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_IrradianceTexWidth = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("IrradianceTexWidth"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(IrradianceTexWidth, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_TransmittanceTexHeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TransmittanceTexHeight"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TransmittanceTexHeight, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_TransmittanceTexWidth = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TransmittanceTexWidth"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TransmittanceTexWidth, FAtmospherePrecomputeParameters), 0x0000000000000000);
			UProperty* NewProp_MaxScatteringOrder = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxScatteringOrder"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxScatteringOrder, FAtmospherePrecomputeParameters), 0x0000000000000015);
			UProperty* NewProp_DecayHeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DecayHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DecayHeight_DEPRECATED, FAtmospherePrecomputeParameters), 0x0000000020000000);
			UProperty* NewProp_DensityHeight = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DensityHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DensityHeight, FAtmospherePrecomputeParameters), 0x0000000000000015);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Structure storing Data for pre-computation"));
			MetaData->SetValue(NewProp_InscatterNuNum, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_InscatterNuNum, TEXT("ToolTip"), TEXT("Inscatter Texture Width"));
			MetaData->SetValue(NewProp_InscatterMuSNum, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_InscatterMuSNum, TEXT("ToolTip"), TEXT("Inscatter Texture Width"));
			MetaData->SetValue(NewProp_InscatterMuNum, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_InscatterMuNum, TEXT("ToolTip"), TEXT("Inscatter Texture Height"));
			MetaData->SetValue(NewProp_InscatterAltitudeSampleNum, TEXT("Category"), TEXT("AtmosphereParam"));
			MetaData->SetValue(NewProp_InscatterAltitudeSampleNum, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_InscatterAltitudeSampleNum, TEXT("ToolTip"), TEXT("Number of different altitudes at which to sample inscatter color (size of 3D texture Z dimension)"));
			MetaData->SetValue(NewProp_IrradianceTexHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_IrradianceTexHeight, TEXT("ToolTip"), TEXT("Irradiance Texture Height"));
			MetaData->SetValue(NewProp_IrradianceTexWidth, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_IrradianceTexWidth, TEXT("ToolTip"), TEXT("Irradiance Texture Width"));
			MetaData->SetValue(NewProp_TransmittanceTexHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_TransmittanceTexHeight, TEXT("ToolTip"), TEXT("Transmittance Texture Height"));
			MetaData->SetValue(NewProp_TransmittanceTexWidth, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_TransmittanceTexWidth, TEXT("ToolTip"), TEXT("Transmittance Texture Width"));
			MetaData->SetValue(NewProp_MaxScatteringOrder, TEXT("Category"), TEXT("AtmosphereParam"));
			MetaData->SetValue(NewProp_MaxScatteringOrder, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_MaxScatteringOrder, TEXT("ToolTip"), TEXT("Maximum scattering order"));
			MetaData->SetValue(NewProp_DecayHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_DensityHeight, TEXT("Category"), TEXT("AtmosphereParam"));
			MetaData->SetValue(NewProp_DensityHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(NewProp_DensityHeight, TEXT("ToolTip"), TEXT("Rayleigh scattering density height scale, ranges from [0...1]"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAtmospherePrecomputeParameters_CRC() { return 2759037496U; }
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_DisableGroundScattering()
	{
		struct AtmosphericFogComponent_eventDisableGroundScattering_Parms
		{
			bool NewGroundScattering;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DisableGroundScattering"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventDisableGroundScattering_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(NewGroundScattering, AtmosphericFogComponent_eventDisableGroundScattering_Parms, bool);
			UProperty* NewProp_NewGroundScattering = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewGroundScattering"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(NewGroundScattering, AtmosphericFogComponent_eventDisableGroundScattering_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(NewGroundScattering, AtmosphericFogComponent_eventDisableGroundScattering_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set DisableGroundScattering"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_DisableSunDisk()
	{
		struct AtmosphericFogComponent_eventDisableSunDisk_Parms
		{
			bool NewSunDisk;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DisableSunDisk"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventDisableSunDisk_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(NewSunDisk, AtmosphericFogComponent_eventDisableSunDisk_Parms, bool);
			UProperty* NewProp_NewSunDisk = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSunDisk"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(NewSunDisk, AtmosphericFogComponent_eventDisableSunDisk_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(NewSunDisk, AtmosphericFogComponent_eventDisableSunDisk_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set DisableSunDisk"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetAltitudeScale()
	{
		struct AtmosphericFogComponent_eventSetAltitudeScale_Parms
		{
			float NewAltitudeScale;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAltitudeScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetAltitudeScale_Parms));
			UProperty* NewProp_NewAltitudeScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAltitudeScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewAltitudeScale, AtmosphericFogComponent_eventSetAltitudeScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set AltitudeScale"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultBrightness()
	{
		struct AtmosphericFogComponent_eventSetDefaultBrightness_Parms
		{
			float NewBrightness;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDefaultBrightness"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetDefaultBrightness_Parms));
			UProperty* NewProp_NewBrightness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewBrightness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewBrightness, AtmosphericFogComponent_eventSetDefaultBrightness_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set brightness of the light"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultLightColor()
	{
		struct AtmosphericFogComponent_eventSetDefaultLightColor_Parms
		{
			FLinearColor NewLightColor;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDefaultLightColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820403, 65535, sizeof(AtmosphericFogComponent_eventSetDefaultLightColor_Parms));
			UProperty* NewProp_NewLightColor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLightColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewLightColor, AtmosphericFogComponent_eventSetDefaultLightColor_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set color of the light"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityMultiplier()
	{
		struct AtmosphericFogComponent_eventSetDensityMultiplier_Parms
		{
			float NewDensityMultiplier;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDensityMultiplier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetDensityMultiplier_Parms));
			UProperty* NewProp_NewDensityMultiplier = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDensityMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewDensityMultiplier, AtmosphericFogComponent_eventSetDensityMultiplier_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set DensityMultiplier"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityOffset()
	{
		struct AtmosphericFogComponent_eventSetDensityOffset_Parms
		{
			float NewDensityOffset;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDensityOffset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetDensityOffset_Parms));
			UProperty* NewProp_NewDensityOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDensityOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewDensityOffset, AtmosphericFogComponent_eventSetDensityOffset_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set DensityOffset"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceOffset()
	{
		struct AtmosphericFogComponent_eventSetDistanceOffset_Parms
		{
			float NewDistanceOffset;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDistanceOffset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetDistanceOffset_Parms));
			UProperty* NewProp_NewDistanceOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDistanceOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewDistanceOffset, AtmosphericFogComponent_eventSetDistanceOffset_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set DistanceOffset"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceScale()
	{
		struct AtmosphericFogComponent_eventSetDistanceScale_Parms
		{
			float NewDistanceScale;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDistanceScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetDistanceScale_Parms));
			UProperty* NewProp_NewDistanceScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDistanceScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewDistanceScale, AtmosphericFogComponent_eventSetDistanceScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set DistanceScale"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetFogMultiplier()
	{
		struct AtmosphericFogComponent_eventSetFogMultiplier_Parms
		{
			float NewFogMultiplier;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFogMultiplier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetFogMultiplier_Parms));
			UProperty* NewProp_NewFogMultiplier = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFogMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewFogMultiplier, AtmosphericFogComponent_eventSetFogMultiplier_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set FogMultiplier"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetPrecomputeParams()
	{
		struct AtmosphericFogComponent_eventSetPrecomputeParams_Parms
		{
			float DensityHeight;
			int32 MaxScatteringOrder;
			int32 InscatterAltitudeSampleNum;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPrecomputeParams"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetPrecomputeParams_Parms));
			UProperty* NewProp_InscatterAltitudeSampleNum = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InscatterAltitudeSampleNum"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InscatterAltitudeSampleNum, AtmosphericFogComponent_eventSetPrecomputeParams_Parms), 0x0000000000000080);
			UProperty* NewProp_MaxScatteringOrder = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxScatteringOrder"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MaxScatteringOrder, AtmosphericFogComponent_eventSetPrecomputeParams_Parms), 0x0000000000000080);
			UProperty* NewProp_DensityHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DensityHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DensityHeight, AtmosphericFogComponent_eventSetPrecomputeParams_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set PrecomputeParams, only valid in Editor mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetStartDistance()
	{
		struct AtmosphericFogComponent_eventSetStartDistance_Parms
		{
			float NewStartDistance;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartDistance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetStartDistance_Parms));
			UProperty* NewProp_NewStartDistance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewStartDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewStartDistance, AtmosphericFogComponent_eventSetStartDistance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set StartDistance"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_SetSunMultiplier()
	{
		struct AtmosphericFogComponent_eventSetSunMultiplier_Parms
		{
			float NewSunMultiplier;
		};
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSunMultiplier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(AtmosphericFogComponent_eventSetSunMultiplier_Parms));
			UProperty* NewProp_NewSunMultiplier = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSunMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewSunMultiplier, AtmosphericFogComponent_eventSetSunMultiplier_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set SunMultiplier"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAtmosphericFogComponent_StartPrecompute()
	{
		UObject* Outer=Z_Construct_UClass_UAtmosphericFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartPrecompute"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|AtmosphericFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAtmosphericFogComponent_NoRegister()
	{
		return UAtmosphericFogComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAtmosphericFogComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UAtmosphericFogComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A83080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_DisableGroundScattering());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_DisableSunDisk());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetAltitudeScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultBrightness());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultLightColor());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityMultiplier());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityOffset());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceOffset());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetFogMultiplier());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetPrecomputeParams());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetStartDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_SetSunMultiplier());
				OuterClass->LinkChild(Z_Construct_UFunction_UAtmosphericFogComponent_StartPrecompute());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_IrradianceTexture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IrradianceTexture"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(IrradianceTexture_DEPRECATED, UAtmosphericFogComponent), 0x0000000020000000, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_TransmittanceTexture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TransmittanceTexture"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TransmittanceTexture_DEPRECATED, UAtmosphericFogComponent), 0x0000000020000000, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_PrecomputeParams = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PrecomputeParams"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PrecomputeParams, UAtmosphericFogComponent), 0x0000080000000015, Z_Construct_UScriptStruct_FAtmospherePrecomputeParameters());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableGroundScattering, UAtmosphericFogComponent, uint8);
				UProperty* NewProp_bDisableGroundScattering = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableGroundScattering"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableGroundScattering, UAtmosphericFogComponent), 0x0000000200000015, CPP_BOOL_PROPERTY_BITMASK(bDisableGroundScattering, UAtmosphericFogComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableSunDisk, UAtmosphericFogComponent, uint8);
				UProperty* NewProp_bDisableSunDisk = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableSunDisk"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableSunDisk, UAtmosphericFogComponent), 0x0000000200000015, CPP_BOOL_PROPERTY_BITMASK(bDisableSunDisk, UAtmosphericFogComponent), sizeof(uint8), false);
				UProperty* NewProp_DefaultLightColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultLightColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(DefaultLightColor, UAtmosphericFogComponent), 0x0000000200000015, Z_Construct_UScriptStruct_FColor());
				UProperty* NewProp_DefaultBrightness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultBrightness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DefaultBrightness, UAtmosphericFogComponent), 0x0000000200000015);
				UProperty* NewProp_SunDiscScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SunDiscScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SunDiscScale, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_StartDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StartDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartDistance, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_GroundOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroundOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GroundOffset, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_DistanceOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistanceOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DistanceOffset, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_AltitudeScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AltitudeScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AltitudeScale, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_DistanceScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistanceScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DistanceScale, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_DensityOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DensityOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DensityOffset, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_DensityMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DensityMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DensityMultiplier, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_FogMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FogMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FogMultiplier, UAtmosphericFogComponent), 0x0000000200000005);
				UProperty* NewProp_SunMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SunMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SunMultiplier, UAtmosphericFogComponent), 0x0000000200000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_DisableGroundScattering()); // 3237642179
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_DisableSunDisk()); // 1525430490
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetAltitudeScale()); // 1676682791
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultBrightness()); // 2950348235
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetDefaultLightColor()); // 3706361282
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityMultiplier()); // 328025573
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetDensityOffset()); // 1729121963
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceOffset()); // 572602734
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetDistanceScale()); // 996917054
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetFogMultiplier()); // 1360610164
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetPrecomputeParams()); // 548354124
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetStartDistance()); // 18252868
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_SetSunMultiplier()); // 984361697
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAtmosphericFogComponent_StartPrecompute()); // 1882119291
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Activation Components|Activation Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Used to create fogging effects such as clouds."));
				MetaData->SetValue(NewProp_IrradianceTexture, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_TransmittanceTexture, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_PrecomputeParams, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_PrecomputeParams, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_bDisableGroundScattering, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bDisableGroundScattering, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_bDisableGroundScattering, TEXT("ToolTip"), TEXT("Disable Color scattering from ground."));
				MetaData->SetValue(NewProp_bDisableSunDisk, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bDisableSunDisk, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_bDisableSunDisk, TEXT("ToolTip"), TEXT("Disable Sun Disk rendering."));
				MetaData->SetValue(NewProp_DefaultLightColor, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_DefaultLightColor, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_DefaultLightColor, TEXT("ToolTip"), TEXT("Default light color. Used when there is no sunlight placed in the level."));
				MetaData->SetValue(NewProp_DefaultBrightness, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_DefaultBrightness, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_DefaultBrightness, TEXT("ToolTip"), TEXT("Default light brightness. Used when there is no sunlight placed in the level. Unit is lumens"));
				MetaData->SetValue(NewProp_SunDiscScale, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_SunDiscScale, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_SunDiscScale, TEXT("ToolTip"), TEXT("Distance offset, in km (to handle large distance)"));
				MetaData->SetValue(NewProp_StartDistance, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_StartDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_StartDistance, TEXT("ToolTip"), TEXT("Start Distance."));
				MetaData->SetValue(NewProp_GroundOffset, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_GroundOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_GroundOffset, TEXT("ToolTip"), TEXT("Ground offset."));
				MetaData->SetValue(NewProp_DistanceOffset, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_DistanceOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_DistanceOffset, TEXT("ToolTip"), TEXT("Distance offset, in km (to handle large distance)"));
				MetaData->SetValue(NewProp_AltitudeScale, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_AltitudeScale, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_AltitudeScale, TEXT("ToolTip"), TEXT("Altitude scale (only Z scale)."));
				MetaData->SetValue(NewProp_DistanceScale, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_DistanceScale, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_DistanceScale, TEXT("ToolTip"), TEXT("Distance scale."));
				MetaData->SetValue(NewProp_DensityOffset, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_DensityOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_DensityOffset, TEXT("ToolTip"), TEXT("Fog density offset to control opacity [-1.f ~ 1.f]."));
				MetaData->SetValue(NewProp_DensityMultiplier, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_DensityMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_DensityMultiplier, TEXT("ToolTip"), TEXT("Fog density control factor."));
				MetaData->SetValue(NewProp_FogMultiplier, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_FogMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_FogMultiplier, TEXT("ToolTip"), TEXT("Scattering factor on object."));
				MetaData->SetValue(NewProp_SunMultiplier, TEXT("Category"), TEXT("Atmosphere"));
				MetaData->SetValue(NewProp_SunMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Atmosphere/AtmosphericFogComponent.h"));
				MetaData->SetValue(NewProp_SunMultiplier, TEXT("ToolTip"), TEXT("Global scattering factor."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAtmosphericFogComponent(Z_Construct_UClass_UAtmosphericFogComponent, TEXT("UAtmosphericFogComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAtmosphericFogComponent);
	UEnum* Z_Construct_UEnum_Engine_ESoundSpatializationAlgorithm()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESoundSpatializationAlgorithm_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESoundSpatializationAlgorithm"), 0, Get_Z_Construct_UEnum_Engine_ESoundSpatializationAlgorithm_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESoundSpatializationAlgorithm"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SPATIALIZATION_Default")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SPATIALIZATION_HRTF")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SPATIALIZATION_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESoundSpatializationAlgorithm_CRC() { return 264619209U; }
	UEnum* Z_Construct_UEnum_Engine_EAttenuationShape()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAttenuationShape_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAttenuationShape"), 0, Get_Z_Construct_UEnum_Engine_EAttenuationShape_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAttenuationShape"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAttenuationShape::Sphere")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAttenuationShape::Capsule")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAttenuationShape::Box")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAttenuationShape::Cone")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAttenuationShape::EAttenuationShape_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAttenuationShape_CRC() { return 2796493825U; }
	UEnum* Z_Construct_UEnum_Engine_ESoundDistanceCalc()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESoundDistanceCalc_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESoundDistanceCalc"), 0, Get_Z_Construct_UEnum_Engine_ESoundDistanceCalc_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESoundDistanceCalc"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SOUNDDISTANCE_Normal")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SOUNDDISTANCE_InfiniteXYPlane")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SOUNDDISTANCE_InfiniteXZPlane")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SOUNDDISTANCE_InfiniteYZPlane")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SOUNDDISTANCE_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESoundDistanceCalc_CRC() { return 2279305397U; }
	UEnum* Z_Construct_UEnum_Engine_ESoundDistanceModel()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESoundDistanceModel_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESoundDistanceModel"), 0, Get_Z_Construct_UEnum_Engine_ESoundDistanceModel_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESoundDistanceModel"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_Linear")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_Logarithmic")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_Inverse")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_LogReverse")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_NaturalSound")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_Custom")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ATTENUATION_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESoundDistanceModel_CRC() { return 1317535997U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAttenuationSettings()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAttenuationSettings_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AttenuationSettings"), sizeof(FAttenuationSettings), Get_Z_Construct_UScriptStruct_FAttenuationSettings_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AttenuationSettings"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAttenuationSettings>, EStructFlags(0x00000201));
			UProperty* NewProp_LPFRadiusMax = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LPFRadiusMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LPFRadiusMax, FAttenuationSettings), 0x0000000000000005);
			UProperty* NewProp_LPFRadiusMin = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LPFRadiusMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LPFRadiusMin, FAttenuationSettings), 0x0000000000000005);
			UProperty* NewProp_FalloffDistance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FalloffDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FalloffDistance, FAttenuationSettings), 0x0000000000000005);
			UProperty* NewProp_ConeOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ConeOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ConeOffset, FAttenuationSettings), 0x0000000000000005);
			UProperty* NewProp_AttenuationShapeExtents = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AttenuationShapeExtents"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AttenuationShapeExtents, FAttenuationSettings), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_RadiusMax = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RadiusMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RadiusMax_DEPRECATED, FAttenuationSettings), 0x0000000020000000);
			UProperty* NewProp_RadiusMin = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RadiusMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RadiusMin_DEPRECATED, FAttenuationSettings), 0x0000000020000000);
			UProperty* NewProp_SpatializationAlgorithm = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SpatializationAlgorithm"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SpatializationAlgorithm, FAttenuationSettings), 0x0000000000000005, Z_Construct_UEnum_Engine_ESoundSpatializationAlgorithm());
			UProperty* NewProp_OmniRadius = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OmniRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OmniRadius, FAttenuationSettings), 0x0000000000000005);
			UProperty* NewProp_dBAttenuationAtMax = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("dBAttenuationAtMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(dBAttenuationAtMax, FAttenuationSettings), 0x0000000000000005);
			UProperty* NewProp_AttenuationShape = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AttenuationShape"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(AttenuationShape, FAttenuationSettings), 0x0000000000000005, Z_Construct_UEnum_Engine_EAttenuationShape());
			UProperty* NewProp_DistanceType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DistanceType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DistanceType_DEPRECATED, FAttenuationSettings), 0x0000000020000000, Z_Construct_UEnum_Engine_ESoundDistanceCalc());
			UProperty* NewProp_CustomAttenuationCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomAttenuationCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CustomAttenuationCurve, FAttenuationSettings), 0x0000000000000005, Z_Construct_UScriptStruct_FRuntimeFloatCurve());
			UProperty* NewProp_DistanceAlgorithm = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DistanceAlgorithm"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DistanceAlgorithm, FAttenuationSettings), 0x0000000000000005, Z_Construct_UEnum_Engine_ESoundDistanceModel());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAttenuateWithLPF, FAttenuationSettings, uint8);
			UProperty* NewProp_bAttenuateWithLPF = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAttenuateWithLPF"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAttenuateWithLPF, FAttenuationSettings), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bAttenuateWithLPF, FAttenuationSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSpatialize, FAttenuationSettings, uint8);
			UProperty* NewProp_bSpatialize = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSpatialize"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSpatialize, FAttenuationSettings), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bSpatialize, FAttenuationSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAttenuate, FAttenuationSettings, uint8);
			UProperty* NewProp_bAttenuate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAttenuate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAttenuate, FAttenuationSettings), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bAttenuate, FAttenuationSettings), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("The settings for attenuating."));
			MetaData->SetValue(NewProp_LPFRadiusMax, TEXT("Category"), TEXT("LowPassFilter"));
			MetaData->SetValue(NewProp_LPFRadiusMax, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_LPFRadiusMax, TEXT("ToolTip"), TEXT("The range at which to apply the maximum amount of low pass filter."));
			MetaData->SetValue(NewProp_LPFRadiusMin, TEXT("Category"), TEXT("LowPassFilter"));
			MetaData->SetValue(NewProp_LPFRadiusMin, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_LPFRadiusMin, TEXT("ToolTip"), TEXT("The range at which to start applying a low pass filter."));
			MetaData->SetValue(NewProp_FalloffDistance, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_FalloffDistance, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_FalloffDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_FalloffDistance, TEXT("ToolTip"), TEXT("The distance over which falloff occurs."));
			MetaData->SetValue(NewProp_ConeOffset, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_ConeOffset, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_ConeOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_ConeOffset, TEXT("ToolTip"), TEXT("The distance back from the sound's origin to begin the cone when using the cone attenuation shape."));
			MetaData->SetValue(NewProp_AttenuationShapeExtents, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_AttenuationShapeExtents, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_AttenuationShapeExtents, TEXT("ToolTip"), TEXT("The dimensions to use for the attenuation shape. Interpretation of the values differ per shape.\n         Sphere  - X is Sphere Radius. Y and Z are unused\n         Capsule - X is Capsule Half Height, Y is Capsule Radius, Z is unused\n         Box     - X, Y, and Z are the Box's dimensions\n         Cone    - X is Cone Radius, Y is Cone Angle, Z is Cone Falloff Angle"));
			MetaData->SetValue(NewProp_RadiusMax, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_RadiusMin, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_SpatializationAlgorithm, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_SpatializationAlgorithm, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_SpatializationAlgorithm, TEXT("DisplayName"), TEXT("Spatialization Algorithm"));
			MetaData->SetValue(NewProp_SpatializationAlgorithm, TEXT("EditCondition"), TEXT("bSpatialize"));
			MetaData->SetValue(NewProp_SpatializationAlgorithm, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_SpatializationAlgorithm, TEXT("ToolTip"), TEXT("Which spatialization algorithm to use if spatializing mono sources."));
			MetaData->SetValue(NewProp_OmniRadius, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_OmniRadius, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_OmniRadius, TEXT("DisplayName"), TEXT("Non-Spatialized Radius"));
			MetaData->SetValue(NewProp_OmniRadius, TEXT("EditCondition"), TEXT("bSpatialize"));
			MetaData->SetValue(NewProp_OmniRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_OmniRadius, TEXT("ToolTip"), TEXT("At what distance we start treating the sound source as spatialized"));
			MetaData->SetValue(NewProp_dBAttenuationAtMax, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_dBAttenuationAtMax, TEXT("ClampMax"), TEXT("0"));
			MetaData->SetValue(NewProp_dBAttenuationAtMax, TEXT("DisplayName"), TEXT("dB Attenuation At Max"));
			MetaData->SetValue(NewProp_dBAttenuationAtMax, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_dBAttenuationAtMax, TEXT("ToolTip"), TEXT("The volume at maximum distance in deciBels."));
			MetaData->SetValue(NewProp_AttenuationShape, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_AttenuationShape, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_AttenuationShape, TEXT("ToolTip"), TEXT("The shape of the attenuation volume."));
			MetaData->SetValue(NewProp_DistanceType, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_CustomAttenuationCurve, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_CustomAttenuationCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_DistanceAlgorithm, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_DistanceAlgorithm, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_DistanceAlgorithm, TEXT("ToolTip"), TEXT("The type of volume versus distance algorithm to use for the attenuation model."));
			MetaData->SetValue(NewProp_bAttenuateWithLPF, TEXT("Category"), TEXT("LowPassFilter"));
			MetaData->SetValue(NewProp_bAttenuateWithLPF, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_bAttenuateWithLPF, TEXT("ToolTip"), TEXT("Enable attenuation via low pass filter."));
			MetaData->SetValue(NewProp_bSpatialize, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_bSpatialize, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_bSpatialize, TEXT("ToolTip"), TEXT("Enable the source to be positioned in 3D."));
			MetaData->SetValue(NewProp_bAttenuate, TEXT("Category"), TEXT("Attenuation"));
			MetaData->SetValue(NewProp_bAttenuate, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
			MetaData->SetValue(NewProp_bAttenuate, TEXT("ToolTip"), TEXT("Enable attenuation via volume."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAttenuationSettings_CRC() { return 1141572707U; }
	UClass* Z_Construct_UClass_USoundAttenuation_NoRegister()
	{
		return USoundAttenuation::StaticClass();
	}
	UClass* Z_Construct_UClass_USoundAttenuation()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = USoundAttenuation::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20081080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Attenuation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Attenuation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Attenuation, USoundAttenuation), 0x0000000000000001, Z_Construct_UScriptStruct_FAttenuationSettings());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Sound/SoundAttenuation.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Defines how a sound changes volume with distance to the listener"));
				MetaData->SetValue(NewProp_Attenuation, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_Attenuation, TEXT("ModuleRelativePath"), TEXT("Classes/Sound/SoundAttenuation.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USoundAttenuation(Z_Construct_UClass_USoundAttenuation, TEXT("USoundAttenuation"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USoundAttenuation);
	UFunction* Z_Construct_UDelegateFunction_Engine_OnQueueSubtitles__DelegateSignature()
	{
		struct _Script_Engine_eventOnQueueSubtitles_Parms
		{
			TArray<FSubtitleCue> Subtitles;
			float CueDuration;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnQueueSubtitles__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00120000, 65535, sizeof(_Script_Engine_eventOnQueueSubtitles_Parms));
			UProperty* NewProp_CueDuration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CueDuration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CueDuration, _Script_Engine_eventOnQueueSubtitles_Parms), 0x0000000000000080);
			UProperty* NewProp_Subtitles = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Subtitles"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Subtitles, _Script_Engine_eventOnQueueSubtitles_Parms), 0x0000000008000182);
			UProperty* NewProp_Subtitles_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Subtitles, TEXT("Subtitles"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FSubtitleCue());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when subtitles are sent to the SubtitleManager.  Set this delegate if you want to hijack the subtitles for other purposes"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_OnAudioFinished__DelegateSignature()
	{
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnAudioFinished__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early"));
#endif
		}
		return ReturnFunction;
	}
	UScriptStruct* Z_Construct_UScriptStruct_FAudioComponentParam()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAudioComponentParam_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AudioComponentParam"), sizeof(FAudioComponentParam), Get_Z_Construct_UScriptStruct_FAudioComponentParam_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AudioComponentParam"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAudioComponentParam>, EStructFlags(0x00000001));
			UProperty* NewProp_SoundWaveParam = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SoundWaveParam"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SoundWaveParam, FAudioComponentParam), 0x0000000000000005, Z_Construct_UClass_USoundWave_NoRegister());
			UProperty* NewProp_IntParam = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("IntParam"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(IntParam, FAudioComponentParam), 0x0000000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(BoolParam, FAudioComponentParam, bool);
			UProperty* NewProp_BoolParam = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoolParam"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(BoolParam, FAudioComponentParam), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(BoolParam, FAudioComponentParam), sizeof(bool), true);
			UProperty* NewProp_FloatParam = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatParam"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FloatParam, FAudioComponentParam), 0x0000000000000005);
			UProperty* NewProp_ParamName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ParamName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParamName, FAudioComponentParam), 0x0000000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct used for storing one per-instance named parameter for this AudioComponent.\nCertain nodes in the SoundCue may reference parameters by name so they can be adjusted per-instance."));
			MetaData->SetValue(NewProp_SoundWaveParam, TEXT("Category"), TEXT("AudioComponentParam"));
			MetaData->SetValue(NewProp_SoundWaveParam, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(NewProp_SoundWaveParam, TEXT("ToolTip"), TEXT("Value of the parameter when used as a sound wave"));
			MetaData->SetValue(NewProp_IntParam, TEXT("Category"), TEXT("AudioComponentParam"));
			MetaData->SetValue(NewProp_IntParam, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(NewProp_IntParam, TEXT("ToolTip"), TEXT("Value of the parameter when used as an integer"));
			MetaData->SetValue(NewProp_BoolParam, TEXT("Category"), TEXT("AudioComponentParam"));
			MetaData->SetValue(NewProp_BoolParam, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(NewProp_BoolParam, TEXT("ToolTip"), TEXT("Value of the parameter when used as a boolean"));
			MetaData->SetValue(NewProp_FloatParam, TEXT("Category"), TEXT("AudioComponentParam"));
			MetaData->SetValue(NewProp_FloatParam, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(NewProp_FloatParam, TEXT("ToolTip"), TEXT("Value of the parameter when used as a float"));
			MetaData->SetValue(NewProp_ParamName, TEXT("Category"), TEXT("AudioComponentParam"));
			MetaData->SetValue(NewProp_ParamName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(NewProp_ParamName, TEXT("ToolTip"), TEXT("Name of the parameter"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAudioComponentParam_CRC() { return 1941729195U; }
	UFunction* Z_Construct_UFunction_UAudioComponent_AdjustAttenuation()
	{
		struct AudioComponent_eventAdjustAttenuation_Parms
		{
			FAttenuationSettings InAttenuationSettings;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdjustAttenuation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AudioComponent_eventAdjustAttenuation_Parms));
			UProperty* NewProp_InAttenuationSettings = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAttenuationSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InAttenuationSettings, AudioComponent_eventAdjustAttenuation_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FAttenuationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Modify the attenuation settings of the audio component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_AdjustVolume()
	{
		struct AudioComponent_eventAdjustVolume_Parms
		{
			float AdjustVolumeDuration;
			float AdjustVolumeLevel;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdjustVolume"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventAdjustVolume_Parms));
			UProperty* NewProp_AdjustVolumeLevel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdjustVolumeLevel"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AdjustVolumeLevel, AudioComponent_eventAdjustVolume_Parms), 0x0000000000000080);
			UProperty* NewProp_AdjustVolumeDuration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdjustVolumeDuration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AdjustVolumeDuration, AudioComponent_eventAdjustVolume_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("This will allow one to adjust the volume of an AudioComponent on the fly"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_BP_GetAttenuationSettingsToApply()
	{
		struct AudioComponent_eventBP_GetAttenuationSettingsToApply_Parms
		{
			FAttenuationSettings OutAttenuationSettings;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BP_GetAttenuationSettingsToApply"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AudioComponent_eventBP_GetAttenuationSettingsToApply_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AudioComponent_eventBP_GetAttenuationSettingsToApply_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AudioComponent_eventBP_GetAttenuationSettingsToApply_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AudioComponent_eventBP_GetAttenuationSettingsToApply_Parms), sizeof(bool), true);
			UProperty* NewProp_OutAttenuationSettings = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutAttenuationSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutAttenuationSettings, AudioComponent_eventBP_GetAttenuationSettingsToApply_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FAttenuationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Get Attenuation Settings To Apply"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_FadeIn()
	{
		struct AudioComponent_eventFadeIn_Parms
		{
			float FadeInDuration;
			float FadeVolumeLevel;
			float StartTime;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FadeIn"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventFadeIn_Parms));
			UProperty* NewProp_StartTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartTime, AudioComponent_eventFadeIn_Parms), 0x0000000000000080);
			UProperty* NewProp_FadeVolumeLevel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FadeVolumeLevel"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FadeVolumeLevel, AudioComponent_eventFadeIn_Parms), 0x0000000000000080);
			UProperty* NewProp_FadeInDuration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FadeInDuration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FadeInDuration, AudioComponent_eventFadeIn_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FadeVolumeLevel"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_StartTime"), TEXT("0.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("This can be used in place of \"play\" when it is desired to fade in the sound over time.\n\nIf FadeTime is 0.0, the change in volume is instant.\nIf FadeTime is > 0.0, the multiplier will be increased from 0 to FadeVolumeLevel over FadeIn seconds.\n\n@param FadeInDuration how long it should take to reach the FadeVolumeLevel\n@param FadeVolumeLevel the percentage of the AudioComponents's calculated volume to fade to"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_FadeOut()
	{
		struct AudioComponent_eventFadeOut_Parms
		{
			float FadeOutDuration;
			float FadeVolumeLevel;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FadeOut"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventFadeOut_Parms));
			UProperty* NewProp_FadeVolumeLevel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FadeVolumeLevel"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FadeVolumeLevel, AudioComponent_eventFadeOut_Parms), 0x0000000000000080);
			UProperty* NewProp_FadeOutDuration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FadeOutDuration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FadeOutDuration, AudioComponent_eventFadeOut_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("This is used in place of \"stop\" when it is desired to fade the volume of the sound before stopping.\n\nIf FadeTime is 0.0, this is the same as calling Stop().\nIf FadeTime is > 0.0, this will adjust the volume multiplier to FadeVolumeLevel over FadeInTime seconds\nand then stop the sound.\n\n@param FadeOutDuration how long it should take to reach the FadeVolumeLevel\n@param FadeVolumeLevel the percentage of the AudioComponents's calculated volume in which to fade to"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_IsPlaying()
	{
		struct AudioComponent_eventIsPlaying_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsPlaying"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(AudioComponent_eventIsPlaying_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AudioComponent_eventIsPlaying_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AudioComponent_eventIsPlaying_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AudioComponent_eventIsPlaying_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return true if this component is currently playing a SoundCue."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_Play()
	{
		struct AudioComponent_eventPlay_Parms
		{
			float StartTime;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Play"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventPlay_Parms));
			UProperty* NewProp_StartTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartTime, AudioComponent_eventPlay_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_StartTime"), TEXT("0.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Start a sound playing on an audio component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetBoolParameter()
	{
		struct AudioComponent_eventSetBoolParameter_Parms
		{
			FName InName;
			bool InBool;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoolParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetBoolParameter_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(InBool, AudioComponent_eventSetBoolParameter_Parms, bool);
			UProperty* NewProp_InBool = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBool"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(InBool, AudioComponent_eventSetBoolParameter_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(InBool, AudioComponent_eventSetBoolParameter_Parms), sizeof(bool), true);
			UProperty* NewProp_InName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InName, AudioComponent_eventSetBoolParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set Boolean Parameter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a boolean instance parameter for use in sound cues played by this audio component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetFloatParameter()
	{
		struct AudioComponent_eventSetFloatParameter_Parms
		{
			FName InName;
			float InFloat;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFloatParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetFloatParameter_Parms));
			UProperty* NewProp_InFloat = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InFloat"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InFloat, AudioComponent_eventSetFloatParameter_Parms), 0x0000000000000080);
			UProperty* NewProp_InName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InName, AudioComponent_eventSetFloatParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a float instance parameter for use in sound cues played by this audio component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetIntParameter()
	{
		struct AudioComponent_eventSetIntParameter_Parms
		{
			FName InName;
			int32 InInt;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetIntParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetIntParameter_Parms));
			UProperty* NewProp_InInt = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InInt"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InInt, AudioComponent_eventSetIntParameter_Parms), 0x0000000000000080);
			UProperty* NewProp_InName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InName, AudioComponent_eventSetIntParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set Integer Parameter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set an integer instance parameter for use in sound cues played by this audio component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetPitchMultiplier()
	{
		struct AudioComponent_eventSetPitchMultiplier_Parms
		{
			float NewPitchMultiplier;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPitchMultiplier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetPitchMultiplier_Parms));
			UProperty* NewProp_NewPitchMultiplier = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewPitchMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewPitchMultiplier, AudioComponent_eventSetPitchMultiplier_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new pitch multiplier"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetSound()
	{
		struct AudioComponent_eventSetSound_Parms
		{
			USoundBase* NewSound;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSound"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetSound_Parms));
			UProperty* NewProp_NewSound = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSound"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewSound, AudioComponent_eventSetSound_Parms), 0x0000000000000080, Z_Construct_UClass_USoundBase_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set what sound is played by this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetUISound()
	{
		struct AudioComponent_eventSetUISound_Parms
		{
			bool bInUISound;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetUISound"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetUISound_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInUISound, AudioComponent_eventSetUISound_Parms, bool);
			UProperty* NewProp_bInUISound = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInUISound"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInUISound, AudioComponent_eventSetUISound_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bInUISound, AudioComponent_eventSetUISound_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set whether sounds generated by this audio component should be considered UI sounds"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetVolumeMultiplier()
	{
		struct AudioComponent_eventSetVolumeMultiplier_Parms
		{
			float NewVolumeMultiplier;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetVolumeMultiplier"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetVolumeMultiplier_Parms));
			UProperty* NewProp_NewVolumeMultiplier = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVolumeMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewVolumeMultiplier, AudioComponent_eventSetVolumeMultiplier_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new volume multiplier"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_SetWaveParameter()
	{
		struct AudioComponent_eventSetWaveParameter_Parms
		{
			FName InName;
			USoundWave* InWave;
		};
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetWaveParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AudioComponent_eventSetWaveParameter_Parms));
			UProperty* NewProp_InWave = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWave"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(InWave, AudioComponent_eventSetWaveParameter_Parms), 0x0000000000000080, Z_Construct_UClass_USoundWave_NoRegister());
			UProperty* NewProp_InName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InName, AudioComponent_eventSetWaveParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a sound wave instance parameter for use in sound cues played by this audio component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAudioComponent_Stop()
	{
		UObject* Outer=Z_Construct_UClass_UAudioComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Stop"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Audio|Components|Audio"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stop an audio component playing its sound cue, issue any delegates if needed"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAudioComponent_NoRegister()
	{
		return UAudioComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAudioComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UAudioComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_AdjustAttenuation());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_AdjustVolume());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_BP_GetAttenuationSettingsToApply());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_FadeIn());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_FadeOut());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_IsPlaying());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_Play());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetBoolParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetFloatParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetIntParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetPitchMultiplier());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetSound());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetUISound());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetVolumeMultiplier());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_SetWaveParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UAudioComponent_Stop());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnQueueSubtitles = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnQueueSubtitles"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(OnQueueSubtitles, UAudioComponent), 0x0000000000080000, Z_Construct_UDelegateFunction_Engine_OnQueueSubtitles__DelegateSignature());
				UProperty* NewProp_OnAudioFinished = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnAudioFinished"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnAudioFinished, UAudioComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_OnAudioFinished__DelegateSignature());
				UProperty* NewProp_AttenuationOverrides = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AttenuationOverrides"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AttenuationOverrides, UAudioComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FAttenuationSettings());
				UProperty* NewProp_AttenuationSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AttenuationSettings"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AttenuationSettings, UAudioComponent), 0x0000000000000005, Z_Construct_UClass_USoundAttenuation_NoRegister());
				UProperty* NewProp_HighFrequencyGainMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HighFrequencyGainMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HighFrequencyGainMultiplier, UAudioComponent), 0x0000000000000005);
				UProperty* NewProp_PitchMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PitchMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PitchMultiplier, UAudioComponent), 0x0000000000000005);
				UProperty* NewProp_VolumeMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VolumeMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(VolumeMultiplier, UAudioComponent), 0x0000000000000005);
				UProperty* NewProp_VolumeModulationMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VolumeModulationMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(VolumeModulationMax, UAudioComponent), 0x0000000000000005);
				UProperty* NewProp_VolumeModulationMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VolumeModulationMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(VolumeModulationMin, UAudioComponent), 0x0000000000000005);
				UProperty* NewProp_PitchModulationMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PitchModulationMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PitchModulationMax, UAudioComponent), 0x0000000000000005);
				UProperty* NewProp_PitchModulationMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PitchModulationMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PitchModulationMin, UAudioComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsUISound, UAudioComponent, uint8);
				UProperty* NewProp_bIsUISound = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsUISound"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsUISound, UAudioComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsUISound, UAudioComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideAttenuation, UAudioComponent, uint8);
				UProperty* NewProp_bOverrideAttenuation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideAttenuation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideAttenuation, UAudioComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bOverrideAttenuation, UAudioComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowSpatialization, UAudioComponent, uint8);
				UProperty* NewProp_bAllowSpatialization = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowSpatialization"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowSpatialization, UAudioComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bAllowSpatialization, UAudioComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldRemainActiveIfDropped, UAudioComponent, uint8);
				UProperty* NewProp_bShouldRemainActiveIfDropped = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldRemainActiveIfDropped"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldRemainActiveIfDropped, UAudioComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bShouldRemainActiveIfDropped, UAudioComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStopWhenOwnerDestroyed, UAudioComponent, uint8);
				UProperty* NewProp_bStopWhenOwnerDestroyed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bStopWhenOwnerDestroyed"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStopWhenOwnerDestroyed, UAudioComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bStopWhenOwnerDestroyed, UAudioComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoDestroy, UAudioComponent, uint8);
				UProperty* NewProp_bAutoDestroy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutoDestroy"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoDestroy, UAudioComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bAutoDestroy, UAudioComponent), sizeof(uint8), false);
				UProperty* NewProp_SoundClassOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SoundClassOverride"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SoundClassOverride, UAudioComponent), 0x0000040000000001, Z_Construct_UClass_USoundClass_NoRegister());
				UProperty* NewProp_InstanceParameters = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstanceParameters"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InstanceParameters, UAudioComponent), 0x0000040000000005);
				UProperty* NewProp_InstanceParameters_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InstanceParameters, TEXT("InstanceParameters"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAudioComponentParam());
				UProperty* NewProp_Sound = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Sound"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Sound, UAudioComponent), 0x0000000000000005, Z_Construct_UClass_USoundBase_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_AdjustAttenuation()); // 377489288
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_AdjustVolume()); // 1626105342
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_BP_GetAttenuationSettingsToApply()); // 3305045549
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_FadeIn()); // 612578424
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_FadeOut()); // 2528190131
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_IsPlaying()); // 488174853
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_Play()); // 665185883
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetBoolParameter()); // 3194214597
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetFloatParameter()); // 3709591306
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetIntParameter()); // 3786615997
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetPitchMultiplier()); // 3564165896
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetSound()); // 1008455685
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetUISound()); // 1825566825
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetVolumeMultiplier()); // 4125805042
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_SetWaveParameter()); // 482088212
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAudioComponent_Stop()); // 95279821
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Audio Common"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object ActorComponent Physics Rendering Mobility LOD PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/AudioComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("AudioComponent is used to play a Sound\n\n@see https://docs.unrealengine.com/latest/INT/Audio/Overview/index.html\n@see USoundBase"));
				MetaData->SetValue(NewProp_OnQueueSubtitles, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_OnQueueSubtitles, TEXT("ToolTip"), TEXT("Called when subtitles are sent to the SubtitleManager.  Set this delegate if you want to hijack the subtitles for other purposes"));
				MetaData->SetValue(NewProp_OnAudioFinished, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_OnAudioFinished, TEXT("ToolTip"), TEXT("called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early"));
				MetaData->SetValue(NewProp_AttenuationOverrides, TEXT("Category"), TEXT("Attenuation"));
				MetaData->SetValue(NewProp_AttenuationOverrides, TEXT("EditCondition"), TEXT("bOverrideAttenuation"));
				MetaData->SetValue(NewProp_AttenuationOverrides, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_AttenuationOverrides, TEXT("ToolTip"), TEXT("If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component"));
				MetaData->SetValue(NewProp_AttenuationSettings, TEXT("Category"), TEXT("Attenuation"));
				MetaData->SetValue(NewProp_AttenuationSettings, TEXT("EditCondition"), TEXT("!bOverrideAttenuation"));
				MetaData->SetValue(NewProp_AttenuationSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_AttenuationSettings, TEXT("ToolTip"), TEXT("If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component"));
				MetaData->SetValue(NewProp_HighFrequencyGainMultiplier, TEXT("Category"), TEXT("Modulation"));
				MetaData->SetValue(NewProp_HighFrequencyGainMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_HighFrequencyGainMultiplier, TEXT("ToolTip"), TEXT("A multiplier to apply to the high frequency gain for sounds generated by this component"));
				MetaData->SetValue(NewProp_PitchMultiplier, TEXT("Category"), TEXT("Sound"));
				MetaData->SetValue(NewProp_PitchMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_PitchMultiplier, TEXT("ToolTip"), TEXT("A pitch multiplier to apply to sounds generated by this component"));
				MetaData->SetValue(NewProp_VolumeMultiplier, TEXT("Category"), TEXT("Sound"));
				MetaData->SetValue(NewProp_VolumeMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_VolumeMultiplier, TEXT("ToolTip"), TEXT("A volume multiplier to apply to sounds generated by this component"));
				MetaData->SetValue(NewProp_VolumeModulationMax, TEXT("Category"), TEXT("Modulation"));
				MetaData->SetValue(NewProp_VolumeModulationMax, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_VolumeModulationMax, TEXT("ToolTip"), TEXT("The upper bound to use when randomly determining a volume multiplier"));
				MetaData->SetValue(NewProp_VolumeModulationMin, TEXT("Category"), TEXT("Modulation"));
				MetaData->SetValue(NewProp_VolumeModulationMin, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_VolumeModulationMin, TEXT("ToolTip"), TEXT("The lower bound to use when randomly determining a volume multiplier"));
				MetaData->SetValue(NewProp_PitchModulationMax, TEXT("Category"), TEXT("Modulation"));
				MetaData->SetValue(NewProp_PitchModulationMax, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_PitchModulationMax, TEXT("ToolTip"), TEXT("The upper bound to use when randomly determining a pitch multiplier"));
				MetaData->SetValue(NewProp_PitchModulationMin, TEXT("Category"), TEXT("Modulation"));
				MetaData->SetValue(NewProp_PitchModulationMin, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_PitchModulationMin, TEXT("ToolTip"), TEXT("The lower bound to use when randomly determining a pitch multiplier"));
				MetaData->SetValue(NewProp_bIsUISound, TEXT("Category"), TEXT("Sound"));
				MetaData->SetValue(NewProp_bIsUISound, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_bIsUISound, TEXT("ToolTip"), TEXT("Whether or not this sound plays when the game is paused in the UI"));
				MetaData->SetValue(NewProp_bOverrideAttenuation, TEXT("Category"), TEXT("Attenuation"));
				MetaData->SetValue(NewProp_bOverrideAttenuation, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_bOverrideAttenuation, TEXT("ToolTip"), TEXT("Should the Attenuation Settings asset be used (false) or should the properties set directly on the component be used for attenuation properties"));
				MetaData->SetValue(NewProp_bAllowSpatialization, TEXT("Category"), TEXT("Attenuation"));
				MetaData->SetValue(NewProp_bAllowSpatialization, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_bAllowSpatialization, TEXT("ToolTip"), TEXT("Is this audio component allowed to be spatialized?"));
				MetaData->SetValue(NewProp_bShouldRemainActiveIfDropped, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_bShouldRemainActiveIfDropped, TEXT("ToolTip"), TEXT("Whether the wave instances should remain active if they're dropped by the prioritization code. Useful for e.g. vehicle sounds that shouldn't cut out."));
				MetaData->SetValue(NewProp_bStopWhenOwnerDestroyed, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_bStopWhenOwnerDestroyed, TEXT("ToolTip"), TEXT("Stop sound when owner is destroyed"));
				MetaData->SetValue(NewProp_bAutoDestroy, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_bAutoDestroy, TEXT("ToolTip"), TEXT("Auto destroy this component on completion"));
				MetaData->SetValue(NewProp_SoundClassOverride, TEXT("Category"), TEXT("Sound"));
				MetaData->SetValue(NewProp_SoundClassOverride, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_SoundClassOverride, TEXT("ToolTip"), TEXT("Optional sound group this AudioComponent belongs to"));
				MetaData->SetValue(NewProp_InstanceParameters, TEXT("Category"), TEXT("Sound"));
				MetaData->SetValue(NewProp_InstanceParameters, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_InstanceParameters, TEXT("ToolTip"), TEXT("Array of per-instance parameters for this AudioComponent."));
				MetaData->SetValue(NewProp_Sound, TEXT("Category"), TEXT("Sound"));
				MetaData->SetValue(NewProp_Sound, TEXT("ModuleRelativePath"), TEXT("Classes/Components/AudioComponent.h"));
				MetaData->SetValue(NewProp_Sound, TEXT("ToolTip"), TEXT("The sound to be played"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAudioComponent(Z_Construct_UClass_UAudioComponent, TEXT("UAudioComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAudioComponent);
	UFunction* Z_Construct_UFunction_UCameraComponent_AddOrUpdateBlendable()
	{
		struct CameraComponent_eventAddOrUpdateBlendable_Parms
		{
			TScriptInterface<IBlendableInterface> InBlendableObject;
			float InWeight;
		};
		UObject* Outer=Z_Construct_UClass_UCameraComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddOrUpdateBlendable"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CameraComponent_eventAddOrUpdateBlendable_Parms));
			UProperty* NewProp_InWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWeight, CameraComponent_eventAddOrUpdateBlendable_Parms), 0x0000000000000080);
			UProperty* NewProp_InBlendableObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBlendableObject"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(InBlendableObject, CameraComponent_eventAddOrUpdateBlendable_Parms), 0x0004000000000080, Z_Construct_UClass_UBlendableInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_InWeight"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCameraComponent_GetCameraView()
	{
		struct CameraComponent_eventGetCameraView_Parms
		{
			float DeltaTime;
			FMinimalViewInfo DesiredView;
		};
		UObject* Outer=Z_Construct_UClass_UCameraComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCameraView"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420400, 65535, sizeof(CameraComponent_eventGetCameraView_Parms));
			UProperty* NewProp_DesiredView = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DesiredView"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(DesiredView, CameraComponent_eventGetCameraView_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FMinimalViewInfo());
			UProperty* NewProp_DeltaTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DeltaTime, CameraComponent_eventGetCameraView_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Camera"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns camera's Point of View.\nCalled by Camera class. Subclass and postprocess to add any effects."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UCameraComponent_NoRegister()
	{
		return UCameraComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UCameraComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UCameraComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UCameraComponent_AddOrUpdateBlendable());
				OuterClass->LinkChild(Z_Construct_UFunction_UCameraComponent_GetCameraView());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerViewRotation_DEPRECATED, UCameraComponent, uint8);
				UProperty* NewProp_bUseControllerViewRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerViewRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerViewRotation_DEPRECATED, UCameraComponent), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bUseControllerViewRotation_DEPRECATED, UCameraComponent), sizeof(uint8), false);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_ProxyMeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProxyMeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ProxyMeshComponent, UCameraComponent), 0x0000080800082008, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
				UProperty* NewProp_CameraMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CameraMesh, UCameraComponent), 0x0000080800002000, Z_Construct_UClass_UStaticMesh_NoRegister());
				UProperty* NewProp_DrawFrustum = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawFrustum"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DrawFrustum, UCameraComponent), 0x0000080800082008, Z_Construct_UClass_UDrawFrustumComponent_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_PostProcessSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PostProcessSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PostProcessSettings, UCameraComponent), 0x0000000200000005, Z_Construct_UScriptStruct_FPostProcessSettings());
				UProperty* NewProp_PostProcessBlendWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PostProcessBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PostProcessBlendWeight, UCameraComponent), 0x0000000200000005);
				UProperty* NewProp_ProjectionMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProjectionMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ProjectionMode, UCameraComponent), 0x0000000200000005, Z_Construct_UEnum_Engine_ECameraProjectionMode());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUsePawnControlRotation, UCameraComponent, uint8);
				UProperty* NewProp_bUsePawnControlRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUsePawnControlRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUsePawnControlRotation, UCameraComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bUsePawnControlRotation, UCameraComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseFieldOfViewForLOD, UCameraComponent, uint8);
				UProperty* NewProp_bUseFieldOfViewForLOD = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseFieldOfViewForLOD"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseFieldOfViewForLOD, UCameraComponent), 0x0000040200000005, CPP_BOOL_PROPERTY_BITMASK(bUseFieldOfViewForLOD, UCameraComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConstrainAspectRatio, UCameraComponent, uint8);
				UProperty* NewProp_bConstrainAspectRatio = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bConstrainAspectRatio"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConstrainAspectRatio, UCameraComponent), 0x0000000200000005, CPP_BOOL_PROPERTY_BITMASK(bConstrainAspectRatio, UCameraComponent), sizeof(uint8), false);
				UProperty* NewProp_AspectRatio = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AspectRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AspectRatio, UCameraComponent), 0x0000000200000005);
				UProperty* NewProp_OrthoFarClipPlane = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OrthoFarClipPlane"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OrthoFarClipPlane, UCameraComponent), 0x0000000200000005);
				UProperty* NewProp_OrthoNearClipPlane = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OrthoNearClipPlane"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OrthoNearClipPlane, UCameraComponent), 0x0000000200000005);
				UProperty* NewProp_OrthoWidth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OrthoWidth"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OrthoWidth, UCameraComponent), 0x0000000200000005);
				UProperty* NewProp_FieldOfView = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FieldOfView"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FieldOfView, UCameraComponent), 0x0000000200000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCameraComponent_AddOrUpdateBlendable()); // 589719534
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCameraComponent_GetCameraView()); // 3287998501
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Camera"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Rendering LOD Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Camera/CameraComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Represents a camera viewpoint and settings, such as projection type, field of view, and post-process overrides.\nThe default behavior for an actor used as the camera view target is to look for an attached camera component and use its location, rotation, and settings."));
				MetaData->SetValue(NewProp_bUseControllerViewRotation, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_bUseControllerViewRotation, TEXT("ToolTip"), TEXT("DEPRECATED: use bUsePawnControlRotation instead"));
				MetaData->SetValue(NewProp_ProxyMeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ProxyMeshComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_ProxyMeshComponent, TEXT("ToolTip"), TEXT("The camera mesh to show visually where the camera is placed"));
				MetaData->SetValue(NewProp_CameraMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_DrawFrustum, TEXT("ToolTip"), TEXT("The frustum component used to show visually where the camera field of view is"));
				MetaData->SetValue(NewProp_PostProcessSettings, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_PostProcessSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_PostProcessSettings, TEXT("ToolTip"), TEXT("Post process settings to use for this camera. Don't forget to check the properties you want to override"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("ToolTip"), TEXT("Indicates if PostProcessSettings should be used when using this Camera to view through."));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_ProjectionMode, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_ProjectionMode, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_ProjectionMode, TEXT("ToolTip"), TEXT("The type of camera"));
				MetaData->SetValue(NewProp_bUsePawnControlRotation, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bUsePawnControlRotation, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_bUsePawnControlRotation, TEXT("ToolTip"), TEXT("If this camera component is placed on a pawn, should it use the view/control rotation of the pawn where possible?\n@see APawn::GetViewRotation()"));
				MetaData->SetValue(NewProp_bUseFieldOfViewForLOD, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bUseFieldOfViewForLOD, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_bUseFieldOfViewForLOD, TEXT("ToolTip"), TEXT("If true, account for the field of view angle when computing which level of detail to use for meshes."));
				MetaData->SetValue(NewProp_bConstrainAspectRatio, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bConstrainAspectRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_bConstrainAspectRatio, TEXT("ToolTip"), TEXT("If bConstrainAspectRatio is true, black bars will be added if the destination view has a different aspect ratio than this camera requested."));
				MetaData->SetValue(NewProp_AspectRatio, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_AspectRatio, TEXT("ClampMax"), TEXT("100.0"));
				MetaData->SetValue(NewProp_AspectRatio, TEXT("ClampMin"), TEXT("0.1"));
				MetaData->SetValue(NewProp_AspectRatio, TEXT("EditCondition"), TEXT("bConstrainAspectRatio"));
				MetaData->SetValue(NewProp_AspectRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_AspectRatio, TEXT("ToolTip"), TEXT("Aspect Ratio (Width/Height)"));
				MetaData->SetValue(NewProp_OrthoFarClipPlane, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_OrthoFarClipPlane, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_OrthoFarClipPlane, TEXT("ToolTip"), TEXT("The far plane distance of the orthographic view (in world units)"));
				MetaData->SetValue(NewProp_OrthoNearClipPlane, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_OrthoNearClipPlane, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_OrthoNearClipPlane, TEXT("ToolTip"), TEXT("The near plane distance of the orthographic view (in world units)"));
				MetaData->SetValue(NewProp_OrthoWidth, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_OrthoWidth, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_OrthoWidth, TEXT("ToolTip"), TEXT("The desired width (in world units) of the orthographic view (ignored in Perspective mode)"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("ClampMax"), TEXT("360.0"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("ClampMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("ModuleRelativePath"), TEXT("Classes/Camera/CameraComponent.h"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("ToolTip"), TEXT("The horizontal field of view (in degrees) in perspective mode (ignored in Orthographic mode)"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("UIMax"), TEXT("170"));
				MetaData->SetValue(NewProp_FieldOfView, TEXT("UIMin"), TEXT("5.0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UCameraComponent(Z_Construct_UClass_UCameraComponent, TEXT("UCameraComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UCameraComponent);
	UFunction* Z_Construct_UFunction_UChildActorComponent_SetChildActorClass()
	{
		struct ChildActorComponent_eventSetChildActorClass_Parms
		{
			TSubclassOf<AActor>  InClass;
		};
		UObject* Outer=Z_Construct_UClass_UChildActorComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetChildActorClass"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(ChildActorComponent_eventSetChildActorClass_Parms));
			UProperty* NewProp_InClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(InClass, ChildActorComponent_eventSetChildActorClass_Parms), 0x0004000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("ChildActorComponent"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ChildActorComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UChildActorComponent_NoRegister()
	{
		return UChildActorComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UChildActorComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UChildActorComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;

				OuterClass->LinkChild(Z_Construct_UFunction_UChildActorComponent_SetChildActorClass());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ChildActor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChildActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ChildActor, UChildActorComponent), 0x0000c00000000014, Z_Construct_UClass_AActor_NoRegister());
				UProperty* NewProp_ChildActorClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChildActorClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(ChildActorClass, UChildActorComponent), 0x0004000000000015, Z_Construct_UClass_AActor_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UChildActorComponent_SetChildActorClass()); // 785503690
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Physics Lighting TextureStreaming Activation Components|Activation Collision Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ChildActorComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ChildActorComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A component that spawns an Actor when registered, and destroys it when unregistered."));
				MetaData->SetValue(NewProp_ChildActor, TEXT("Category"), TEXT("ChildActorComponent"));
				MetaData->SetValue(NewProp_ChildActor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ChildActorComponent.h"));
				MetaData->SetValue(NewProp_ChildActor, TEXT("ToolTip"), TEXT("The actor that we spawned and own"));
				MetaData->SetValue(NewProp_ChildActorClass, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ChildActorClass, TEXT("Category"), TEXT("ChildActorComponent"));
				MetaData->SetValue(NewProp_ChildActorClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ChildActorComponent.h"));
				MetaData->SetValue(NewProp_ChildActorClass, TEXT("OnlyPlaceable"), TEXT(""));
				MetaData->SetValue(NewProp_ChildActorClass, TEXT("ToolTip"), TEXT("The class of Actor to spawn"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UChildActorComponent(Z_Construct_UClass_UChildActorComponent, TEXT("UChildActorComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UChildActorComponent);
	UFunction* Z_Construct_UFunction_UDecalComponent_CreateDynamicMaterialInstance()
	{
		struct DecalComponent_eventCreateDynamicMaterialInstance_Parms
		{
			UMaterialInstanceDynamic* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UDecalComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateDynamicMaterialInstance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(DecalComponent_eventCreateDynamicMaterialInstance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, DecalComponent_eventCreateDynamicMaterialInstance_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Decal"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Utility to allocate a new Dynamic Material Instance, set its parent to the currently applied material, and assign it"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDecalComponent_GetDecalMaterial()
	{
		struct DecalComponent_eventGetDecalMaterial_Parms
		{
			UMaterialInterface* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UDecalComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDecalMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(DecalComponent_eventGetDecalMaterial_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, DecalComponent_eventGetDecalMaterial_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Decal"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Accessor for decal material"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDecalComponent_SetDecalMaterial()
	{
		struct DecalComponent_eventSetDecalMaterial_Parms
		{
			UMaterialInterface* NewDecalMaterial;
		};
		UObject* Outer=Z_Construct_UClass_UDecalComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDecalMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DecalComponent_eventSetDecalMaterial_Parms));
			UProperty* NewProp_NewDecalMaterial = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDecalMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewDecalMaterial, DecalComponent_eventSetDecalMaterial_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Decal"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("setting decal material on decal component. This will force the decal to reattach"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDecalComponent_SetSortOrder()
	{
		struct DecalComponent_eventSetSortOrder_Parms
		{
			int32 Value;
		};
		UObject* Outer=Z_Construct_UClass_UDecalComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSortOrder"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DecalComponent_eventSetSortOrder_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Value, DecalComponent_eventSetSortOrder_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Decal"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the sort order for the decal component. Higher values draw later (on top). This will force the decal to reattach"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UDecalComponent_NoRegister()
	{
		return UDecalComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UDecalComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UDecalComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UDecalComponent_CreateDynamicMaterialInstance());
				OuterClass->LinkChild(Z_Construct_UFunction_UDecalComponent_GetDecalMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UDecalComponent_SetDecalMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UDecalComponent_SetSortOrder());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_FadeScreenSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FadeScreenSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FadeScreenSize, UDecalComponent), 0x0000000000000015);
				UProperty* NewProp_SortOrder = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SortOrder"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SortOrder, UDecalComponent), 0x0000000000000015);
				UProperty* NewProp_DecalMaterial = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DecalMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DecalMaterial, UDecalComponent), 0x0000000000000015, Z_Construct_UClass_UMaterialInterface_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDecalComponent_CreateDynamicMaterialInstance()); // 2057603642
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDecalComponent_GetDecalMaterial()); // 3017241899
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDecalComponent_SetDecalMaterial()); // 739563458
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDecalComponent_SetSortOrder()); // 2113024069
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent Activation Components|Activation Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/DecalComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A material that is rendered onto the surface of a mesh. A kind of 'bumper sticker' for a model.\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Actors/DecalActor\n@see UDecalActor"));
				MetaData->SetValue(NewProp_FadeScreenSize, TEXT("Category"), TEXT("Decal"));
				MetaData->SetValue(NewProp_FadeScreenSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
				MetaData->SetValue(NewProp_SortOrder, TEXT("Category"), TEXT("Decal"));
				MetaData->SetValue(NewProp_SortOrder, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
				MetaData->SetValue(NewProp_SortOrder, TEXT("ToolTip"), TEXT("Controls the order in which decal elements are rendered.  Higher values draw later (on top).\nSetting many different sort orders on many different decals prevents sorting by state and can reduce performance."));
				MetaData->SetValue(NewProp_DecalMaterial, TEXT("Category"), TEXT("Decal"));
				MetaData->SetValue(NewProp_DecalMaterial, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DecalComponent.h"));
				MetaData->SetValue(NewProp_DecalMaterial, TEXT("ToolTip"), TEXT("Decal material."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UDecalComponent(Z_Construct_UClass_UDecalComponent, TEXT("UDecalComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UDecalComponent);
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringColor()
	{
		struct ExponentialHeightFogComponent_eventSetDirectionalInscatteringColor_Parms
		{
			FLinearColor Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDirectionalInscatteringColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(ExponentialHeightFogComponent_eventSetDirectionalInscatteringColor_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetDirectionalInscatteringColor_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringExponent()
	{
		struct ExponentialHeightFogComponent_eventSetDirectionalInscatteringExponent_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDirectionalInscatteringExponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ExponentialHeightFogComponent_eventSetDirectionalInscatteringExponent_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetDirectionalInscatteringExponent_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance()
	{
		struct ExponentialHeightFogComponent_eventSetDirectionalInscatteringStartDistance_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDirectionalInscatteringStartDistance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ExponentialHeightFogComponent_eventSetDirectionalInscatteringStartDistance_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetDirectionalInscatteringStartDistance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogDensity()
	{
		struct ExponentialHeightFogComponent_eventSetFogDensity_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFogDensity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ExponentialHeightFogComponent_eventSetFogDensity_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetFogDensity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogHeightFalloff()
	{
		struct ExponentialHeightFogComponent_eventSetFogHeightFalloff_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFogHeightFalloff"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ExponentialHeightFogComponent_eventSetFogHeightFalloff_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetFogHeightFalloff_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogInscatteringColor()
	{
		struct ExponentialHeightFogComponent_eventSetFogInscatteringColor_Parms
		{
			FLinearColor Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFogInscatteringColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(ExponentialHeightFogComponent_eventSetFogInscatteringColor_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetFogInscatteringColor_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogMaxOpacity()
	{
		struct ExponentialHeightFogComponent_eventSetFogMaxOpacity_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFogMaxOpacity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ExponentialHeightFogComponent_eventSetFogMaxOpacity_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetFogMaxOpacity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UExponentialHeightFogComponent_SetStartDistance()
	{
		struct ExponentialHeightFogComponent_eventSetStartDistance_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UExponentialHeightFogComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartDistance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ExponentialHeightFogComponent_eventSetStartDistance_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, ExponentialHeightFogComponent_eventSetStartDistance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|ExponentialHeightFog"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UExponentialHeightFogComponent_NoRegister()
	{
		return UExponentialHeightFogComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UExponentialHeightFogComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UExponentialHeightFogComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B03080;

				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringColor());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringExponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogDensity());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogHeightFalloff());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogInscatteringColor());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogMaxOpacity());
				OuterClass->LinkChild(Z_Construct_UFunction_UExponentialHeightFogComponent_SetStartDistance());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_StartDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StartDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartDistance, UExponentialHeightFogComponent), 0x0000000200000015);
				UProperty* NewProp_FogMaxOpacity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FogMaxOpacity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FogMaxOpacity, UExponentialHeightFogComponent), 0x0000000200000015);
				UProperty* NewProp_FogHeightFalloff = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FogHeightFalloff"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FogHeightFalloff, UExponentialHeightFogComponent), 0x0000000200000015);
				UProperty* NewProp_DirectionalInscatteringColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DirectionalInscatteringColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(DirectionalInscatteringColor, UExponentialHeightFogComponent), 0x0000000200000015, Z_Construct_UScriptStruct_FLinearColor());
				UProperty* NewProp_DirectionalInscatteringStartDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DirectionalInscatteringStartDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DirectionalInscatteringStartDistance, UExponentialHeightFogComponent), 0x0000000200000015);
				UProperty* NewProp_DirectionalInscatteringExponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DirectionalInscatteringExponent"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DirectionalInscatteringExponent, UExponentialHeightFogComponent), 0x0000000200000015);
				UProperty* NewProp_FogInscatteringColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FogInscatteringColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FogInscatteringColor, UExponentialHeightFogComponent), 0x0000000200000015, Z_Construct_UScriptStruct_FLinearColor());
				UProperty* NewProp_FogDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FogDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FogDensity, UExponentialHeightFogComponent), 0x0000000200000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringColor()); // 4275253125
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringExponent()); // 640439819
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance()); // 3343213421
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogDensity()); // 1546179463
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogHeightFalloff()); // 1116737473
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogInscatteringColor()); // 763703466
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetFogMaxOpacity()); // 3004413
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UExponentialHeightFogComponent_SetStartDistance()); // 3073393695
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Used to create fogging effects such as clouds but with a density that is related to the height of the fog."));
				MetaData->SetValue(NewProp_StartDistance, TEXT("Category"), TEXT("ExponentialHeightFogComponent"));
				MetaData->SetValue(NewProp_StartDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_StartDistance, TEXT("ToolTip"), TEXT("Distance from the camera that the fog will start, in world units."));
				MetaData->SetValue(NewProp_StartDistance, TEXT("UIMax"), TEXT("5000"));
				MetaData->SetValue(NewProp_StartDistance, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_FogMaxOpacity, TEXT("Category"), TEXT("ExponentialHeightFogComponent"));
				MetaData->SetValue(NewProp_FogMaxOpacity, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_FogMaxOpacity, TEXT("ToolTip"), TEXT("Maximum opacity of the fog.\nA value of 1 means the fog can become fully opaque at a distance and replace scene color completely,\nA value of 0 means the fog color will not be factored in at all."));
				MetaData->SetValue(NewProp_FogMaxOpacity, TEXT("UIMax"), TEXT("1"));
				MetaData->SetValue(NewProp_FogMaxOpacity, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_FogHeightFalloff, TEXT("Category"), TEXT("ExponentialHeightFogComponent"));
				MetaData->SetValue(NewProp_FogHeightFalloff, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_FogHeightFalloff, TEXT("ToolTip"), TEXT("Height density factor, controls how the density increases as height decreases.\nSmaller values make the visible transition larger."));
				MetaData->SetValue(NewProp_FogHeightFalloff, TEXT("UIMax"), TEXT("2"));
				MetaData->SetValue(NewProp_FogHeightFalloff, TEXT("UIMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_DirectionalInscatteringColor, TEXT("Category"), TEXT("DirectionalInscattering"));
				MetaData->SetValue(NewProp_DirectionalInscatteringColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_DirectionalInscatteringColor, TEXT("ToolTip"), TEXT("Controls the color of the directional inscattering, which is used to approximate inscattering from a directional light.\nNote: there must be a directional light with bUsedAsAtmosphereSunLight enabled for DirectionalInscattering to be used."));
				MetaData->SetValue(NewProp_DirectionalInscatteringStartDistance, TEXT("Category"), TEXT("DirectionalInscattering"));
				MetaData->SetValue(NewProp_DirectionalInscatteringStartDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_DirectionalInscatteringStartDistance, TEXT("ToolTip"), TEXT("Controls the start distance from the viewer of the directional inscattering, which is used to approximate inscattering from a directional light.\nNote: there must be a directional light with bUsedAsAtmosphereSunLight enabled for DirectionalInscattering to be used."));
				MetaData->SetValue(NewProp_DirectionalInscatteringExponent, TEXT("Category"), TEXT("DirectionalInscattering"));
				MetaData->SetValue(NewProp_DirectionalInscatteringExponent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_DirectionalInscatteringExponent, TEXT("ToolTip"), TEXT("Controls the size of the directional inscattering cone, which is used to approximate inscattering from a directional light.\nNote: there must be a directional light with bUsedAsAtmosphereSunLight enabled for DirectionalInscattering to be used."));
				MetaData->SetValue(NewProp_DirectionalInscatteringExponent, TEXT("UIMax"), TEXT("64"));
				MetaData->SetValue(NewProp_DirectionalInscatteringExponent, TEXT("UIMin"), TEXT("2"));
				MetaData->SetValue(NewProp_FogInscatteringColor, TEXT("Category"), TEXT("ExponentialHeightFogComponent"));
				MetaData->SetValue(NewProp_FogInscatteringColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_FogDensity, TEXT("Category"), TEXT("ExponentialHeightFogComponent"));
				MetaData->SetValue(NewProp_FogDensity, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ExponentialHeightFogComponent.h"));
				MetaData->SetValue(NewProp_FogDensity, TEXT("ToolTip"), TEXT("Global density factor."));
				MetaData->SetValue(NewProp_FogDensity, TEXT("UIMax"), TEXT(".05"));
				MetaData->SetValue(NewProp_FogDensity, TEXT("UIMin"), TEXT("0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UExponentialHeightFogComponent(Z_Construct_UClass_UExponentialHeightFogComponent, TEXT("UExponentialHeightFogComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UExponentialHeightFogComponent);
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeDistributionExponent()
	{
		struct DirectionalLightComponent_eventSetCascadeDistributionExponent_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCascadeDistributionExponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetCascadeDistributionExponent_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetCascadeDistributionExponent_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeTransitionFraction()
	{
		struct DirectionalLightComponent_eventSetCascadeTransitionFraction_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCascadeTransitionFraction"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetCascadeTransitionFraction_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetCascadeTransitionFraction_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowCascades()
	{
		struct DirectionalLightComponent_eventSetDynamicShadowCascades_Parms
		{
			int32 NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDynamicShadowCascades"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetDynamicShadowCascades_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetDynamicShadowCascades_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight()
	{
		struct DirectionalLightComponent_eventSetDynamicShadowDistanceMovableLight_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDynamicShadowDistanceMovableLight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetDynamicShadowDistanceMovableLight_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetDynamicShadowDistanceMovableLight_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight()
	{
		struct DirectionalLightComponent_eventSetDynamicShadowDistanceStationaryLight_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDynamicShadowDistanceStationaryLight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetDynamicShadowDistanceStationaryLight_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetDynamicShadowDistanceStationaryLight_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetEnableLightShaftOcclusion()
	{
		struct DirectionalLightComponent_eventSetEnableLightShaftOcclusion_Parms
		{
			bool bNewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnableLightShaftOcclusion"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetEnableLightShaftOcclusion_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewValue, DirectionalLightComponent_eventSetEnableLightShaftOcclusion_Parms, bool);
			UProperty* NewProp_bNewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewValue, DirectionalLightComponent_eventSetEnableLightShaftOcclusion_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewValue, DirectionalLightComponent_eventSetEnableLightShaftOcclusion_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetLightShaftOverrideDirection()
	{
		struct DirectionalLightComponent_eventSetLightShaftOverrideDirection_Parms
		{
			FVector NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLightShaftOverrideDirection"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(DirectionalLightComponent_eventSetLightShaftOverrideDirection_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetLightShaftOverrideDirection_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetOcclusionMaskDarkness()
	{
		struct DirectionalLightComponent_eventSetOcclusionMaskDarkness_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetOcclusionMaskDarkness"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetOcclusionMaskDarkness_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetOcclusionMaskDarkness_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDirectionalLightComponent_SetShadowDistanceFadeoutFraction()
	{
		struct DirectionalLightComponent_eventSetShadowDistanceFadeoutFraction_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UDirectionalLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetShadowDistanceFadeoutFraction"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DirectionalLightComponent_eventSetShadowDistanceFadeoutFraction_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, DirectionalLightComponent_eventSetShadowDistanceFadeoutFraction_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UDirectionalLightComponent_NoRegister()
	{
		return UDirectionalLightComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UDirectionalLightComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULightComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UDirectionalLightComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A81080;

				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeDistributionExponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeTransitionFraction());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowCascades());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetEnableLightShaftOcclusion());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetLightShaftOverrideDirection());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetOcclusionMaskDarkness());
				OuterClass->LinkChild(Z_Construct_UFunction_UDirectionalLightComponent_SetShadowDistanceFadeoutFraction());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUsedAsAtmosphereSunLight, UDirectionalLightComponent, uint8);
				UProperty* NewProp_bUsedAsAtmosphereSunLight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUsedAsAtmosphereSunLight"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUsedAsAtmosphereSunLight, UDirectionalLightComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bUsedAsAtmosphereSunLight, UDirectionalLightComponent), sizeof(uint8), false);
				UProperty* NewProp_ModulatedShadowColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ModulatedShadowColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ModulatedShadowColor, UDirectionalLightComponent), 0x0000040200000015, Z_Construct_UScriptStruct_FColor());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastModulatedShadows, UDirectionalLightComponent, uint8);
				UProperty* NewProp_bCastModulatedShadows = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastModulatedShadows"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastModulatedShadows, UDirectionalLightComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastModulatedShadows, UDirectionalLightComponent), sizeof(uint8), false);
				UProperty* NewProp_LightmassSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightmassSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightmassSettings, UDirectionalLightComponent), 0x0000000000000015, Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings());
				UProperty* NewProp_TraceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TraceDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TraceDistance, UDirectionalLightComponent), 0x0000040000000015);
				UProperty* NewProp_LightSourceAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightSourceAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LightSourceAngle, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_DistanceFieldShadowDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistanceFieldShadowDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DistanceFieldShadowDistance, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_FarShadowDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FarShadowDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FarShadowDistance, UDirectionalLightComponent), 0x0000040000000015);
				UProperty* NewProp_FarShadowCascadeCount = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FarShadowCascadeCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(FarShadowCascadeCount, UDirectionalLightComponent), 0x0000040000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseInsetShadowsForMovableObjects, UDirectionalLightComponent, uint8);
				UProperty* NewProp_bUseInsetShadowsForMovableObjects = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseInsetShadowsForMovableObjects"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseInsetShadowsForMovableObjects, UDirectionalLightComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bUseInsetShadowsForMovableObjects, UDirectionalLightComponent), sizeof(uint8), false);
				UProperty* NewProp_ShadowDistanceFadeoutFraction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShadowDistanceFadeoutFraction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ShadowDistanceFadeoutFraction, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_CascadeTransitionFraction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CascadeTransitionFraction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CascadeTransitionFraction, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_CascadeDistributionExponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CascadeDistributionExponent"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CascadeDistributionExponent, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_DynamicShadowCascades = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DynamicShadowCascades"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(DynamicShadowCascades, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_DynamicShadowDistanceStationaryLight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DynamicShadowDistanceStationaryLight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DynamicShadowDistanceStationaryLight, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_DynamicShadowDistanceMovableLight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DynamicShadowDistanceMovableLight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DynamicShadowDistanceMovableLight, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_WholeSceneDynamicShadowRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WholeSceneDynamicShadowRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WholeSceneDynamicShadowRadius_DEPRECATED, UDirectionalLightComponent), 0x0000000020000000);
				UProperty* NewProp_LightShaftOverrideDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightShaftOverrideDirection"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightShaftOverrideDirection, UDirectionalLightComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_OcclusionDepthRange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OcclusionDepthRange"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OcclusionDepthRange, UDirectionalLightComponent), 0x0000000000000015);
				UProperty* NewProp_OcclusionMaskDarkness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OcclusionMaskDarkness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OcclusionMaskDarkness, UDirectionalLightComponent), 0x0000000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableLightShaftOcclusion, UDirectionalLightComponent, uint8);
				UProperty* NewProp_bEnableLightShaftOcclusion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableLightShaftOcclusion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableLightShaftOcclusion, UDirectionalLightComponent), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bEnableLightShaftOcclusion, UDirectionalLightComponent), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeDistributionExponent()); // 4067424946
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetCascadeTransitionFraction()); // 493141891
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowCascades()); // 1415711734
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight()); // 1703445021
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight()); // 2780592294
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetEnableLightShaftOcclusion()); // 352176161
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetLightShaftOverrideDirection()); // 2798821787
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetOcclusionMaskDarkness()); // 1605693499
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDirectionalLightComponent_SetShadowDistanceFadeoutFraction()); // 1861511187
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Lights"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LightProfiles Trigger Activation Components|Activation Physics Trigger Activation Components|Activation Physics Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/DirectionalLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A light component that has parallel rays. Will provide a uniform lighting across any affected surface (eg. The Sun). This will affect all objects in the defined light-mass importance volume."));
				MetaData->SetValue(NewProp_bUsedAsAtmosphereSunLight, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_bUsedAsAtmosphereSunLight, TEXT("DisplayName"), TEXT("Atmosphere Sun Light"));
				MetaData->SetValue(NewProp_bUsedAsAtmosphereSunLight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_ModulatedShadowColor, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_ModulatedShadowColor, TEXT("HideAlphaChannel"), TEXT(""));
				MetaData->SetValue(NewProp_ModulatedShadowColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_ModulatedShadowColor, TEXT("ToolTip"), TEXT("Color to modulate against the scene color when rendering modulated shadows. (mobile only)"));
				MetaData->SetValue(NewProp_bCastModulatedShadows, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_bCastModulatedShadows, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_bCastModulatedShadows, TEXT("ToolTip"), TEXT("Whether the light should cast modulated shadows from dynamic objects (mobile only).  Also requires Cast Shadows to be set to True."));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ToolTip"), TEXT("The Lightmass settings for this object."));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("Category"), TEXT("DistanceFieldShadows"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("DisplayName"), TEXT("DistanceField Trace Distance"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("ToolTip"), TEXT("Determines how far shadows can be cast, in world units.  Larger values increase the shadowing cost."));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("UIMax"), TEXT("100000"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("UIMin"), TEXT("1000"));
				MetaData->SetValue(NewProp_LightSourceAngle, TEXT("Category"), TEXT("DistanceFieldShadows"));
				MetaData->SetValue(NewProp_LightSourceAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_LightSourceAngle, TEXT("ToolTip"), TEXT("Light source angle in degrees."));
				MetaData->SetValue(NewProp_LightSourceAngle, TEXT("UIMax"), TEXT("5"));
				MetaData->SetValue(NewProp_LightSourceAngle, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_DistanceFieldShadowDistance, TEXT("Category"), TEXT("DistanceFieldShadows"));
				MetaData->SetValue(NewProp_DistanceFieldShadowDistance, TEXT("DisplayName"), TEXT("DistanceField Shadow Distance"));
				MetaData->SetValue(NewProp_DistanceFieldShadowDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_DistanceFieldShadowDistance, TEXT("ToolTip"), TEXT("Distance at which the ray traced shadow cascade should end.  Distance field shadows will cover the range between 'Dynamic Shadow Distance' this distance."));
				MetaData->SetValue(NewProp_DistanceFieldShadowDistance, TEXT("UIMax"), TEXT("100000"));
				MetaData->SetValue(NewProp_DistanceFieldShadowDistance, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_FarShadowDistance, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_FarShadowDistance, TEXT("DisplayName"), TEXT("Far Shadow Distance"));
				MetaData->SetValue(NewProp_FarShadowDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_FarShadowDistance, TEXT("ToolTip"), TEXT("Distance at which the far shadow cascade should end.  Far shadows will cover the range between 'Dynamic Shadow Distance' and this distance."));
				MetaData->SetValue(NewProp_FarShadowDistance, TEXT("UIMax"), TEXT("800000"));
				MetaData->SetValue(NewProp_FarShadowDistance, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_FarShadowCascadeCount, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_FarShadowCascadeCount, TEXT("DisplayName"), TEXT("Far Shadow Cascade Count"));
				MetaData->SetValue(NewProp_FarShadowCascadeCount, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_FarShadowCascadeCount, TEXT("ToolTip"), TEXT("0: no DistantShadowCascades, otherwise the count of cascades between WholeSceneDynamicShadowRadius and DistantShadowDistance that are covered by distant shadow cascades."));
				MetaData->SetValue(NewProp_FarShadowCascadeCount, TEXT("UIMax"), TEXT("4"));
				MetaData->SetValue(NewProp_FarShadowCascadeCount, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_bUseInsetShadowsForMovableObjects, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_bUseInsetShadowsForMovableObjects, TEXT("DisplayName"), TEXT("Inset Shadows For Movable Objects"));
				MetaData->SetValue(NewProp_bUseInsetShadowsForMovableObjects, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_bUseInsetShadowsForMovableObjects, TEXT("ToolTip"), TEXT("Stationary lights only: Whether to use per-object inset shadows for movable components, even though cascaded shadow maps are enabled.\nThis allows dynamic objects to have a shadow even when they are outside of the cascaded shadow map, which is important when DynamicShadowDistanceStationaryLight is small.\nIf DynamicShadowDistanceStationaryLight is large (currently > 8000), this will be forced off.\nDisabling this can reduce shadowing cost significantly with many movable objects."));
				MetaData->SetValue(NewProp_ShadowDistanceFadeoutFraction, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_ShadowDistanceFadeoutFraction, TEXT("DisplayName"), TEXT("Distance Fadeout Fraction"));
				MetaData->SetValue(NewProp_ShadowDistanceFadeoutFraction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_ShadowDistanceFadeoutFraction, TEXT("ToolTip"), TEXT("Controls the size of the fade out region at the far extent of the dynamic shadow's influence.\nThis is specified as a fraction of DynamicShadowDistance."));
				MetaData->SetValue(NewProp_ShadowDistanceFadeoutFraction, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_ShadowDistanceFadeoutFraction, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CascadeTransitionFraction, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_CascadeTransitionFraction, TEXT("DisplayName"), TEXT("Transition Fraction"));
				MetaData->SetValue(NewProp_CascadeTransitionFraction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_CascadeTransitionFraction, TEXT("ToolTip"), TEXT("Proportion of the fade region between cascades.\nPixels within the fade region of two cascades have their shadows blended to avoid hard transitions between quality levels.\nA value of zero eliminates the fade region, creating hard transitions.\nHigher values increase the size of the fade region, creating a more gradual transition between cascades.\nThe value is expressed as a percentage proportion (i.e. 0.1 = 10% overlap).\nIdeal values are the smallest possible which still hide the transition.\nAn increased fade region size causes an increase in shadow rendering cost."));
				MetaData->SetValue(NewProp_CascadeTransitionFraction, TEXT("UIMax"), TEXT("0.3"));
				MetaData->SetValue(NewProp_CascadeTransitionFraction, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CascadeDistributionExponent, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_CascadeDistributionExponent, TEXT("DisplayName"), TEXT("Distribution Exponent"));
				MetaData->SetValue(NewProp_CascadeDistributionExponent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_CascadeDistributionExponent, TEXT("ToolTip"), TEXT("Controls whether the cascades are distributed closer to the camera (larger exponent) or further from the camera (smaller exponent).\nAn exponent of 1 means that cascade transitions will happen at a distance proportional to their resolution."));
				MetaData->SetValue(NewProp_CascadeDistributionExponent, TEXT("UIMax"), TEXT("4"));
				MetaData->SetValue(NewProp_CascadeDistributionExponent, TEXT("UIMin"), TEXT("1"));
				MetaData->SetValue(NewProp_DynamicShadowCascades, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_DynamicShadowCascades, TEXT("DisplayName"), TEXT("Num Dynamic Shadow Cascades"));
				MetaData->SetValue(NewProp_DynamicShadowCascades, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_DynamicShadowCascades, TEXT("ToolTip"), TEXT("Number of cascades to split the view frustum into for the whole scene dynamic shadow.\nMore cascades result in better shadow resolution, but adds significant rendering cost."));
				MetaData->SetValue(NewProp_DynamicShadowCascades, TEXT("UIMax"), TEXT("4"));
				MetaData->SetValue(NewProp_DynamicShadowCascades, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceStationaryLight, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceStationaryLight, TEXT("DisplayName"), TEXT("Dynamic Shadow Distance StationaryLight"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceStationaryLight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceStationaryLight, TEXT("ToolTip"), TEXT("How far Cascaded Shadow Map dynamic shadows will cover for a stationary light, measured from the camera.\nA value of 0 disables the dynamic shadow."));
				MetaData->SetValue(NewProp_DynamicShadowDistanceStationaryLight, TEXT("UIMax"), TEXT("20000"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceStationaryLight, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceMovableLight, TEXT("Category"), TEXT("CascadedShadowMaps"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceMovableLight, TEXT("DisplayName"), TEXT("Dynamic Shadow Distance MovableLight"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceMovableLight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceMovableLight, TEXT("ToolTip"), TEXT("How far Cascaded Shadow Map dynamic shadows will cover for a movable light, measured from the camera.\nA value of 0 disables the dynamic shadow."));
				MetaData->SetValue(NewProp_DynamicShadowDistanceMovableLight, TEXT("UIMax"), TEXT("20000"));
				MetaData->SetValue(NewProp_DynamicShadowDistanceMovableLight, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_WholeSceneDynamicShadowRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_LightShaftOverrideDirection, TEXT("Category"), TEXT("LightShafts"));
				MetaData->SetValue(NewProp_LightShaftOverrideDirection, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_LightShaftOverrideDirection, TEXT("ToolTip"), TEXT("Can be used to make light shafts come from somewhere other than the light's actual direction.\nThis will only be used when non-zero.  It does not have to be normalized."));
				MetaData->SetValue(NewProp_OcclusionDepthRange, TEXT("Category"), TEXT("LightShafts"));
				MetaData->SetValue(NewProp_OcclusionDepthRange, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_OcclusionDepthRange, TEXT("ToolTip"), TEXT("Everything closer to the camera than this distance will occlude light shafts."));
				MetaData->SetValue(NewProp_OcclusionDepthRange, TEXT("UIMax"), TEXT("500000"));
				MetaData->SetValue(NewProp_OcclusionDepthRange, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_OcclusionMaskDarkness, TEXT("Category"), TEXT("LightShafts"));
				MetaData->SetValue(NewProp_OcclusionMaskDarkness, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_OcclusionMaskDarkness, TEXT("ToolTip"), TEXT("Controls how dark the occlusion masking is, a value of 1 results in no darkening term."));
				MetaData->SetValue(NewProp_OcclusionMaskDarkness, TEXT("UIMax"), TEXT("1"));
				MetaData->SetValue(NewProp_OcclusionMaskDarkness, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_bEnableLightShaftOcclusion, TEXT("Category"), TEXT("LightShafts"));
				MetaData->SetValue(NewProp_bEnableLightShaftOcclusion, TEXT("DisplayName"), TEXT("Light Shaft Occlusion"));
				MetaData->SetValue(NewProp_bEnableLightShaftOcclusion, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DirectionalLightComponent.h"));
				MetaData->SetValue(NewProp_bEnableLightShaftOcclusion, TEXT("ToolTip"), TEXT("Whether to occlude fog and atmosphere inscattering with screenspace blurred occlusion from this light."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UDirectionalLightComponent(Z_Construct_UClass_UDirectionalLightComponent, TEXT("UDirectionalLightComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UDirectionalLightComponent);
	UFunction* Z_Construct_UFunction_UPointLightComponent_SetAttenuationRadius()
	{
		struct PointLightComponent_eventSetAttenuationRadius_Parms
		{
			float NewRadius;
		};
		UObject* Outer=Z_Construct_UClass_UPointLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAttenuationRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PointLightComponent_eventSetAttenuationRadius_Parms));
			UProperty* NewProp_NewRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewRadius, PointLightComponent_eventSetAttenuationRadius_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPointLightComponent_SetLightFalloffExponent()
	{
		struct PointLightComponent_eventSetLightFalloffExponent_Parms
		{
			float NewLightFalloffExponent;
		};
		UObject* Outer=Z_Construct_UClass_UPointLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLightFalloffExponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PointLightComponent_eventSetLightFalloffExponent_Parms));
			UProperty* NewProp_NewLightFalloffExponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLightFalloffExponent"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewLightFalloffExponent, PointLightComponent_eventSetLightFalloffExponent_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPointLightComponent_SetSourceLength()
	{
		struct PointLightComponent_eventSetSourceLength_Parms
		{
			float NewValue;
		};
		UObject* Outer=Z_Construct_UClass_UPointLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSourceLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PointLightComponent_eventSetSourceLength_Parms));
			UProperty* NewProp_NewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewValue, PointLightComponent_eventSetSourceLength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPointLightComponent_SetSourceRadius()
	{
		struct PointLightComponent_eventSetSourceRadius_Parms
		{
			float bNewValue;
		};
		UObject* Outer=Z_Construct_UClass_UPointLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSourceRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PointLightComponent_eventSetSourceRadius_Parms));
			UProperty* NewProp_bNewValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(bNewValue, PointLightComponent_eventSetSourceRadius_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPointLightComponent_NoRegister()
	{
		return UPointLightComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPointLightComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULightComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPointLightComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPointLightComponent_SetAttenuationRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UPointLightComponent_SetLightFalloffExponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UPointLightComponent_SetSourceLength());
				OuterClass->LinkChild(Z_Construct_UFunction_UPointLightComponent_SetSourceRadius());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LightmassSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightmassSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightmassSettings, UPointLightComponent), 0x0000000000000015, Z_Construct_UScriptStruct_FLightmassPointLightSettings());
				UProperty* NewProp_SourceLength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SourceLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SourceLength, UPointLightComponent), 0x0000000000000015);
				UProperty* NewProp_SourceRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SourceRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SourceRadius, UPointLightComponent), 0x0000000000000015);
				UProperty* NewProp_LightFalloffExponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightFalloffExponent"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LightFalloffExponent, UPointLightComponent), 0x0000040200000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseInverseSquaredFalloff, UPointLightComponent, uint8);
				UProperty* NewProp_bUseInverseSquaredFalloff = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseInverseSquaredFalloff"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseInverseSquaredFalloff, UPointLightComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bUseInverseSquaredFalloff, UPointLightComponent), sizeof(uint8), false);
				UProperty* NewProp_AttenuationRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AttenuationRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AttenuationRadius, UPointLightComponent), 0x0000000200000015);
				UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius_DEPRECATED, UPointLightComponent), 0x0000000020000000);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPointLightComponent_SetAttenuationRadius()); // 1253977595
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPointLightComponent_SetLightFalloffExponent()); // 2929909467
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPointLightComponent_SetSourceLength()); // 1861192007
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPointLightComponent_SetSourceRadius()); // 807978113
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Lights Common"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LightShafts Trigger Activation Components|Activation Physics Trigger Activation Components|Activation Physics Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PointLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A light component which emits light from a single point equally in all directions."));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ToolTip"), TEXT("The Lightmass settings for this object."));
				MetaData->SetValue(NewProp_SourceLength, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_SourceLength, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(NewProp_SourceLength, TEXT("ToolTip"), TEXT("Length of light source shape.\nNote that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."));
				MetaData->SetValue(NewProp_SourceRadius, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_SourceRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(NewProp_SourceRadius, TEXT("ToolTip"), TEXT("Radius of light source shape.\nNote that light sources shapes which intersect shadow casting geometry can cause shadowing artifacts."));
				MetaData->SetValue(NewProp_LightFalloffExponent, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_LightFalloffExponent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(NewProp_LightFalloffExponent, TEXT("ToolTip"), TEXT("Controls the radial falloff of the light when UseInverseSquaredFalloff is disabled.\n2 is almost linear and very unrealistic and around 8 it looks reasonable.\nWith large exponents, the light has contribution to only a small area of its influence radius but still costs the same as low exponents."));
				MetaData->SetValue(NewProp_LightFalloffExponent, TEXT("UIMax"), TEXT("16.0"));
				MetaData->SetValue(NewProp_LightFalloffExponent, TEXT("UIMin"), TEXT("2.0"));
				MetaData->SetValue(NewProp_bUseInverseSquaredFalloff, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_bUseInverseSquaredFalloff, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(NewProp_bUseInverseSquaredFalloff, TEXT("ToolTip"), TEXT("Whether to use physically based inverse squared distance falloff, where AttenuationRadius is only clamping the light's contribution.\nDisabling inverse squared falloff can be useful when placing fill lights (don't want a super bright spot near the light).\nWhen enabled, the light's Intensity is in units of lumens, where 1700 lumens is a 100W lightbulb.\nWhen disabled, the light's Intensity is a brightness scale."));
				MetaData->SetValue(NewProp_AttenuationRadius, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_AttenuationRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
				MetaData->SetValue(NewProp_AttenuationRadius, TEXT("SliderExponent"), TEXT("5.0"));
				MetaData->SetValue(NewProp_AttenuationRadius, TEXT("ToolTip"), TEXT("Bounds the light's visible influence.\nThis clamping of the light's influence is not physically correct but very important for performance, larger lights cost more."));
				MetaData->SetValue(NewProp_AttenuationRadius, TEXT("UIMax"), TEXT("16384.0"));
				MetaData->SetValue(NewProp_AttenuationRadius, TEXT("UIMin"), TEXT("8.0"));
				MetaData->SetValue(NewProp_Radius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PointLightComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPointLightComponent(Z_Construct_UClass_UPointLightComponent, TEXT("UPointLightComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPointLightComponent);
	UFunction* Z_Construct_UFunction_USpotLightComponent_SetInnerConeAngle()
	{
		struct SpotLightComponent_eventSetInnerConeAngle_Parms
		{
			float NewInnerConeAngle;
		};
		UObject* Outer=Z_Construct_UClass_USpotLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetInnerConeAngle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SpotLightComponent_eventSetInnerConeAngle_Parms));
			UProperty* NewProp_NewInnerConeAngle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInnerConeAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewInnerConeAngle, SpotLightComponent_eventSetInnerConeAngle_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SpotLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USpotLightComponent_SetOuterConeAngle()
	{
		struct SpotLightComponent_eventSetOuterConeAngle_Parms
		{
			float NewOuterConeAngle;
		};
		UObject* Outer=Z_Construct_UClass_USpotLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetOuterConeAngle"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SpotLightComponent_eventSetOuterConeAngle_Parms));
			UProperty* NewProp_NewOuterConeAngle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewOuterConeAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewOuterConeAngle, SpotLightComponent_eventSetOuterConeAngle_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Lighting"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SpotLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USpotLightComponent_NoRegister()
	{
		return USpotLightComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USpotLightComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPointLightComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USpotLightComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_USpotLightComponent_SetInnerConeAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_USpotLightComponent_SetOuterConeAngle());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LightShaftConeAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightShaftConeAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LightShaftConeAngle, USpotLightComponent), 0x0000000000000000);
				UProperty* NewProp_OuterConeAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OuterConeAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OuterConeAngle, USpotLightComponent), 0x0000000000000015);
				UProperty* NewProp_InnerConeAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InnerConeAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InnerConeAngle, USpotLightComponent), 0x0000000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USpotLightComponent_SetInnerConeAngle()); // 3534060367
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USpotLightComponent_SetOuterConeAngle()); // 1636976890
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Lights"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object LightShafts Trigger Activation Components|Activation Physics Trigger Activation Components|Activation Physics Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SpotLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SpotLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A spot light component emits a directional cone shaped light (Eg a Torch)."));
				MetaData->SetValue(NewProp_LightShaftConeAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SpotLightComponent.h"));
				MetaData->SetValue(NewProp_LightShaftConeAngle, TEXT("ToolTip"), TEXT("EditAnywhere, BlueprintReadOnly, Category=LightShaft, meta=(UIMin = \"1.0\", UIMax = \"180.0\")"));
				MetaData->SetValue(NewProp_OuterConeAngle, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_OuterConeAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SpotLightComponent.h"));
				MetaData->SetValue(NewProp_OuterConeAngle, TEXT("ToolTip"), TEXT("Degrees."));
				MetaData->SetValue(NewProp_OuterConeAngle, TEXT("UIMax"), TEXT("80.0"));
				MetaData->SetValue(NewProp_OuterConeAngle, TEXT("UIMin"), TEXT("1.0"));
				MetaData->SetValue(NewProp_InnerConeAngle, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_InnerConeAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SpotLightComponent.h"));
				MetaData->SetValue(NewProp_InnerConeAngle, TEXT("ToolTip"), TEXT("Degrees."));
				MetaData->SetValue(NewProp_InnerConeAngle, TEXT("UIMax"), TEXT("80.0"));
				MetaData->SetValue(NewProp_InnerConeAngle, TEXT("UIMin"), TEXT("1.0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USpotLightComponent(Z_Construct_UClass_USpotLightComponent, TEXT("USpotLightComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USpotLightComponent);
	UEnum* Z_Construct_UEnum_Engine_ESkyLightSourceType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESkyLightSourceType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESkyLightSourceType"), 0, Get_Z_Construct_UEnum_Engine_ESkyLightSourceType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESkyLightSourceType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SLS_CapturedScene")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SLS_SpecifiedCubemap")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SLS_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("SLS_CapturedScene.ToolTip"), TEXT("Construct the sky light from the captured scene, anything further than SkyDistanceThreshold from the sky light position will be included."));
			MetaData->SetValue(ReturnEnum, TEXT("SLS_SpecifiedCubemap.ToolTip"), TEXT("Construct the sky light from the specified cubemap."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESkyLightSourceType_CRC() { return 1660164381U; }
	UFunction* Z_Construct_UFunction_USkyLightComponent_RecaptureSky()
	{
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RecaptureSky"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Recaptures the scene for the skylight.\nThis is useful for making sure the sky light is up to date after changing something in the world that it would capture.\nWarning: this is very costly and will definitely cause a hitch."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetCubemap()
	{
		struct SkyLightComponent_eventSetCubemap_Parms
		{
			UTextureCube* NewCubemap;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCubemap"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkyLightComponent_eventSetCubemap_Parms));
			UProperty* NewProp_NewCubemap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewCubemap"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewCubemap, SkyLightComponent_eventSetCubemap_Parms), 0x0000000000000080, Z_Construct_UClass_UTextureCube_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the cubemap used when SourceType is set to SpecifiedCubemap, and causes a skylight update on the next tick."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetCubemapBlend()
	{
		struct SkyLightComponent_eventSetCubemapBlend_Parms
		{
			UTextureCube* SourceCubemap;
			UTextureCube* DestinationCubemap;
			float InBlendFraction;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCubemapBlend"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkyLightComponent_eventSetCubemapBlend_Parms));
			UProperty* NewProp_InBlendFraction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBlendFraction"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InBlendFraction, SkyLightComponent_eventSetCubemapBlend_Parms), 0x0000000000000080);
			UProperty* NewProp_DestinationCubemap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DestinationCubemap"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DestinationCubemap, SkyLightComponent_eventSetCubemapBlend_Parms), 0x0000000000000080, Z_Construct_UClass_UTextureCube_NoRegister());
			UProperty* NewProp_SourceCubemap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceCubemap"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SourceCubemap, SkyLightComponent_eventSetCubemapBlend_Parms), 0x0000000000000080, Z_Construct_UClass_UTextureCube_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates sky lighting from a blend between two cubemaps, which is only valid when SourceType is set to SpecifiedCubemap.\nThis can be used to seamlessly transition sky lighting between different times of day.\nThe caller should continue to update the blend until BlendFraction is 0 or 1 to reduce rendering cost.\nThe caller is responsible for avoiding pops due to changing the source or destination."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetIndirectLightingIntensity()
	{
		struct SkyLightComponent_eventSetIndirectLightingIntensity_Parms
		{
			float NewIntensity;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetIndirectLightingIntensity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkyLightComponent_eventSetIndirectLightingIntensity_Parms));
			UProperty* NewProp_NewIntensity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewIntensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewIntensity, SkyLightComponent_eventSetIndirectLightingIntensity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Light"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetIntensity()
	{
		struct SkyLightComponent_eventSetIntensity_Parms
		{
			float NewIntensity;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetIntensity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkyLightComponent_eventSetIntensity_Parms));
			UProperty* NewProp_NewIntensity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewIntensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewIntensity, SkyLightComponent_eventSetIntensity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetLightColor()
	{
		struct SkyLightComponent_eventSetLightColor_Parms
		{
			FLinearColor NewLightColor;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLightColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SkyLightComponent_eventSetLightColor_Parms));
			UProperty* NewProp_NewLightColor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLightColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewLightColor, SkyLightComponent_eventSetLightColor_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set color of the light"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetMinOcclusion()
	{
		struct SkyLightComponent_eventSetMinOcclusion_Parms
		{
			float InMinOcclusion;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMinOcclusion"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SkyLightComponent_eventSetMinOcclusion_Parms));
			UProperty* NewProp_InMinOcclusion = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InMinOcclusion"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InMinOcclusion, SkyLightComponent_eventSetMinOcclusion_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkyLightComponent_SetOcclusionTint()
	{
		struct SkyLightComponent_eventSetOcclusionTint_Parms
		{
			FColor InTint;
		};
		UObject* Outer=Z_Construct_UClass_USkyLightComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetOcclusionTint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SkyLightComponent_eventSetOcclusionTint_Parms));
			UProperty* NewProp_InTint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InTint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InTint, SkyLightComponent_eventSetOcclusionTint_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|SkyLight"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkyLightComponent_NoRegister()
	{
		return USkyLightComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USkyLightComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULightComponentBase();
			Z_Construct_UPackage_Engine();
			OuterClass = USkyLightComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_RecaptureSky());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetCubemap());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetCubemapBlend());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetIndirectLightingIntensity());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetIntensity());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetLightColor());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetMinOcclusion());
				OuterClass->LinkChild(Z_Construct_UFunction_USkyLightComponent_SetOcclusionTint());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BlendDestinationCubemap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BlendDestinationCubemap"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(BlendDestinationCubemap, USkyLightComponent), 0x0000080000002000, Z_Construct_UClass_UTextureCube_NoRegister());
				UProperty* NewProp_OcclusionTint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OcclusionTint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OcclusionTint, USkyLightComponent), 0x0000000000000015, Z_Construct_UScriptStruct_FColor());
				UProperty* NewProp_MinOcclusion = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinOcclusion"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinOcclusion, USkyLightComponent), 0x0000000000000015);
				UProperty* NewProp_Contrast = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Contrast"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Contrast, USkyLightComponent), 0x0000000000000015);
				UProperty* NewProp_OcclusionMaxDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OcclusionMaxDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OcclusionMaxDistance, USkyLightComponent), 0x0000000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLowerHemisphereIsBlack, USkyLightComponent, bool);
				UProperty* NewProp_bLowerHemisphereIsBlack = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLowerHemisphereIsBlack"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLowerHemisphereIsBlack, USkyLightComponent), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bLowerHemisphereIsBlack, USkyLightComponent), sizeof(bool), true);
				UProperty* NewProp_SkyDistanceThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkyDistanceThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SkyDistanceThreshold, USkyLightComponent), 0x0000000000000015);
				UProperty* NewProp_Cubemap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Cubemap"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Cubemap, USkyLightComponent), 0x0000000000000015, Z_Construct_UClass_UTextureCube_NoRegister());
				UProperty* NewProp_SourceType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SourceType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SourceType, USkyLightComponent), 0x0000000000000015, Z_Construct_UEnum_Engine_ESkyLightSourceType());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_RecaptureSky()); // 2168494127
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetCubemap()); // 2903276143
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetCubemapBlend()); // 2664379411
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetIndirectLightingIntensity()); // 2652949384
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetIntensity()); // 1750798108
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetLightColor()); // 268275475
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetMinOcclusion()); // 1040515259
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkyLightComponent_SetOcclusionTint()); // 467904627
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Lights"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Trigger Activation Components|Activation Physics Trigger Activation Components|Activation Physics Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SkyLightComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_BlendDestinationCubemap, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_OcclusionTint, TEXT("Category"), TEXT("DistanceFieldAmbientOcclusion"));
				MetaData->SetValue(NewProp_OcclusionTint, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_OcclusionTint, TEXT("ToolTip"), TEXT("Tint color on occluded areas, artistic control."));
				MetaData->SetValue(NewProp_MinOcclusion, TEXT("Category"), TEXT("DistanceFieldAmbientOcclusion"));
				MetaData->SetValue(NewProp_MinOcclusion, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_MinOcclusion, TEXT("ToolTip"), TEXT("Controls the darkest that a fully occluded area can get."));
				MetaData->SetValue(NewProp_MinOcclusion, TEXT("UIMax"), TEXT("1"));
				MetaData->SetValue(NewProp_MinOcclusion, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Contrast, TEXT("Category"), TEXT("DistanceFieldAmbientOcclusion"));
				MetaData->SetValue(NewProp_Contrast, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_Contrast, TEXT("ToolTip"), TEXT("Contrast S-curve applied to the computed AO.  A value of 0 means no contrast increase, 1 is a significant contrast increase."));
				MetaData->SetValue(NewProp_Contrast, TEXT("UIMax"), TEXT("1"));
				MetaData->SetValue(NewProp_Contrast, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_OcclusionMaxDistance, TEXT("Category"), TEXT("DistanceFieldAmbientOcclusion"));
				MetaData->SetValue(NewProp_OcclusionMaxDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_OcclusionMaxDistance, TEXT("ToolTip"), TEXT("Max distance that the occlusion of one point will affect another.\nHigher values increase the cost of Distance Field AO exponentially."));
				MetaData->SetValue(NewProp_OcclusionMaxDistance, TEXT("UIMax"), TEXT("1500"));
				MetaData->SetValue(NewProp_OcclusionMaxDistance, TEXT("UIMin"), TEXT("200"));
				MetaData->SetValue(NewProp_bLowerHemisphereIsBlack, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_bLowerHemisphereIsBlack, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_bLowerHemisphereIsBlack, TEXT("ToolTip"), TEXT("Whether all distant lighting from the lower hemisphere should be set to zero.\nEnabling this is accurate when lighting a scene on a planet,\nHowever disabling it can be useful to approximate skylight bounce lighting (eg Movable light)."));
				MetaData->SetValue(NewProp_SkyDistanceThreshold, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_SkyDistanceThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_SkyDistanceThreshold, TEXT("ToolTip"), TEXT("Distance from the sky light at which any geometry should be treated as part of the sky.\nThis is also used by reflection captures, so update reflection captures to see the impact."));
				MetaData->SetValue(NewProp_Cubemap, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_Cubemap, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_Cubemap, TEXT("ToolTip"), TEXT("Cubemap to use for sky lighting if SourceType is set to SLS_SpecifiedCubemap."));
				MetaData->SetValue(NewProp_SourceType, TEXT("Category"), TEXT("Light"));
				MetaData->SetValue(NewProp_SourceType, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SkyLightComponent.h"));
				MetaData->SetValue(NewProp_SourceType, TEXT("ToolTip"), TEXT("Indicates where to get the light contribution from."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkyLightComponent(Z_Construct_UClass_USkyLightComponent, TEXT("USkyLightComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkyLightComponent);
	UClass* Z_Construct_UClass_UNavigationGraphNodeComponent_NoRegister()
	{
		return UNavigationGraphNodeComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavigationGraphNodeComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavigationGraphNodeComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PrevNodeComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PrevNodeComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PrevNodeComponent, UNavigationGraphNodeComponent), 0x0000000000080008, Z_Construct_UClass_UNavigationGraphNodeComponent_NoRegister());
				UProperty* NewProp_NextNodeComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NextNodeComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NextNodeComponent, UNavigationGraphNodeComponent), 0x0000000000080008, Z_Construct_UClass_UNavigationGraphNodeComponent_NoRegister());
				UProperty* NewProp_Node = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Node"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Node, UNavigationGraphNodeComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FNavGraphNode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavigationGraphNodeComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationGraphNodeComponent.h"));
				MetaData->SetValue(NewProp_PrevNodeComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PrevNodeComponent, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationGraphNodeComponent.h"));
				MetaData->SetValue(NewProp_NextNodeComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_NextNodeComponent, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationGraphNodeComponent.h"));
				MetaData->SetValue(NewProp_Node, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavigationGraphNodeComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavigationGraphNodeComponent(Z_Construct_UClass_UNavigationGraphNodeComponent, TEXT("UNavigationGraphNodeComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavigationGraphNodeComponent);
	UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetNormalizedCompressionScalar()
	{
		struct PhysicsSpringComponent_eventGetNormalizedCompressionScalar_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsSpringComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetNormalizedCompressionScalar"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(PhysicsSpringComponent_eventGetNormalizedCompressionScalar_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsSpringComponent_eventGetNormalizedCompressionScalar_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the spring compression as a normalized scalar along spring direction.\n0 implies spring is at rest\n1 implies fully compressed"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringCurrentEndPoint()
	{
		struct PhysicsSpringComponent_eventGetSpringCurrentEndPoint_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsSpringComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSpringCurrentEndPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(PhysicsSpringComponent_eventGetSpringCurrentEndPoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsSpringComponent_eventGetSpringCurrentEndPoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the spring current end point in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringDirection()
	{
		struct PhysicsSpringComponent_eventGetSpringDirection_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsSpringComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSpringDirection"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(PhysicsSpringComponent_eventGetSpringDirection_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsSpringComponent_eventGetSpringDirection_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the spring direction from start to resting point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringRestingPoint()
	{
		struct PhysicsSpringComponent_eventGetSpringRestingPoint_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPhysicsSpringComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSpringRestingPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(PhysicsSpringComponent_eventGetSpringRestingPoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PhysicsSpringComponent_eventGetSpringRestingPoint_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the spring resting point in world space."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPhysicsSpringComponent_NoRegister()
	{
		return UPhysicsSpringComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPhysicsSpringComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPhysicsSpringComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsSpringComponent_GetNormalizedCompressionScalar());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringCurrentEndPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringDirection());
				OuterClass->LinkChild(Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringRestingPoint());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SpringCompression = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpringCompression"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SpringCompression, UPhysicsSpringComponent), 0x0000000000002014);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, UPhysicsSpringComponent, bool);
				UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, UPhysicsSpringComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, UPhysicsSpringComponent), sizeof(bool), true);
				UProperty* NewProp_SpringChannel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpringChannel"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SpringChannel, UPhysicsSpringComponent), 0x0000000000000004, Z_Construct_UEnum_Engine_ECollisionChannel());
				UProperty* NewProp_SpringRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpringRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SpringRadius, UPhysicsSpringComponent), 0x0000000000000005);
				UProperty* NewProp_SpringLengthAtRest = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpringLengthAtRest"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SpringLengthAtRest, UPhysicsSpringComponent), 0x0000000000000005);
				UProperty* NewProp_SpringDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpringDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SpringDamping, UPhysicsSpringComponent), 0x0000000000000005);
				UProperty* NewProp_SpringStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpringStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SpringStiffness, UPhysicsSpringComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsSpringComponent_GetNormalizedCompressionScalar()); // 2001342836
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringCurrentEndPoint()); // 3280644488
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringDirection()); // 1341307523
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPhysicsSpringComponent_GetSpringRestingPoint()); // 2509708969
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Note: this component is still work in progress. Uses raycast springs for simple vehicle forces\n   Used with objects that have physics to create a spring down the X direction\n   ie. point X in the direction you want generate spring."));
				MetaData->SetValue(NewProp_SpringCompression, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_SpringCompression, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_SpringCompression, TEXT("ToolTip"), TEXT("The current compression of the spring. A spring at rest will have SpringCompression 0."));
				MetaData->SetValue(NewProp_bIgnoreSelf, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_bIgnoreSelf, TEXT("ClampMin"), TEXT("0.010000"));
				MetaData->SetValue(NewProp_bIgnoreSelf, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_bIgnoreSelf, TEXT("ToolTip"), TEXT("If true, the spring will ignore all components in its own actor"));
				MetaData->SetValue(NewProp_bIgnoreSelf, TEXT("UIMin"), TEXT("0.010000"));
				MetaData->SetValue(NewProp_SpringChannel, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_SpringChannel, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_SpringChannel, TEXT("ToolTip"), TEXT("Strength of thrust force applied to the base object."));
				MetaData->SetValue(NewProp_SpringRadius, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_SpringRadius, TEXT("ClampMin"), TEXT("0.010000"));
				MetaData->SetValue(NewProp_SpringRadius, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_SpringRadius, TEXT("ToolTip"), TEXT("Determines the radius of the spring."));
				MetaData->SetValue(NewProp_SpringRadius, TEXT("UIMin"), TEXT("0.010000"));
				MetaData->SetValue(NewProp_SpringLengthAtRest, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_SpringLengthAtRest, TEXT("ClampMin"), TEXT("0.010000"));
				MetaData->SetValue(NewProp_SpringLengthAtRest, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_SpringLengthAtRest, TEXT("ToolTip"), TEXT("Determines how long the spring will be along the X-axis at rest. The spring will apply 0 force on a body when it's at rest."));
				MetaData->SetValue(NewProp_SpringLengthAtRest, TEXT("UIMin"), TEXT("0.010000"));
				MetaData->SetValue(NewProp_SpringDamping, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_SpringDamping, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_SpringDamping, TEXT("ToolTip"), TEXT("Specifies how quickly the spring can absorb energy of a body. The higher the damping the less oscillation"));
				MetaData->SetValue(NewProp_SpringStiffness, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_SpringStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsSpringComponent.h"));
				MetaData->SetValue(NewProp_SpringStiffness, TEXT("ToolTip"), TEXT("Specifies how much strength the spring has. The higher the SpringStiffness the more force the spring can push on a body with."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPhysicsSpringComponent(Z_Construct_UClass_UPhysicsSpringComponent, TEXT("UPhysicsSpringComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPhysicsSpringComponent);
	UClass* Z_Construct_UClass_UPhysicsThrusterComponent_NoRegister()
	{
		return UPhysicsThrusterComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPhysicsThrusterComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPhysicsThrusterComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ThrustStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThrustStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ThrustStrength, UPhysicsThrusterComponent), 0x0000000200000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/PhysicsThrusterComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsThrusterComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Used with objects that have physics to apply a force down the negative-X direction\nie. point X in the direction you want the thrust in."));
				MetaData->SetValue(NewProp_ThrustStrength, TEXT("Category"), TEXT("Physics"));
				MetaData->SetValue(NewProp_ThrustStrength, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/PhysicsThrusterComponent.h"));
				MetaData->SetValue(NewProp_ThrustStrength, TEXT("ToolTip"), TEXT("Strength of thrust force applied to the base object."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPhysicsThrusterComponent(Z_Construct_UClass_UPhysicsThrusterComponent, TEXT("UPhysicsThrusterComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPhysicsThrusterComponent);
	UFunction* Z_Construct_UFunction_UPostProcessComponent_AddOrUpdateBlendable()
	{
		struct PostProcessComponent_eventAddOrUpdateBlendable_Parms
		{
			TScriptInterface<IBlendableInterface> InBlendableObject;
			float InWeight;
		};
		UObject* Outer=Z_Construct_UClass_UPostProcessComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddOrUpdateBlendable"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(PostProcessComponent_eventAddOrUpdateBlendable_Parms));
			UProperty* NewProp_InWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWeight, PostProcessComponent_eventAddOrUpdateBlendable_Parms), 0x0000000000000080);
			UProperty* NewProp_InBlendableObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBlendableObject"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(InBlendableObject, PostProcessComponent_eventAddOrUpdateBlendable_Parms), 0x0004000000000080, Z_Construct_UClass_UBlendableInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_InWeight"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPostProcessComponent_NoRegister()
	{
		return UPostProcessComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPostProcessComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPostProcessComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A83080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPostProcessComponent_AddOrUpdateBlendable());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUnbound, UPostProcessComponent, uint8);
				UProperty* NewProp_bUnbound = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUnbound"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUnbound, UPostProcessComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bUnbound, UPostProcessComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnabled, UPostProcessComponent, uint8);
				UProperty* NewProp_bEnabled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnabled, UPostProcessComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnabled, UPostProcessComponent), sizeof(uint8), false);
				UProperty* NewProp_BlendWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BlendWeight, UPostProcessComponent), 0x0000000200000005);
				UProperty* NewProp_BlendRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BlendRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BlendRadius, UPostProcessComponent), 0x0000000200000005);
				UProperty* NewProp_Priority = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Priority"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Priority, UPostProcessComponent), 0x0000000000000005);
				UProperty* NewProp_Settings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Settings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Settings, UPostProcessComponent), 0x0000000200000005, Z_Construct_UScriptStruct_FPostProcessSettings());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPostProcessComponent_AddOrUpdateBlendable()); // 1390030048
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UInterface_PostProcessVolume_NoRegister(), VTABLE_OFFSET(UPostProcessComponent, IInterface_PostProcessVolume), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PostProcessComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("PostProcessComponent. Enables Post process controls for blueprints.\n   Will use a parent UShapeComponent to provide volume data if available."));
				MetaData->SetValue(NewProp_bUnbound, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_bUnbound, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(NewProp_bUnbound, TEXT("ToolTip"), TEXT("set this to false to use the parent shape component as volume bounds. True affects the whole world regardless."));
				MetaData->SetValue(NewProp_bEnabled, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_bEnabled, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(NewProp_bEnabled, TEXT("ToolTip"), TEXT("Whether this volume is enabled or not."));
				MetaData->SetValue(NewProp_BlendWeight, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_BlendWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(NewProp_BlendWeight, TEXT("ToolTip"), TEXT("0:no effect, 1:full effect"));
				MetaData->SetValue(NewProp_BlendWeight, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_BlendWeight, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_BlendRadius, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_BlendRadius, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_BlendRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(NewProp_BlendRadius, TEXT("ToolTip"), TEXT("World space radius around the volume that is used for blending (only if not unbound)."));
				MetaData->SetValue(NewProp_BlendRadius, TEXT("UIMax"), TEXT("6000.0"));
				MetaData->SetValue(NewProp_BlendRadius, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_Priority, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_Priority, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(NewProp_Priority, TEXT("ToolTip"), TEXT("Priority of this volume. In the case of overlapping volumes the one with the highest priority\noverrides the lower priority ones. The order is undefined if two or more overlapping volumes have the same priority."));
				MetaData->SetValue(NewProp_Settings, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_Settings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PostProcessComponent.h"));
				MetaData->SetValue(NewProp_Settings, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_Settings, TEXT("ToolTip"), TEXT("Post process settings to use for this volume."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPostProcessComponent(Z_Construct_UClass_UPostProcessComponent, TEXT("UPostProcessComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPostProcessComponent);
	UFunction* Z_Construct_UFunction_UArrowComponent_SetArrowColor_DEPRECATED()
	{
		struct ArrowComponent_eventSetArrowColor_DEPRECATED_Parms
		{
			FColor NewColor;
		};
		UObject* Outer=Z_Construct_UClass_UArrowComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetArrowColor_DEPRECATED"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ArrowComponent_eventSetArrowColor_DEPRECATED_Parms));
			UProperty* NewProp_NewColor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewColor, ArrowComponent_eventSetArrowColor_DEPRECATED_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Arrow"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use new SetArrowColor"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Updates the arrow's colour, and tells it to refresh"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UArrowComponent_SetArrowColor_New()
	{
		struct ArrowComponent_eventSetArrowColor_New_Parms
		{
			FLinearColor NewColor;
		};
		UObject* Outer=Z_Construct_UClass_UArrowComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetArrowColor_New"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ArrowComponent_eventSetArrowColor_New_Parms));
			UProperty* NewProp_NewColor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewColor, ArrowComponent_eventSetArrowColor_New_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Arrow"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("SetArrowColor"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Updates the arrow's colour, and tells it to refresh"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UArrowComponent_NoRegister()
	{
		return UArrowComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UArrowComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UArrowComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UArrowComponent_SetArrowColor_DEPRECATED());
				OuterClass->LinkChild(Z_Construct_UFunction_UArrowComponent_SetArrowColor_New());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseInEditorScaling, UArrowComponent, bool);
				UProperty* NewProp_bUseInEditorScaling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseInEditorScaling"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseInEditorScaling, UArrowComponent), 0x0000000800000005, CPP_BOOL_PROPERTY_BITMASK(bUseInEditorScaling, UArrowComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLightAttachment, UArrowComponent, uint8);
				UProperty* NewProp_bLightAttachment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLightAttachment"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLightAttachment, UArrowComponent), 0x0000000800000000, CPP_BOOL_PROPERTY_BITMASK(bLightAttachment, UArrowComponent), sizeof(uint8), false);
				UProperty* NewProp_SpriteInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SpriteInfo, UArrowComponent), 0x0000000800000000, Z_Construct_UScriptStruct_FSpriteCategoryInfo());
				UProperty* NewProp_SpriteCategoryName = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteCategoryName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(SpriteCategoryName_DEPRECATED, UArrowComponent), 0x0000000820000000);
#endif // WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTreatAsASprite, UArrowComponent, uint8);
				UProperty* NewProp_bTreatAsASprite = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bTreatAsASprite"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTreatAsASprite, UArrowComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bTreatAsASprite, UArrowComponent), sizeof(uint8), false);
				UProperty* NewProp_ScreenSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScreenSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScreenSize, UArrowComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsScreenSizeScaled, UArrowComponent, bool);
				UProperty* NewProp_bIsScreenSizeScaled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsScreenSizeScaled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsScreenSizeScaled, UArrowComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsScreenSizeScaled, UArrowComponent), sizeof(bool), true);
				UProperty* NewProp_ArrowSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ArrowSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ArrowSize, UArrowComponent), 0x0000000000000005);
				UProperty* NewProp_ArrowColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ArrowColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ArrowColor, UArrowComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FColor());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UArrowComponent_SetArrowColor_DEPRECATED()); // 1366492476
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UArrowComponent_SetArrowColor_New()); // 1031942556
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Physics Lighting TextureStreaming Activation Components|Activation Collision Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ArrowComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A simple arrow rendered using lines. Useful for indicating which way an object is facing."));
				MetaData->SetValue(NewProp_bUseInEditorScaling, TEXT("Category"), TEXT("ArrowComponent"));
				MetaData->SetValue(NewProp_bUseInEditorScaling, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_bUseInEditorScaling, TEXT("ToolTip"), TEXT("Whether to use in-editor arrow scaling (i.e. to be affected by the global arrow scale)"));
				MetaData->SetValue(NewProp_bLightAttachment, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_bLightAttachment, TEXT("ToolTip"), TEXT("If true, this arrow component is attached to a light actor"));
				MetaData->SetValue(NewProp_SpriteInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_SpriteInfo, TEXT("ToolTip"), TEXT("Sprite category information regarding the arrow component, if being treated as a sprite."));
				MetaData->SetValue(NewProp_SpriteCategoryName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_SpriteCategoryName, TEXT("ToolTip"), TEXT("Sprite category that the arrow component belongs to, if being treated as a sprite. Value serves as a key into the localization file."));
				MetaData->SetValue(NewProp_bTreatAsASprite, TEXT("Category"), TEXT("ArrowComponent"));
				MetaData->SetValue(NewProp_bTreatAsASprite, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_bTreatAsASprite, TEXT("ToolTip"), TEXT("If true, don't show the arrow when EngineShowFlags.BillboardSprites is disabled."));
				MetaData->SetValue(NewProp_ScreenSize, TEXT("Category"), TEXT("ArrowComponent"));
				MetaData->SetValue(NewProp_ScreenSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_ScreenSize, TEXT("ToolTip"), TEXT("The size on screen to limit this arrow to (in screen space)"));
				MetaData->SetValue(NewProp_bIsScreenSizeScaled, TEXT("Category"), TEXT("ArrowComponent"));
				MetaData->SetValue(NewProp_bIsScreenSizeScaled, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_bIsScreenSizeScaled, TEXT("ToolTip"), TEXT("Set to limit the screen size of this arrow"));
				MetaData->SetValue(NewProp_ArrowSize, TEXT("Category"), TEXT("ArrowComponent"));
				MetaData->SetValue(NewProp_ArrowSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
				MetaData->SetValue(NewProp_ArrowColor, TEXT("Category"), TEXT("ArrowComponent"));
				MetaData->SetValue(NewProp_ArrowColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ArrowComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UArrowComponent(Z_Construct_UClass_UArrowComponent, TEXT("UArrowComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UArrowComponent);
	UFunction* Z_Construct_UFunction_UBillboardComponent_SetSprite()
	{
		struct BillboardComponent_eventSetSprite_Parms
		{
			UTexture2D* NewSprite;
		};
		UObject* Outer=Z_Construct_UClass_UBillboardComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSprite"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(BillboardComponent_eventSetSprite_Parms));
			UProperty* NewProp_NewSprite = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSprite"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewSprite, BillboardComponent_eventSetSprite_Parms), 0x0000000000000080, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Sprite"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the sprite texture used by this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UBillboardComponent_SetSpriteAndUV()
	{
		struct BillboardComponent_eventSetSpriteAndUV_Parms
		{
			UTexture2D* NewSprite;
			int32 NewU;
			int32 NewUL;
			int32 NewV;
			int32 NewVL;
		};
		UObject* Outer=Z_Construct_UClass_UBillboardComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSpriteAndUV"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(BillboardComponent_eventSetSpriteAndUV_Parms));
			UProperty* NewProp_NewVL = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVL"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewVL, BillboardComponent_eventSetSpriteAndUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewV = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewV"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewV, BillboardComponent_eventSetSpriteAndUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewUL = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewUL"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewUL, BillboardComponent_eventSetSpriteAndUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewU = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewU"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewU, BillboardComponent_eventSetSpriteAndUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewSprite = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSprite"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewSprite, BillboardComponent_eventSetSpriteAndUV_Parms), 0x0000000000000080, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Sprite"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the sprite texture and the UV's used by this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UBillboardComponent_SetUV()
	{
		struct BillboardComponent_eventSetUV_Parms
		{
			int32 NewU;
			int32 NewUL;
			int32 NewV;
			int32 NewVL;
		};
		UObject* Outer=Z_Construct_UClass_UBillboardComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetUV"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(BillboardComponent_eventSetUV_Parms));
			UProperty* NewProp_NewVL = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewVL"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewVL, BillboardComponent_eventSetUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewV = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewV"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewV, BillboardComponent_eventSetUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewUL = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewUL"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewUL, BillboardComponent_eventSetUV_Parms), 0x0000000000000080);
			UProperty* NewProp_NewU = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewU"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewU, BillboardComponent_eventSetUV_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|Sprite"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the sprite's UVs"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UBillboardComponent_NoRegister()
	{
		return UBillboardComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBillboardComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UBillboardComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B03080;

				OuterClass->LinkChild(Z_Construct_UFunction_UBillboardComponent_SetSprite());
				OuterClass->LinkChild(Z_Construct_UFunction_UBillboardComponent_SetSpriteAndUV());
				OuterClass->LinkChild(Z_Construct_UFunction_UBillboardComponent_SetUV());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseInEditorScaling, UBillboardComponent, bool);
				UProperty* NewProp_bUseInEditorScaling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseInEditorScaling"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseInEditorScaling, UBillboardComponent), 0x0000000800000005, CPP_BOOL_PROPERTY_BITMASK(bUseInEditorScaling, UBillboardComponent), sizeof(bool), true);
				UProperty* NewProp_SpriteInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SpriteInfo, UBillboardComponent), 0x0000000800000000, Z_Construct_UScriptStruct_FSpriteCategoryInfo());
				UProperty* NewProp_SpriteCategoryName = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpriteCategoryName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(SpriteCategoryName_DEPRECATED, UBillboardComponent), 0x0000000820000000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_VL = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VL"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(VL, UBillboardComponent), 0x0000000000000005);
				UProperty* NewProp_V = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("V"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(V, UBillboardComponent), 0x0000000000000005);
				UProperty* NewProp_UL = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UL"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(UL, UBillboardComponent), 0x0000000000000005);
				UProperty* NewProp_U = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("U"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(U, UBillboardComponent), 0x0000000000000005);
				UProperty* NewProp_ScreenSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScreenSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScreenSize, UBillboardComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsScreenSizeScaled, UBillboardComponent, uint8);
				UProperty* NewProp_bIsScreenSizeScaled = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsScreenSizeScaled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsScreenSizeScaled, UBillboardComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsScreenSizeScaled, UBillboardComponent), sizeof(uint8), false);
				UProperty* NewProp_Sprite = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Sprite"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Sprite, UBillboardComponent), 0x0000000000000005, Z_Construct_UClass_UTexture2D_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UBillboardComponent_SetSprite()); // 975627159
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UBillboardComponent_SetSpriteAndUV()); // 712602564
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UBillboardComponent_SetUV()); // 2801993297
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Physics Collision Lighting Mesh PhysicsVolume Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/BillboardComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A 2d texture that will be rendered always facing the camera."));
				MetaData->SetValue(NewProp_bUseInEditorScaling, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_bUseInEditorScaling, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_bUseInEditorScaling, TEXT("ToolTip"), TEXT("Whether to use in-editor arrow scaling (i.e. to be affected by the global arrow scale)"));
				MetaData->SetValue(NewProp_SpriteInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_SpriteInfo, TEXT("ToolTip"), TEXT("Sprite category information regarding the component"));
				MetaData->SetValue(NewProp_SpriteCategoryName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_SpriteCategoryName, TEXT("ToolTip"), TEXT("Sprite category that the component belongs to. Value serves as a key into the localization file."));
				MetaData->SetValue(NewProp_VL, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_VL, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_V, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_V, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_UL, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_UL, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_U, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_U, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_ScreenSize, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_ScreenSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_bIsScreenSizeScaled, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_bIsScreenSizeScaled, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
				MetaData->SetValue(NewProp_Sprite, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_Sprite, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BillboardComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBillboardComponent(Z_Construct_UClass_UBillboardComponent, TEXT("UBillboardComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBillboardComponent);
	UClass* Z_Construct_UClass_UBrushComponent_NoRegister()
	{
		return UBrushComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBrushComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UBrushComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A81080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PrePivot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PrePivot"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PrePivot_DEPRECATED, UBrushComponent), 0x0000000020000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_BrushBodySetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BrushBodySetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(BrushBodySetup, UBrushComponent), 0x0000000000000000, Z_Construct_UClass_UBodySetup_NoRegister());
				UProperty* NewProp_Brush = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Brush"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Brush, UBrushComponent), 0x0000000000000000, UModel::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Physics Lighting LOD Rendering TextureStreaming Transform Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/BrushComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BrushComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Rendering|Material"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A brush component defines a shape that can be modified within the editor. They are used both as part of BSP building, and for volumes.\n@see https://docs.unrealengine.com/latest/INT/Engine/Actors/Volumes\n@see https://docs.unrealengine.com/latest/INT/Engine/Actors/Brushes"));
				MetaData->SetValue(NewProp_PrePivot, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BrushComponent.h"));
				MetaData->SetValue(NewProp_PrePivot, TEXT("ToolTip"), TEXT("Local space translation"));
				MetaData->SetValue(NewProp_BrushBodySetup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BrushComponent.h"));
				MetaData->SetValue(NewProp_BrushBodySetup, TEXT("ToolTip"), TEXT("Description of collision"));
				MetaData->SetValue(NewProp_Brush, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BrushComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBrushComponent(Z_Construct_UClass_UBrushComponent, TEXT("UBrushComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBrushComponent);
	UClass* Z_Construct_UClass_UDrawFrustumComponent_NoRegister()
	{
		return UDrawFrustumComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UDrawFrustumComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UDrawFrustumComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A83080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Texture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Texture"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Texture, UDrawFrustumComponent), 0x0000000000000005, Z_Construct_UClass_UTexture_NoRegister());
				UProperty* NewProp_FrustumEndDist = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FrustumEndDist"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrustumEndDist, UDrawFrustumComponent), 0x0000000000000005);
				UProperty* NewProp_FrustumStartDist = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FrustumStartDist"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrustumStartDist, UDrawFrustumComponent), 0x0000000000000005);
				UProperty* NewProp_FrustumAspectRatio = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FrustumAspectRatio"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrustumAspectRatio, UDrawFrustumComponent), 0x0000000000000005);
				UProperty* NewProp_FrustumAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FrustumAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FrustumAngle, UDrawFrustumComponent), 0x0000000000000005);
				UProperty* NewProp_FrustumColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FrustumColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FrustumColor, UDrawFrustumComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FColor());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/DrawFrustumComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Utility component for drawing a view frustum. Origin is at the component location, frustum points down position X axis."));
				MetaData->SetValue(NewProp_Texture, TEXT("Category"), TEXT("DrawFrustumComponent"));
				MetaData->SetValue(NewProp_Texture, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(NewProp_Texture, TEXT("ToolTip"), TEXT("optional texture to show on the near plane"));
				MetaData->SetValue(NewProp_FrustumEndDist, TEXT("Category"), TEXT("DrawFrustumComponent"));
				MetaData->SetValue(NewProp_FrustumEndDist, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(NewProp_FrustumEndDist, TEXT("ToolTip"), TEXT("Distance from origin to stop drawing the frustum."));
				MetaData->SetValue(NewProp_FrustumStartDist, TEXT("Category"), TEXT("DrawFrustumComponent"));
				MetaData->SetValue(NewProp_FrustumStartDist, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(NewProp_FrustumStartDist, TEXT("ToolTip"), TEXT("Distance from origin to start drawing the frustum."));
				MetaData->SetValue(NewProp_FrustumAspectRatio, TEXT("Category"), TEXT("DrawFrustumComponent"));
				MetaData->SetValue(NewProp_FrustumAspectRatio, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(NewProp_FrustumAspectRatio, TEXT("ToolTip"), TEXT("Ratio of horizontal size over vertical size."));
				MetaData->SetValue(NewProp_FrustumAngle, TEXT("Category"), TEXT("DrawFrustumComponent"));
				MetaData->SetValue(NewProp_FrustumAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(NewProp_FrustumAngle, TEXT("ToolTip"), TEXT("Angle of longest dimension of view shape.\nIf the angle is 0 then an orthographic projection is used"));
				MetaData->SetValue(NewProp_FrustumColor, TEXT("Category"), TEXT("DrawFrustumComponent"));
				MetaData->SetValue(NewProp_FrustumColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawFrustumComponent.h"));
				MetaData->SetValue(NewProp_FrustumColor, TEXT("ToolTip"), TEXT("Color to draw the wireframe frustum."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UDrawFrustumComponent(Z_Construct_UClass_UDrawFrustumComponent, TEXT("UDrawFrustumComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UDrawFrustumComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FBatchedPoint()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBatchedPoint_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BatchedPoint"), sizeof(FBatchedPoint), Get_Z_Construct_UScriptStruct_FBatchedPoint_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BatchedPoint"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBatchedPoint>, EStructFlags(0x00000001));
			UProperty* NewProp_DepthPriority = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DepthPriority"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DepthPriority, FBatchedPoint), 0x0000000000000000);
			UProperty* NewProp_RemainingLifeTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RemainingLifeTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RemainingLifeTime, FBatchedPoint), 0x0000000000000000);
			UProperty* NewProp_PointSize = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PointSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PointSize, FBatchedPoint), 0x0000000000000000);
			UProperty* NewProp_Color = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Color"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Color, FBatchedPoint), 0x0000000000000000, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Position, FBatchedPoint), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_DepthPriority, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_RemainingLifeTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_PointSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_Color, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBatchedPoint_CRC() { return 2473503633U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBatchedLine()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBatchedLine_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BatchedLine"), sizeof(FBatchedLine), Get_Z_Construct_UScriptStruct_FBatchedLine_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BatchedLine"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBatchedLine>, EStructFlags(0x00000001));
			UProperty* NewProp_DepthPriority = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DepthPriority"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(DepthPriority, FBatchedLine), 0x0000000000000000);
			UProperty* NewProp_RemainingLifeTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RemainingLifeTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RemainingLifeTime, FBatchedLine), 0x0000000000000000);
			UProperty* NewProp_Thickness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Thickness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Thickness, FBatchedLine), 0x0000000000000000);
			UProperty* NewProp_Color = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Color"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Color, FBatchedLine), 0x0000000000000000, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_End = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("End"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(End, FBatchedLine), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Start = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Start"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Start, FBatchedLine), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_DepthPriority, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_RemainingLifeTime, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_Thickness, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_Color, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_End, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
			MetaData->SetValue(NewProp_Start, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBatchedLine_CRC() { return 3457895602U; }
	UClass* Z_Construct_UClass_ULineBatchComponent_NoRegister()
	{
		return ULineBatchComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_ULineBatchComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = ULineBatchComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/LineBatchComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/LineBatchComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The line batch component buffers and draws lines (and some other line-based shapes) in a scene.\n    This can be useful for debug drawing, but is not very performant for runtime use."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULineBatchComponent(Z_Construct_UClass_ULineBatchComponent, TEXT("ULineBatchComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULineBatchComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FMaterialSpriteElement()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FMaterialSpriteElement_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("MaterialSpriteElement"), sizeof(FMaterialSpriteElement), Get_Z_Construct_UScriptStruct_FMaterialSpriteElement_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MaterialSpriteElement"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FMaterialSpriteElement>, EStructFlags(0x00000001));
			UProperty* NewProp_DistanceToSizeCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DistanceToSizeCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DistanceToSizeCurve, FMaterialSpriteElement), 0x0000000000000005, Z_Construct_UClass_UCurveFloat_NoRegister());
			UProperty* NewProp_BaseSizeY = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BaseSizeY"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseSizeY, FMaterialSpriteElement), 0x0000000000000005);
			UProperty* NewProp_BaseSizeX = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BaseSizeX"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseSizeX, FMaterialSpriteElement), 0x0000000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSizeIsInScreenSpace, FMaterialSpriteElement, uint8);
			UProperty* NewProp_bSizeIsInScreenSpace = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSizeIsInScreenSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSizeIsInScreenSpace, FMaterialSpriteElement), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bSizeIsInScreenSpace, FMaterialSpriteElement), sizeof(uint8), false);
			UProperty* NewProp_DistanceToOpacityCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DistanceToOpacityCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DistanceToOpacityCurve, FMaterialSpriteElement), 0x0000000000000005, Z_Construct_UClass_UCurveFloat_NoRegister());
			UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, FMaterialSpriteElement), 0x0000000000000005, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_DistanceToSizeCurve, TEXT("Category"), TEXT("MaterialSpriteElement"));
			MetaData->SetValue(NewProp_DistanceToSizeCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_DistanceToSizeCurve, TEXT("ToolTip"), TEXT("A curve that maps distance on the X axis to the sprite size on the Y axis."));
			MetaData->SetValue(NewProp_BaseSizeY, TEXT("Category"), TEXT("MaterialSpriteElement"));
			MetaData->SetValue(NewProp_BaseSizeY, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_BaseSizeY, TEXT("ToolTip"), TEXT("The base height of the sprite, multiplied with the DistanceToSizeCurve."));
			MetaData->SetValue(NewProp_BaseSizeX, TEXT("Category"), TEXT("MaterialSpriteElement"));
			MetaData->SetValue(NewProp_BaseSizeX, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_BaseSizeX, TEXT("ToolTip"), TEXT("The base width of the sprite, multiplied with the DistanceToSizeCurve."));
			MetaData->SetValue(NewProp_bSizeIsInScreenSpace, TEXT("Category"), TEXT("MaterialSpriteElement"));
			MetaData->SetValue(NewProp_bSizeIsInScreenSpace, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_bSizeIsInScreenSpace, TEXT("ToolTip"), TEXT("Whether the size is defined in screen-space or world-space."));
			MetaData->SetValue(NewProp_DistanceToOpacityCurve, TEXT("Category"), TEXT("MaterialSpriteElement"));
			MetaData->SetValue(NewProp_DistanceToOpacityCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_DistanceToOpacityCurve, TEXT("ToolTip"), TEXT("A curve that maps distance on the X axis to the sprite opacity on the Y axis."));
			MetaData->SetValue(NewProp_Material, TEXT("Category"), TEXT("MaterialSpriteElement"));
			MetaData->SetValue(NewProp_Material, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(NewProp_Material, TEXT("ToolTip"), TEXT("The material that the sprite is rendered with."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMaterialSpriteElement_CRC() { return 522821082U; }
	UFunction* Z_Construct_UFunction_UMaterialBillboardComponent_AddElement()
	{
		struct MaterialBillboardComponent_eventAddElement_Parms
		{
			UMaterialInterface* Material;
			UCurveFloat* DistanceToOpacityCurve;
			bool bSizeIsInScreenSpace;
			float BaseSizeX;
			float BaseSizeY;
			UCurveFloat* DistanceToSizeCurve;
		};
		UObject* Outer=Z_Construct_UClass_UMaterialBillboardComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddElement"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(MaterialBillboardComponent_eventAddElement_Parms));
			UProperty* NewProp_DistanceToSizeCurve = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DistanceToSizeCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DistanceToSizeCurve, MaterialBillboardComponent_eventAddElement_Parms), 0x0000000000000080, Z_Construct_UClass_UCurveFloat_NoRegister());
			UProperty* NewProp_BaseSizeY = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BaseSizeY"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseSizeY, MaterialBillboardComponent_eventAddElement_Parms), 0x0000000000000080);
			UProperty* NewProp_BaseSizeX = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BaseSizeX"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseSizeX, MaterialBillboardComponent_eventAddElement_Parms), 0x0000000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSizeIsInScreenSpace, MaterialBillboardComponent_eventAddElement_Parms, bool);
			UProperty* NewProp_bSizeIsInScreenSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSizeIsInScreenSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSizeIsInScreenSpace, MaterialBillboardComponent_eventAddElement_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSizeIsInScreenSpace, MaterialBillboardComponent_eventAddElement_Parms), sizeof(bool), true);
			UProperty* NewProp_DistanceToOpacityCurve = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DistanceToOpacityCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DistanceToOpacityCurve, MaterialBillboardComponent_eventAddElement_Parms), 0x0000000000000080, Z_Construct_UClass_UCurveFloat_NoRegister());
			UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, MaterialBillboardComponent_eventAddElement_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|MaterialSprite"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds an element to the sprite."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMaterialBillboardComponent_NoRegister()
	{
		return UMaterialBillboardComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UMaterialBillboardComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UMaterialBillboardComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B03080;

				OuterClass->LinkChild(Z_Construct_UFunction_UMaterialBillboardComponent_AddElement());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Elements = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Elements"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Elements, UMaterialBillboardComponent), 0x0000000000000005);
				UProperty* NewProp_Elements_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Elements, TEXT("Elements"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FMaterialSpriteElement());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMaterialBillboardComponent_AddElement()); // 1731365030
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Physics Collision Lighting Mesh PhysicsVolume Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/MaterialBillboardComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A 2d material that will be rendered always facing the camera."));
				MetaData->SetValue(NewProp_Elements, TEXT("Category"), TEXT("Sprite"));
				MetaData->SetValue(NewProp_Elements, TEXT("ModuleRelativePath"), TEXT("Classes/Components/MaterialBillboardComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMaterialBillboardComponent(Z_Construct_UClass_UMaterialBillboardComponent, TEXT("UMaterialBillboardComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMaterialBillboardComponent);
	UFunction* Z_Construct_UDelegateFunction_Engine_ComponentFractureSignature__DelegateSignature()
	{
		struct _Script_Engine_eventComponentFractureSignature_Parms
		{
			FVector HitPoint;
			FVector HitDirection;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ComponentFractureSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventComponentFractureSignature_Parms));
			UProperty* NewProp_HitDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitDirection"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitDirection, _Script_Engine_eventComponentFractureSignature_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_HitPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitPoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitPoint, _Script_Engine_eventComponentFractureSignature_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate for notification when fracture occurs"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDestructibleComponent_ApplyDamage()
	{
		struct DestructibleComponent_eventApplyDamage_Parms
		{
			float DamageAmount;
			FVector HitLocation;
			FVector ImpulseDir;
			float ImpulseStrength;
		};
		UObject* Outer=Z_Construct_UClass_UDestructibleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ApplyDamage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(DestructibleComponent_eventApplyDamage_Parms));
			UProperty* NewProp_ImpulseStrength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpulseStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ImpulseStrength, DestructibleComponent_eventApplyDamage_Parms), 0x0000000000000080);
			UProperty* NewProp_ImpulseDir = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpulseDir"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ImpulseDir, DestructibleComponent_eventApplyDamage_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_HitLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitLocation, DestructibleComponent_eventApplyDamage_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DamageAmount = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageAmount"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DamageAmount, DestructibleComponent_eventApplyDamage_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Destructible"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Take damage"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDestructibleComponent_ApplyRadiusDamage()
	{
		struct DestructibleComponent_eventApplyRadiusDamage_Parms
		{
			float BaseDamage;
			FVector HurtOrigin;
			float DamageRadius;
			float ImpulseStrength;
			bool bFullDamage;
		};
		UObject* Outer=Z_Construct_UClass_UDestructibleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ApplyRadiusDamage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(DestructibleComponent_eventApplyRadiusDamage_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFullDamage, DestructibleComponent_eventApplyRadiusDamage_Parms, bool);
			UProperty* NewProp_bFullDamage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFullDamage"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFullDamage, DestructibleComponent_eventApplyRadiusDamage_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFullDamage, DestructibleComponent_eventApplyRadiusDamage_Parms), sizeof(bool), true);
			UProperty* NewProp_ImpulseStrength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpulseStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ImpulseStrength, DestructibleComponent_eventApplyRadiusDamage_Parms), 0x0000000000000080);
			UProperty* NewProp_DamageRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DamageRadius, DestructibleComponent_eventApplyRadiusDamage_Parms), 0x0000000000000080);
			UProperty* NewProp_HurtOrigin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HurtOrigin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HurtOrigin, DestructibleComponent_eventApplyRadiusDamage_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BaseDamage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BaseDamage"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BaseDamage, DestructibleComponent_eventApplyRadiusDamage_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Destructible"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Take radius damage"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDestructibleComponent_GetDestructibleMesh()
	{
		struct DestructibleComponent_eventGetDestructibleMesh_Parms
		{
			UDestructibleMesh* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UDestructibleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDestructibleMesh"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DestructibleComponent_eventGetDestructibleMesh_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, DestructibleComponent_eventGetDestructibleMesh_Parms), 0x0000000000000580, Z_Construct_UClass_UDestructibleMesh_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Destructible"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UDestructibleComponent_SetDestructibleMesh()
	{
		struct DestructibleComponent_eventSetDestructibleMesh_Parms
		{
			UDestructibleMesh* NewMesh;
		};
		UObject* Outer=Z_Construct_UClass_UDestructibleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetDestructibleMesh"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(DestructibleComponent_eventSetDestructibleMesh_Parms));
			UProperty* NewProp_NewMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewMesh, DestructibleComponent_eventSetDestructibleMesh_Parms), 0x0000000000000080, Z_Construct_UClass_UDestructibleMesh_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Destructible"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UDestructibleComponent_NoRegister()
	{
		return UDestructibleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UDestructibleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USkinnedMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UDestructibleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UDestructibleComponent_ApplyDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_UDestructibleComponent_ApplyRadiusDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_UDestructibleComponent_GetDestructibleMesh());
				OuterClass->LinkChild(Z_Construct_UFunction_UDestructibleComponent_SetDestructibleMesh());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnComponentFracture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnComponentFracture"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnComponentFracture, UDestructibleComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ComponentFractureSignature__DelegateSignature());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_DestructibleMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DestructibleMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DestructibleMesh, UDestructibleComponent), 0x0000000800002005, Z_Construct_UClass_UDestructibleMesh_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_LargeChunkThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LargeChunkThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LargeChunkThreshold, UDestructibleComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableHardSleeping, UDestructibleComponent, bool);
				UProperty* NewProp_bEnableHardSleeping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableHardSleeping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableHardSleeping, UDestructibleComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnableHardSleeping, UDestructibleComponent), sizeof(bool), true);
				UProperty* NewProp_FractureEffects = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FractureEffects"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(FractureEffects, UDestructibleComponent), 0x0000000000000055);
				UProperty* NewProp_FractureEffects_Inner = new(EC_InternalUseOnlyConstructor, NewProp_FractureEffects, TEXT("FractureEffects"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FFractureEffect());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFractureEffectOverride, UDestructibleComponent, uint8);
				UProperty* NewProp_bFractureEffectOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFractureEffectOverride"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFractureEffectOverride, UDestructibleComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bFractureEffectOverride, UDestructibleComponent), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDestructibleComponent_ApplyDamage()); // 552803497
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDestructibleComponent_ApplyRadiusDamage()); // 706560862
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDestructibleComponent_GetDestructibleMesh()); // 2128083421
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDestructibleComponent_SetDestructibleMesh()); // 1766406925
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mesh Components|SkinnedMesh Mirroring Activation Components|Activation Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/DestructibleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("This component holds the physics data for a DestructibleActor.\n\nThe USkeletalMesh pointer in the base class (SkinnedMeshComponent) MUST be a DestructibleMesh"));
				MetaData->SetValue(NewProp_OnComponentFracture, TEXT("Category"), TEXT("Components|Destructible"));
				MetaData->SetValue(NewProp_OnComponentFracture, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(NewProp_OnComponentFracture, TEXT("ToolTip"), TEXT("Called when a component is touched"));
				MetaData->SetValue(NewProp_DestructibleMesh, TEXT("Category"), TEXT("DestructibleComponent"));
				MetaData->SetValue(NewProp_DestructibleMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(NewProp_DestructibleMesh, TEXT("ToolTip"), TEXT("Provide a blueprint interface for setting the destructible mesh"));
				MetaData->SetValue(NewProp_LargeChunkThreshold, TEXT("Category"), TEXT("DestructibleComponent"));
				MetaData->SetValue(NewProp_LargeChunkThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(NewProp_LargeChunkThreshold, TEXT("ToolTip"), TEXT("The minimum size required to treat chunks as Large."));
				MetaData->SetValue(NewProp_bEnableHardSleeping, TEXT("Category"), TEXT("DestructibleComponent"));
				MetaData->SetValue(NewProp_bEnableHardSleeping, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(NewProp_bEnableHardSleeping, TEXT("ToolTip"), TEXT("Enable \"hard sleeping\" for destruction-generated PxActors.  This means that they turn kinematic\nwhen they sleep, but can be made dynamic again by application of enough damage."));
				MetaData->SetValue(NewProp_FractureEffects, TEXT("Category"), TEXT("DestructibleComponent"));
				MetaData->SetValue(NewProp_FractureEffects, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(NewProp_FractureEffects, TEXT("ToolTip"), TEXT("Fracture effects for each fracture level. Used only if Fracture Effect Override is set."));
				MetaData->SetValue(NewProp_bFractureEffectOverride, TEXT("Category"), TEXT("DestructibleComponent"));
				MetaData->SetValue(NewProp_bFractureEffectOverride, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DestructibleComponent.h"));
				MetaData->SetValue(NewProp_bFractureEffectOverride, TEXT("ToolTip"), TEXT("If set, use this actor's fracture effects instead of the asset's fracture effects."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UDestructibleComponent(Z_Construct_UClass_UDestructibleComponent, TEXT("UDestructibleComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UDestructibleComponent);
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneLocationByName()
	{
		struct PoseableMeshComponent_eventGetBoneLocationByName_Parms
		{
			FName BoneName;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneLocationByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventGetBoneLocationByName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PoseableMeshComponent_eventGetBoneLocationByName_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventGetBoneLocationByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventGetBoneLocationByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneRotationByName()
	{
		struct PoseableMeshComponent_eventGetBoneRotationByName_Parms
		{
			FName BoneName;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneRotationByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventGetBoneRotationByName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PoseableMeshComponent_eventGetBoneRotationByName_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventGetBoneRotationByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventGetBoneRotationByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneScaleByName()
	{
		struct PoseableMeshComponent_eventGetBoneScaleByName_Parms
		{
			FName BoneName;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneScaleByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventGetBoneScaleByName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PoseableMeshComponent_eventGetBoneScaleByName_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventGetBoneScaleByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventGetBoneScaleByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_GetBoneTransformByName()
	{
		struct PoseableMeshComponent_eventGetBoneTransformByName_Parms
		{
			FName BoneName;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneTransformByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventGetBoneTransformByName_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, PoseableMeshComponent_eventGetBoneTransformByName_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventGetBoneTransformByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventGetBoneTransformByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_ResetBoneTransformByName()
	{
		struct PoseableMeshComponent_eventResetBoneTransformByName_Parms
		{
			FName BoneName;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ResetBoneTransformByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(PoseableMeshComponent_eventResetBoneTransformByName_Parms));
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventResetBoneTransformByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneLocationByName()
	{
		struct PoseableMeshComponent_eventSetBoneLocationByName_Parms
		{
			FName BoneName;
			FVector InLocation;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoneLocationByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventSetBoneLocationByName_Parms));
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventSetBoneLocationByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_InLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InLocation, PoseableMeshComponent_eventSetBoneLocationByName_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventSetBoneLocationByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneRotationByName()
	{
		struct PoseableMeshComponent_eventSetBoneRotationByName_Parms
		{
			FName BoneName;
			FRotator InRotation;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoneRotationByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventSetBoneRotationByName_Parms));
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventSetBoneRotationByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_InRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InRotation, PoseableMeshComponent_eventSetBoneRotationByName_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventSetBoneRotationByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneScaleByName()
	{
		struct PoseableMeshComponent_eventSetBoneScaleByName_Parms
		{
			FName BoneName;
			FVector InScale3D;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoneScaleByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(PoseableMeshComponent_eventSetBoneScaleByName_Parms));
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventSetBoneScaleByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_InScale3D = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InScale3D"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InScale3D, PoseableMeshComponent_eventSetBoneScaleByName_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventSetBoneScaleByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UPoseableMeshComponent_SetBoneTransformByName()
	{
		struct PoseableMeshComponent_eventSetBoneTransformByName_Parms
		{
			FName BoneName;
			FTransform InTransform;
			TEnumAsByte<EBoneSpaces::Type> BoneSpace;
		};
		UObject* Outer=Z_Construct_UClass_UPoseableMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoneTransformByName"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(PoseableMeshComponent_eventSetBoneTransformByName_Parms));
			UProperty* NewProp_BoneSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneSpace"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BoneSpace, PoseableMeshComponent_eventSetBoneTransformByName_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EBoneSpaces());
			UProperty* NewProp_InTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InTransform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InTransform, PoseableMeshComponent_eventSetBoneTransformByName_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(BoneName, PoseableMeshComponent_eventSetBoneTransformByName_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|PoseableMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UPoseableMeshComponent_NoRegister()
	{
		return UPoseableMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPoseableMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USkinnedMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPoseableMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneLocationByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneRotationByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneScaleByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneTransformByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_ResetBoneTransformByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneLocationByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneRotationByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneScaleByName());
				OuterClass->LinkChild(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneTransformByName());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneLocationByName()); // 4275668424
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneRotationByName()); // 2763722735
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneScaleByName()); // 4077252085
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_GetBoneTransformByName()); // 421559257
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_ResetBoneTransformByName()); // 2126866654
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneLocationByName()); // 2914917909
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneRotationByName()); // 1487606226
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneScaleByName()); // 2766611100
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UPoseableMeshComponent_SetBoneTransformByName()); // 1220102765
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Physics Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PoseableMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PoseableMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("UPoseableMeshComponent that allows bone transforms to be driven by blueprint."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPoseableMeshComponent(Z_Construct_UClass_UPoseableMeshComponent, TEXT("UPoseableMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPoseableMeshComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FStaticMeshComponentLODInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FStaticMeshComponentLODInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("StaticMeshComponentLODInfo"), sizeof(FStaticMeshComponentLODInfo), Get_Z_Construct_UScriptStruct_FStaticMeshComponentLODInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StaticMeshComponentLODInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FStaticMeshComponentLODInfo>, EStructFlags(0x00000001));
			UProperty* NewProp_PaintedVertices = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PaintedVertices"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(PaintedVertices, FStaticMeshComponentLODInfo), 0x0000000000000000);
			UProperty* NewProp_PaintedVertices_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PaintedVertices, TEXT("PaintedVertices"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FPaintedVertex());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(NewProp_PaintedVertices, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(NewProp_PaintedVertices, TEXT("ToolTip"), TEXT("Vertex data cached at the time this LOD was painted, if any"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FStaticMeshComponentLODInfo_CRC() { return 590875140U; }
	UScriptStruct* Z_Construct_UScriptStruct_FPaintedVertex()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FPaintedVertex_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("PaintedVertex"), sizeof(FPaintedVertex), Get_Z_Construct_UScriptStruct_FPaintedVertex_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PaintedVertex"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FPaintedVertex>, EStructFlags(0x00000001));
			UProperty* NewProp_Color = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Color"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Color, FPaintedVertex), 0x0000000000000000, Z_Construct_UScriptStruct_FColor());
			UProperty* NewProp_Normal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Normal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Normal, FPaintedVertex), 0x0000000000000000, Z_Construct_UScriptStruct_FPackedNormal());
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Position, FPaintedVertex), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Cached vertex information at the time the mesh was painted."));
			MetaData->SetValue(NewProp_Color, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(NewProp_Normal, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPaintedVertex_CRC() { return 140777997U; }
	UFunction* Z_Construct_UFunction_UStaticMeshComponent_GetLocalBounds()
	{
		struct StaticMeshComponent_eventGetLocalBounds_Parms
		{
			FVector Min;
			FVector Max;
		};
		UObject* Outer=Z_Construct_UClass_UStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLocalBounds"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(StaticMeshComponent_eventGetLocalBounds_Parms));
			UProperty* NewProp_Max = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Max"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Max, StaticMeshComponent_eventGetLocalBounds_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Min = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Min"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Min, StaticMeshComponent_eventGetLocalBounds_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|StaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get Local bounds"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UStaticMeshComponent_OnRep_StaticMesh()
	{
		struct StaticMeshComponent_eventOnRep_StaticMesh_Parms
		{
			UStaticMesh* OldStaticMesh;
		};
		UObject* Outer=Z_Construct_UClass_UStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_StaticMesh"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020401, 65535, sizeof(StaticMeshComponent_eventOnRep_StaticMesh_Parms));
			UProperty* NewProp_OldStaticMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldStaticMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OldStaticMesh, StaticMeshComponent_eventOnRep_StaticMesh_Parms), 0x0000000000000080, Z_Construct_UClass_UStaticMesh_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UStaticMeshComponent_SetForcedLodModel()
	{
		struct StaticMeshComponent_eventSetForcedLodModel_Parms
		{
			int32 NewForcedLodModel;
		};
		UObject* Outer=Z_Construct_UClass_UStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetForcedLodModel"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(StaticMeshComponent_eventSetForcedLodModel_Parms));
			UProperty* NewProp_NewForcedLodModel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewForcedLodModel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NewForcedLodModel, StaticMeshComponent_eventSetForcedLodModel_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|LOD"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UStaticMeshComponent_SetStaticMesh()
	{
		struct StaticMeshComponent_eventSetStaticMesh_Parms
		{
			UStaticMesh* NewMesh;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStaticMesh"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(StaticMeshComponent_eventSetStaticMesh_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, StaticMeshComponent_eventSetStaticMesh_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, StaticMeshComponent_eventSetStaticMesh_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, StaticMeshComponent_eventSetStaticMesh_Parms), sizeof(bool), true);
			UProperty* NewProp_NewMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewMesh, StaticMeshComponent_eventSetStaticMesh_Parms), 0x0000000000000080, Z_Construct_UClass_UStaticMesh_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|StaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the StaticMesh used by this instance."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UStaticMeshComponent_NoRegister()
	{
		return UStaticMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UStaticMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UStaticMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UStaticMeshComponent_GetLocalBounds());
				OuterClass->LinkChild(Z_Construct_UFunction_UStaticMeshComponent_OnRep_StaticMesh());
				OuterClass->LinkChild(Z_Construct_UFunction_UStaticMeshComponent_SetForcedLodModel());
				OuterClass->LinkChild(Z_Construct_UFunction_UStaticMeshComponent_SetStaticMesh());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LightmassSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightmassSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightmassSettings, UStaticMeshComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FLightmassPrimitiveSettings());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_StaticMeshDerivedDataKey = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StaticMeshDerivedDataKey"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(StaticMeshDerivedDataKey, UStaticMeshComponent), 0x0000000800000000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_LODData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODData"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LODData, UStaticMeshComponent), 0x0000000000002000);
				UProperty* NewProp_LODData_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LODData, TEXT("LODData"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FStaticMeshComponentLODInfo());
				UProperty* NewProp_IrrelevantLights = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IrrelevantLights"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(IrrelevantLights, UStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_IrrelevantLights_Inner = new(EC_InternalUseOnlyConstructor, NewProp_IrrelevantLights, TEXT("IrrelevantLights"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FGuid());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseSubDivisions, UStaticMeshComponent, uint8);
				UProperty* NewProp_bUseSubDivisions = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseSubDivisions"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseSubDivisions, UStaticMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUseSubDivisions, UStaticMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_SubDivisionStepSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SubDivisionStepSize"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SubDivisionStepSize, UStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_StreamingDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StreamingDistanceMultiplier"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StreamingDistanceMultiplier, UStaticMeshComponent), 0x0000040000000005);
				UProperty* NewProp_OverriddenLightMapRes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OverriddenLightMapRes"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OverriddenLightMapRes, UStaticMeshComponent), 0x0000000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideLightMapRes, UStaticMeshComponent, uint8);
				UProperty* NewProp_bOverrideLightMapRes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideLightMapRes"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideLightMapRes, UStaticMeshComponent), 0x0000000000000014, CPP_BOOL_PROPERTY_BITMASK(bOverrideLightMapRes, UStaticMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreInstanceForTextureStreaming, UStaticMeshComponent, uint8);
				UProperty* NewProp_bIgnoreInstanceForTextureStreaming = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreInstanceForTextureStreaming"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreInstanceForTextureStreaming, UStaticMeshComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bIgnoreInstanceForTextureStreaming, UStaticMeshComponent), sizeof(uint8), false);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_SelectedEditorSection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SelectedEditorSection"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SelectedEditorSection, UStaticMeshComponent), 0x0000000800002000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_WireframeColorOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WireframeColorOverride"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WireframeColorOverride, UStaticMeshComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FColor());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideWireframeColor, UStaticMeshComponent, bool);
				UProperty* NewProp_bOverrideWireframeColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideWireframeColor"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideWireframeColor, UStaticMeshComponent), 0x0000000000000014, CPP_BOOL_PROPERTY_BITMASK(bOverrideWireframeColor, UStaticMeshComponent), sizeof(bool), true);
				UProperty* NewProp_StaticMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StaticMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(StaticMesh, UStaticMeshComponent), 0x0000000100000035, Z_Construct_UClass_UStaticMesh_NoRegister());
				NewProp_StaticMesh->RepNotifyFunc = FName(TEXT("OnRep_StaticMesh"));
				UProperty* NewProp_MinLOD = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinLOD"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(MinLOD, UStaticMeshComponent), 0x0000040000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMinLOD, UStaticMeshComponent, bool);
				UProperty* NewProp_bOverrideMinLOD = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideMinLOD"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMinLOD, UStaticMeshComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bOverrideMinLOD, UStaticMeshComponent), sizeof(bool), true);
				UProperty* NewProp_PreviousLODLevel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviousLODLevel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PreviousLODLevel, UStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_ForcedLodModel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ForcedLodModel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ForcedLodModel, UStaticMeshComponent), 0x0000040000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UStaticMeshComponent_GetLocalBounds()); // 1601319227
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UStaticMeshComponent_OnRep_StaticMesh()); // 4104746733
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UStaticMeshComponent_SetForcedLodModel()); // 1781922907
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UStaticMeshComponent_SetStaticMesh()); // 1375159169
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering Common"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/StaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("StaticMeshComponent is used to create an instance of a UStaticMesh.\nA static mesh is a piece of geometry that consists of a static set of polygons.\n\n@see https://docs.unrealengine.com/latest/INT/Engine/Content/Types/StaticMeshes/\n@see UStaticMesh"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ToolTip"), TEXT("The Lightmass settings for this object."));
				MetaData->SetValue(NewProp_StaticMeshDerivedDataKey, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_StaticMeshDerivedDataKey, TEXT("ToolTip"), TEXT("Derived data key of the static mesh, used to determine if an update from the source static mesh is required."));
				MetaData->SetValue(NewProp_LODData, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_LODData, TEXT("ToolTip"), TEXT("Static mesh LOD data.  Contains static lighting data along with instanced mesh vertex colors."));
				MetaData->SetValue(NewProp_IrrelevantLights, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bUseSubDivisions, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bUseSubDivisions, TEXT("ToolTip"), TEXT("Whether to use subdivisions or just the triangle's vertices."));
				MetaData->SetValue(NewProp_SubDivisionStepSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_SubDivisionStepSize, TEXT("ToolTip"), TEXT("Subdivision step size for static vertex lighting."));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("Category"), TEXT("TextureStreaming"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_StreamingDistanceMultiplier, TEXT("ToolTip"), TEXT("Allows adjusting the desired resolution of streaming textures that uses UV 0.  1.0 is the default, whereas a higher value increases the streamed-in resolution."));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("editcondition"), TEXT("bOverrideLightMapRes"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("ToolTip"), TEXT("Light map resolution to use on this component, used if bOverrideLightMapRes is true"));
				MetaData->SetValue(NewProp_bOverrideLightMapRes, TEXT("Category"), TEXT("Lighting"));
				MetaData->SetValue(NewProp_bOverrideLightMapRes, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bOverrideLightMapRes, TEXT("ToolTip"), TEXT("Whether to override the lightmap resolution defined in the static mesh."));
				MetaData->SetValue(NewProp_bIgnoreInstanceForTextureStreaming, TEXT("Category"), TEXT("TextureStreaming"));
				MetaData->SetValue(NewProp_bIgnoreInstanceForTextureStreaming, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bIgnoreInstanceForTextureStreaming, TEXT("ToolTip"), TEXT("Ignore this instance of this static mesh when calculating streaming information.\nThis can be useful when doing things like applying character textures to static geometry,\nto avoid them using distance-based streaming."));
				MetaData->SetValue(NewProp_SelectedEditorSection, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_SelectedEditorSection, TEXT("ToolTip"), TEXT("The section currently selected in the Editor."));
				MetaData->SetValue(NewProp_WireframeColorOverride, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_WireframeColorOverride, TEXT("editcondition"), TEXT("bOverrideWireframeColor"));
				MetaData->SetValue(NewProp_WireframeColorOverride, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_WireframeColorOverride, TEXT("ToolTip"), TEXT("Wireframe color to use if bOverrideWireframeColor is true"));
				MetaData->SetValue(NewProp_bOverrideWireframeColor, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bOverrideWireframeColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bOverrideWireframeColor, TEXT("ToolTip"), TEXT("If true, WireframeColorOverride will be used. If false, color is determined based on mobility and physics simulation settings"));
				MetaData->SetValue(NewProp_StaticMesh, TEXT("Category"), TEXT("StaticMesh"));
				MetaData->SetValue(NewProp_StaticMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_MinLOD, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_MinLOD, TEXT("editcondition"), TEXT("bOverrideMinLOD"));
				MetaData->SetValue(NewProp_MinLOD, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_MinLOD, TEXT("ToolTip"), TEXT("Specifies the smallest LOD that will be used for this component.\nThis is ignored if ForcedLodModel is enabled."));
				MetaData->SetValue(NewProp_bOverrideMinLOD, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_bOverrideMinLOD, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bOverrideMinLOD, TEXT("ToolTip"), TEXT("Whether to override the MinLOD setting of the static mesh asset with the MinLOD of this component."));
				MetaData->SetValue(NewProp_PreviousLODLevel, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_PreviousLODLevel, TEXT("ToolTip"), TEXT("LOD that was desired for rendering this StaticMeshComponent last frame."));
				MetaData->SetValue(NewProp_ForcedLodModel, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_ForcedLodModel, TEXT("ModuleRelativePath"), TEXT("Classes/Components/StaticMeshComponent.h"));
				MetaData->SetValue(NewProp_ForcedLodModel, TEXT("ToolTip"), TEXT("If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1)."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UStaticMeshComponent(Z_Construct_UClass_UStaticMeshComponent, TEXT("UStaticMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UStaticMeshComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FInstancedStaticMeshMappingInfo()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FInstancedStaticMeshMappingInfo_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("InstancedStaticMeshMappingInfo"), sizeof(FInstancedStaticMeshMappingInfo), Get_Z_Construct_UScriptStruct_FInstancedStaticMeshMappingInfo_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InstancedStaticMeshMappingInfo"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FInstancedStaticMeshMappingInfo>, EStructFlags(0x00000001));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInstancedStaticMeshMappingInfo_CRC() { return 4170346009U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInstancedStaticMeshInstanceData()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FInstancedStaticMeshInstanceData_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("InstancedStaticMeshInstanceData"), sizeof(FInstancedStaticMeshInstanceData), Get_Z_Construct_UScriptStruct_FInstancedStaticMeshInstanceData_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InstancedStaticMeshInstanceData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FInstancedStaticMeshInstanceData>, EStructFlags(0x00000001));
			UProperty* NewProp_ShadowmapUVBias = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ShadowmapUVBias"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ShadowmapUVBias, FInstancedStaticMeshInstanceData), 0x0000000000000000, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_LightmapUVBias = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LightmapUVBias"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightmapUVBias, FInstancedStaticMeshInstanceData), 0x0000000000000000, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_Transform = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Transform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Transform, FInstancedStaticMeshInstanceData), 0x0000000000000001, Z_Construct_UScriptStruct_FMatrix());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_ShadowmapUVBias, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_LightmapUVBias, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_Transform, TEXT("Category"), TEXT("Instances"));
			MetaData->SetValue(NewProp_Transform, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInstancedStaticMeshInstanceData_CRC() { return 327698489U; }
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstance()
	{
		struct InstancedStaticMeshComponent_eventAddInstance_Parms
		{
			FTransform InstanceTransform;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddInstance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(InstancedStaticMeshComponent_eventAddInstance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, InstancedStaticMeshComponent_eventAddInstance_Parms), 0x0000000000000580);
			UProperty* NewProp_InstanceTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstanceTransform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InstanceTransform, InstancedStaticMeshComponent_eventAddInstance_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an instance to this component. Transform is given in local space of this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstanceWorldSpace()
	{
		struct InstancedStaticMeshComponent_eventAddInstanceWorldSpace_Parms
		{
			FTransform WorldTransform;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddInstanceWorldSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(InstancedStaticMeshComponent_eventAddInstanceWorldSpace_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, InstancedStaticMeshComponent_eventAddInstanceWorldSpace_Parms), 0x0000000000000580);
			UProperty* NewProp_WorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldTransform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(WorldTransform, InstancedStaticMeshComponent_eventAddInstanceWorldSpace_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an instance to this component. Transform is given in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_ClearInstances()
	{
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClearInstances"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clear all instances being rendered by this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceCount()
	{
		struct InstancedStaticMeshComponent_eventGetInstanceCount_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInstanceCount"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(InstancedStaticMeshComponent_eventGetInstanceCount_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, InstancedStaticMeshComponent_eventGetInstanceCount_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the number of instances in this component"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstancesOverlappingSphere()
	{
		struct InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms
		{
			FVector Center;
			float Radius;
			bool bSphereInWorldSpace;
			TArray<int32> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInstancesOverlappingSphere"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20400, 65535, sizeof(InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms), 0x0000000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSphereInWorldSpace, InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms, bool);
			UProperty* NewProp_bSphereInWorldSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSphereInWorldSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSphereInWorldSpace, InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bSphereInWorldSpace, InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms), sizeof(bool), true);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms), 0x0000000000000080);
			UProperty* NewProp_Center = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Center"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Center, InstancedStaticMeshComponent_eventGetInstancesOverlappingSphere_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSphereInWorldSpace"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the instances with instance bounds overlapping the specified sphere. The return value is an array of instance indices."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceTransform()
	{
		struct InstancedStaticMeshComponent_eventGetInstanceTransform_Parms
		{
			int32 InstanceIndex;
			FTransform OutInstanceTransform;
			bool bWorldSpace;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInstanceTransform"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(InstancedStaticMeshComponent_eventGetInstanceTransform_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldSpace, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms, bool);
			UProperty* NewProp_bWorldSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldSpace, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldSpace, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms), sizeof(bool), true);
			UProperty* NewProp_OutInstanceTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutInstanceTransform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutInstanceTransform, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_InstanceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstanceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstanceIndex, InstancedStaticMeshComponent_eventGetInstanceTransform_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldSpace"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the transform for the instance specified. Instance is returned in local space of this component unless bWorldSpace is set.  Returns True on success."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_RemoveInstance()
	{
		struct InstancedStaticMeshComponent_eventRemoveInstance_Parms
		{
			int32 InstanceIndex;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveInstance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(InstancedStaticMeshComponent_eventRemoveInstance_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, InstancedStaticMeshComponent_eventRemoveInstance_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, InstancedStaticMeshComponent_eventRemoveInstance_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, InstancedStaticMeshComponent_eventRemoveInstance_Parms), sizeof(bool), true);
			UProperty* NewProp_InstanceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstanceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstanceIndex, InstancedStaticMeshComponent_eventRemoveInstance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Remove the instance specified. Returns True on success."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_SetCullDistances()
	{
		struct InstancedStaticMeshComponent_eventSetCullDistances_Parms
		{
			int32 StartCullDistance;
			int32 EndCullDistance;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCullDistances"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(InstancedStaticMeshComponent_eventSetCullDistances_Parms));
			UProperty* NewProp_EndCullDistance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndCullDistance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EndCullDistance, InstancedStaticMeshComponent_eventSetCullDistances_Parms), 0x0000000000000080);
			UProperty* NewProp_StartCullDistance = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartCullDistance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StartCullDistance, InstancedStaticMeshComponent_eventSetCullDistances_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the fading start and culling end distances for this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UInstancedStaticMeshComponent_UpdateInstanceTransform()
	{
		struct InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms
		{
			int32 InstanceIndex;
			FTransform NewInstanceTransform;
			bool bWorldSpace;
			bool bMarkRenderStateDirty;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UpdateInstanceTransform"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bMarkRenderStateDirty, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms, bool);
			UProperty* NewProp_bMarkRenderStateDirty = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bMarkRenderStateDirty"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bMarkRenderStateDirty, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bMarkRenderStateDirty, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldSpace, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms, bool);
			UProperty* NewProp_bWorldSpace = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldSpace"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldSpace, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldSpace, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), sizeof(bool), true);
			UProperty* NewProp_NewInstanceTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInstanceTransform"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewInstanceTransform, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_InstanceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstanceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstanceIndex, InstancedStaticMeshComponent_eventUpdateInstanceTransform_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bMarkRenderStateDirty"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldSpace"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Update the transform for the instance specified.\n\n@param InstanceIndex                  The index of the instance to update\n@param NewInstanceTransform   The new transform\n@param bWorldSpace                    If true, the new transform interpreted as a World Space transform, otherwise it is interpreted as Local Space\n@param bMarkRenderStateDirty  If true, the change should be visible immediately. If you are updating many instances you should only set this to true for the last instance.\n@return                                               True on success."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UInstancedStaticMeshComponent_NoRegister()
	{
		return UInstancedStaticMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UInstancedStaticMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UStaticMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UInstancedStaticMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstance());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstanceWorldSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_ClearInstances());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceCount());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstancesOverlappingSphere());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_RemoveInstance());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_SetCullDistances());
				OuterClass->LinkChild(Z_Construct_UFunction_UInstancedStaticMeshComponent_UpdateInstanceTransform());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CachedMappings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedMappings"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(CachedMappings, UInstancedStaticMeshComponent), 0x0000480000202000);
				UProperty* NewProp_CachedMappings_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CachedMappings, TEXT("CachedMappings"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInstancedStaticMeshMappingInfo());
				UProperty* NewProp_NumPendingLightmaps = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NumPendingLightmaps"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NumPendingLightmaps, UInstancedStaticMeshComponent), 0x0000480000202000);
				UProperty* NewProp_PhysicsSerializer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PhysicsSerializer"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PhysicsSerializer, UInstancedStaticMeshComponent), 0x0000000000080008, Z_Construct_UClass_UPhysicsSerializer_NoRegister());
				UProperty* NewProp_RemovedInstances = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RemovedInstances"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(RemovedInstances, UInstancedStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_RemovedInstances_Inner = new(EC_InternalUseOnlyConstructor, NewProp_RemovedInstances, TEXT("RemovedInstances"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_InstanceReorderTable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstanceReorderTable"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InstanceReorderTable, UInstancedStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_InstanceReorderTable_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InstanceReorderTable, TEXT("InstanceReorderTable"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_InstanceEndCullDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstanceEndCullDistance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstanceEndCullDistance, UInstancedStaticMeshComponent), 0x0000000000000015);
				UProperty* NewProp_InstanceStartCullDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstanceStartCullDistance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstanceStartCullDistance, UInstancedStaticMeshComponent), 0x0000000000000015);
				UProperty* NewProp_InstancingRandomSeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstancingRandomSeed"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstancingRandomSeed, UInstancedStaticMeshComponent), 0x0000000000000005);
				UProperty* NewProp_PerInstanceSMData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PerInstanceSMData"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(PerInstanceSMData, UInstancedStaticMeshComponent), 0x0000000000202001);
				UProperty* NewProp_PerInstanceSMData_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PerInstanceSMData, TEXT("PerInstanceSMData"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInstancedStaticMeshInstanceData());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstance()); // 485264631
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_AddInstanceWorldSpace()); // 3501303612
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_ClearInstances()); // 472691396
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceCount()); // 3775453508
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstancesOverlappingSphere()); // 2198402503
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_GetInstanceTransform()); // 1373256370
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_RemoveInstance()); // 3066890154
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_SetCullDistances()); // 875126309
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UInstancedStaticMeshComponent_UpdateInstanceTransform()); // 2096711412
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A component that efficiently renders multiple instances of the same StaticMesh."));
				MetaData->SetValue(NewProp_CachedMappings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_CachedMappings, TEXT("ToolTip"), TEXT("The mappings for all the instances of this component"));
				MetaData->SetValue(NewProp_NumPendingLightmaps, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_NumPendingLightmaps, TEXT("ToolTip"), TEXT("Number of pending lightmaps still to be calculated (Apply()'d)"));
				MetaData->SetValue(NewProp_PhysicsSerializer, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PhysicsSerializer, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_PhysicsSerializer, TEXT("ToolTip"), TEXT("Serialization of all the InstanceBodies. Helps speed up physics creation time"));
				MetaData->SetValue(NewProp_RemovedInstances, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_RemovedInstances, TEXT("ToolTip"), TEXT("The render indices of any removed items we should not render."));
				MetaData->SetValue(NewProp_InstanceReorderTable, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_InstanceReorderTable, TEXT("ToolTip"), TEXT("Mapping from PerInstanceSMData order to instance render buffer order. If empty, the PerInstanceSMData order is used."));
				MetaData->SetValue(NewProp_InstanceEndCullDistance, TEXT("Category"), TEXT("Culling"));
				MetaData->SetValue(NewProp_InstanceEndCullDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_InstanceEndCullDistance, TEXT("ToolTip"), TEXT("Distance from camera at which each instance completely fades out"));
				MetaData->SetValue(NewProp_InstanceStartCullDistance, TEXT("Category"), TEXT("Culling"));
				MetaData->SetValue(NewProp_InstanceStartCullDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_InstanceStartCullDistance, TEXT("ToolTip"), TEXT("Distance from camera at which each instance begins to fade out"));
				MetaData->SetValue(NewProp_InstancingRandomSeed, TEXT("Category"), TEXT("InstancedStaticMeshComponent"));
				MetaData->SetValue(NewProp_InstancingRandomSeed, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_InstancingRandomSeed, TEXT("ToolTip"), TEXT("Value used to seed the random number stream that generates random numbers for each of this mesh's instances.\n              The random number is stored in a buffer accessible to materials through the PerInstanceRandom expression.  If\n              this is set to zero (default), it will be populated automatically by the editor"));
				MetaData->SetValue(NewProp_PerInstanceSMData, TEXT("Category"), TEXT("Instances"));
				MetaData->SetValue(NewProp_PerInstanceSMData, TEXT("DisplayName"), TEXT("Instances"));
				MetaData->SetValue(NewProp_PerInstanceSMData, TEXT("MakeEditWidget"), TEXT("TRUE"));
				MetaData->SetValue(NewProp_PerInstanceSMData, TEXT("ModuleRelativePath"), TEXT("Classes/Components/InstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_PerInstanceSMData, TEXT("ToolTip"), TEXT("Array of instances, bulk serialized"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UInstancedStaticMeshComponent(Z_Construct_UClass_UInstancedStaticMeshComponent, TEXT("UInstancedStaticMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UInstancedStaticMeshComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FClusterNode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FClusterNode_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ClusterNode"), sizeof(FClusterNode), Get_Z_Construct_UScriptStruct_FClusterNode_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClusterNode"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FClusterNode>, EStructFlags(0x00000001));
			UProperty* NewProp_LastInstance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LastInstance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(LastInstance, FClusterNode), 0x0000000000000000);
			UProperty* NewProp_FirstInstance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FirstInstance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(FirstInstance, FClusterNode), 0x0000000000000000);
			UProperty* NewProp_LastChild = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LastChild"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(LastChild, FClusterNode), 0x0000000000000000);
			UProperty* NewProp_BoundMax = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoundMax"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BoundMax, FClusterNode), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FirstChild = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FirstChild"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(FirstChild, FClusterNode), 0x0000000000000000);
			UProperty* NewProp_BoundMin = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoundMin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BoundMin, FClusterNode), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_LastInstance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_FirstInstance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_LastChild, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_BoundMax, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_FirstChild, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(NewProp_BoundMin, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FClusterNode_CRC() { return 3347623199U; }
	UFunction* Z_Construct_UFunction_UHierarchicalInstancedStaticMeshComponent_RemoveInstances()
	{
		struct HierarchicalInstancedStaticMeshComponent_eventRemoveInstances_Parms
		{
			TArray<int32> InstancesToRemove;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveInstances"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(HierarchicalInstancedStaticMeshComponent_eventRemoveInstances_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, HierarchicalInstancedStaticMeshComponent_eventRemoveInstances_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, HierarchicalInstancedStaticMeshComponent_eventRemoveInstances_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, HierarchicalInstancedStaticMeshComponent_eventRemoveInstances_Parms), sizeof(bool), true);
			UProperty* NewProp_InstancesToRemove = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstancesToRemove"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InstancesToRemove, HierarchicalInstancedStaticMeshComponent_eventRemoveInstances_Parms), 0x0000000008000182);
			UProperty* NewProp_InstancesToRemove_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InstancesToRemove, TEXT("InstancesToRemove"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|InstancedStaticMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Removes all the instances with indices specified in the InstancesToRemove array. Returns true on success."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent_NoRegister()
	{
		return UHierarchicalInstancedStaticMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UInstancedStaticMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UHierarchicalInstancedStaticMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UHierarchicalInstancedStaticMeshComponent_RemoveInstances());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableCollision, UHierarchicalInstancedStaticMeshComponent, bool);
				UProperty* NewProp_bDisableCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableCollision"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableCollision, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDisableCollision, UHierarchicalInstancedStaticMeshComponent), sizeof(bool), true);
				UProperty* NewProp_OcclusionLayerNumNodes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OcclusionLayerNumNodes"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OcclusionLayerNumNodes, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_UnbuiltInstanceBoundsList = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UnbuiltInstanceBoundsList"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(UnbuiltInstanceBoundsList, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_UnbuiltInstanceBoundsList_Inner = new(EC_InternalUseOnlyConstructor, NewProp_UnbuiltInstanceBoundsList, TEXT("UnbuiltInstanceBoundsList"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FBox());
				UProperty* NewProp_UnbuiltInstanceBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UnbuiltInstanceBounds"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(UnbuiltInstanceBounds, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FBox());
				UProperty* NewProp_BuiltInstanceBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BuiltInstanceBounds"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BuiltInstanceBounds, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FBox());
				UProperty* NewProp_NumBuiltInstances = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NumBuiltInstances"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NumBuiltInstances, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_SortedInstances = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SortedInstances"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SortedInstances, UHierarchicalInstancedStaticMeshComponent), 0x0000000000000000);
				UProperty* NewProp_SortedInstances_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SortedInstances, TEXT("SortedInstances"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UHierarchicalInstancedStaticMeshComponent_RemoveInstances()); // 1626798777
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_bDisableCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_OcclusionLayerNumNodes, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_OcclusionLayerNumNodes, TEXT("ToolTip"), TEXT("The number of nodes in the occlusion layer"));
				MetaData->SetValue(NewProp_UnbuiltInstanceBoundsList, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_UnbuiltInstanceBoundsList, TEXT("ToolTip"), TEXT("Bounds of each individual unbuilt instance, used for LOD calculation"));
				MetaData->SetValue(NewProp_UnbuiltInstanceBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_UnbuiltInstanceBounds, TEXT("ToolTip"), TEXT("Bounding box of any unbuilt instances"));
				MetaData->SetValue(NewProp_BuiltInstanceBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_BuiltInstanceBounds, TEXT("ToolTip"), TEXT("Bounding box of any built instances (cached from the ClusterTree)"));
				MetaData->SetValue(NewProp_NumBuiltInstances, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_NumBuiltInstances, TEXT("ToolTip"), TEXT("The number of instances in the ClusterTree. Subsequent instances will always be rendered."));
				MetaData->SetValue(NewProp_SortedInstances, TEXT("ModuleRelativePath"), TEXT("Classes/Components/HierarchicalInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_SortedInstances, TEXT("ToolTip"), TEXT("Table for remaping instances from cluster tree to PerInstanceSMData order"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UHierarchicalInstancedStaticMeshComponent(Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent, TEXT("UHierarchicalInstancedStaticMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UHierarchicalInstancedStaticMeshComponent);
	UEnum* Z_Construct_UEnum_Engine_ESplineMeshAxis()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESplineMeshAxis_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESplineMeshAxis"), 0, Get_Z_Construct_UEnum_Engine_ESplineMeshAxis_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESplineMeshAxis"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineMeshAxis::X")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineMeshAxis::Y")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineMeshAxis::Z")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESplineMeshAxis::ESplineMeshAxis_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESplineMeshAxis_CRC() { return 3254003879U; }
	UScriptStruct* Z_Construct_UScriptStruct_FSplineMeshParams()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FSplineMeshParams_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("SplineMeshParams"), sizeof(FSplineMeshParams), Get_Z_Construct_UScriptStruct_FSplineMeshParams_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SplineMeshParams"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FSplineMeshParams>, EStructFlags(0x00000001));
			UProperty* NewProp_EndOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndOffset, FSplineMeshParams), 0x0000040000000001, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_EndRoll = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndRoll"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(EndRoll, FSplineMeshParams), 0x0000040000000001);
			UProperty* NewProp_EndScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndScale, FSplineMeshParams), 0x0000040000000001, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_EndTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndTangent, FSplineMeshParams), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EndPos = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndPos"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndPos, FSplineMeshParams), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_StartOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartOffset, FSplineMeshParams), 0x0000040000000001, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_StartRoll = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartRoll"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartRoll, FSplineMeshParams), 0x0000040000000001);
			UProperty* NewProp_StartScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartScale, FSplineMeshParams), 0x0000040000000001, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_StartTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartTangent, FSplineMeshParams), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_StartPos = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartPos"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartPos, FSplineMeshParams), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Structure that holds info about spline, passed to renderer to deform UStaticMesh.\nAlso used by Lightmass, so be sure to update Lightmass::FSplineMeshParams and the static lighting code if this changes!"));
			MetaData->SetValue(NewProp_EndOffset, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_EndOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_EndOffset, TEXT("ToolTip"), TEXT("Ending offset of the mesh from the spline, in component space."));
			MetaData->SetValue(NewProp_EndRoll, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_EndRoll, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_EndRoll, TEXT("ToolTip"), TEXT("Roll around spline applied at end."));
			MetaData->SetValue(NewProp_EndScale, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_EndScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_EndScale, TEXT("ToolTip"), TEXT("X and Y scale applied to mesh at end of spline."));
			MetaData->SetValue(NewProp_EndTangent, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_EndTangent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_EndTangent, TEXT("ToolTip"), TEXT("End tangent of spline, in component space."));
			MetaData->SetValue(NewProp_EndPos, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_EndPos, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_EndPos, TEXT("ToolTip"), TEXT("End location of spline, in component space."));
			MetaData->SetValue(NewProp_StartOffset, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_StartOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_StartOffset, TEXT("ToolTip"), TEXT("Starting offset of the mesh from the spline, in component space."));
			MetaData->SetValue(NewProp_StartRoll, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_StartRoll, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_StartRoll, TEXT("ToolTip"), TEXT("Roll around spline applied at start"));
			MetaData->SetValue(NewProp_StartScale, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_StartScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_StartScale, TEXT("ToolTip"), TEXT("X and Y scale applied to mesh at start of spline."));
			MetaData->SetValue(NewProp_StartTangent, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_StartTangent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_StartTangent, TEXT("ToolTip"), TEXT("Start tangent of spline, in component space."));
			MetaData->SetValue(NewProp_StartPos, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(NewProp_StartPos, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(NewProp_StartPos, TEXT("ToolTip"), TEXT("Start location of spline, in component space."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSplineMeshParams_CRC() { return 3713112267U; }
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMax()
	{
		struct SplineMeshComponent_eventGetBoundaryMax_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoundaryMax"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineMeshComponent_eventGetBoundaryMax_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetBoundaryMax_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the boundary max"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMin()
	{
		struct SplineMeshComponent_eventGetBoundaryMin_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoundaryMin"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineMeshComponent_eventGetBoundaryMin_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetBoundaryMin_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the boundary min"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndOffset()
	{
		struct SplineMeshComponent_eventGetEndOffset_Parms
		{
			FVector2D ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEndOffset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetEndOffset_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetEndOffset_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the end offset"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndPosition()
	{
		struct SplineMeshComponent_eventGetEndPosition_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEndPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetEndPosition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetEndPosition_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the end position of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndRoll()
	{
		struct SplineMeshComponent_eventGetEndRoll_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEndRoll"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineMeshComponent_eventGetEndRoll_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetEndRoll_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the end roll"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndScale()
	{
		struct SplineMeshComponent_eventGetEndScale_Parms
		{
			FVector2D ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEndScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetEndScale_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetEndScale_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the end scaling"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetEndTangent()
	{
		struct SplineMeshComponent_eventGetEndTangent_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEndTangent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetEndTangent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetEndTangent_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the end tangent vector of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetForwardAxis()
	{
		struct SplineMeshComponent_eventGetForwardAxis_Parms
		{
			TEnumAsByte<ESplineMeshAxis::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetForwardAxis"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineMeshComponent_eventGetForwardAxis_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetForwardAxis_Parms), 0x0000000000000580, Z_Construct_UEnum_Engine_ESplineMeshAxis());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the forward axis"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetSplineUpDir()
	{
		struct SplineMeshComponent_eventGetSplineUpDir_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSplineUpDir"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetSplineUpDir_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetSplineUpDir_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the spline up direction"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartOffset()
	{
		struct SplineMeshComponent_eventGetStartOffset_Parms
		{
			FVector2D ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStartOffset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetStartOffset_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetStartOffset_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the start offset"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartPosition()
	{
		struct SplineMeshComponent_eventGetStartPosition_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStartPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetStartPosition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetStartPosition_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the start position of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartRoll()
	{
		struct SplineMeshComponent_eventGetStartRoll_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStartRoll"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SplineMeshComponent_eventGetStartRoll_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetStartRoll_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the start roll"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartScale()
	{
		struct SplineMeshComponent_eventGetStartScale_Parms
		{
			FVector2D ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStartScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetStartScale_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetStartScale_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the start scaling"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_GetStartTangent()
	{
		struct SplineMeshComponent_eventGetStartTangent_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStartTangent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(SplineMeshComponent_eventGetStartTangent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SplineMeshComponent_eventGetStartTangent_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the start tangent vector of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMax()
	{
		struct SplineMeshComponent_eventSetBoundaryMax_Parms
		{
			float InBoundaryMax;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoundaryMax"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineMeshComponent_eventSetBoundaryMax_Parms));
			UProperty* NewProp_InBoundaryMax = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoundaryMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InBoundaryMax, SplineMeshComponent_eventSetBoundaryMax_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the boundary max"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMin()
	{
		struct SplineMeshComponent_eventSetBoundaryMin_Parms
		{
			float InBoundaryMin;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoundaryMin"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineMeshComponent_eventSetBoundaryMin_Parms));
			UProperty* NewProp_InBoundaryMin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoundaryMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InBoundaryMin, SplineMeshComponent_eventSetBoundaryMin_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the boundary min"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndOffset()
	{
		struct SplineMeshComponent_eventSetEndOffset_Parms
		{
			FVector2D EndOffset;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEndOffset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetEndOffset_Parms));
			UProperty* NewProp_EndOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndOffset, SplineMeshComponent_eventSetEndOffset_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the end offset"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndPosition()
	{
		struct SplineMeshComponent_eventSetEndPosition_Parms
		{
			FVector EndPos;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEndPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetEndPosition_Parms));
			UProperty* NewProp_EndPos = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndPos"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndPos, SplineMeshComponent_eventSetEndPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the end position of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndRoll()
	{
		struct SplineMeshComponent_eventSetEndRoll_Parms
		{
			float EndRoll;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEndRoll"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineMeshComponent_eventSetEndRoll_Parms));
			UProperty* NewProp_EndRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndRoll"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(EndRoll, SplineMeshComponent_eventSetEndRoll_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the end roll"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndScale()
	{
		struct SplineMeshComponent_eventSetEndScale_Parms
		{
			FVector2D EndScale;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEndScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetEndScale_Parms));
			UProperty* NewProp_EndScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndScale, SplineMeshComponent_eventSetEndScale_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_EndScale"), TEXT("(X=1.000,Y=1.000)"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the end scaling"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetEndTangent()
	{
		struct SplineMeshComponent_eventSetEndTangent_Parms
		{
			FVector EndTangent;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEndTangent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetEndTangent_Parms));
			UProperty* NewProp_EndTangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndTangent, SplineMeshComponent_eventSetEndTangent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the end tangent vector of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetForwardAxis()
	{
		struct SplineMeshComponent_eventSetForwardAxis_Parms
		{
			TEnumAsByte<ESplineMeshAxis::Type> InForwardAxis;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetForwardAxis"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineMeshComponent_eventSetForwardAxis_Parms));
			UProperty* NewProp_InForwardAxis = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InForwardAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(InForwardAxis, SplineMeshComponent_eventSetForwardAxis_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ESplineMeshAxis());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the forward axis"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetSplineUpDir()
	{
		struct SplineMeshComponent_eventSetSplineUpDir_Parms
		{
			FVector InSplineUpDir;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSplineUpDir"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(SplineMeshComponent_eventSetSplineUpDir_Parms));
			UProperty* NewProp_InSplineUpDir = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSplineUpDir"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InSplineUpDir, SplineMeshComponent_eventSetSplineUpDir_Parms), 0x0000000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the spline up direction"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartAndEnd()
	{
		struct SplineMeshComponent_eventSetStartAndEnd_Parms
		{
			FVector StartPos;
			FVector StartTangent;
			FVector EndPos;
			FVector EndTangent;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartAndEnd"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetStartAndEnd_Parms));
			UProperty* NewProp_EndTangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndTangent, SplineMeshComponent_eventSetStartAndEnd_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EndPos = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndPos"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(EndPos, SplineMeshComponent_eventSetStartAndEnd_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_StartTangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartTangent, SplineMeshComponent_eventSetStartAndEnd_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_StartPos = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartPos"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartPos, SplineMeshComponent_eventSetStartAndEnd_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the start and end, position and tangent, all in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartOffset()
	{
		struct SplineMeshComponent_eventSetStartOffset_Parms
		{
			FVector2D StartOffset;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartOffset"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetStartOffset_Parms));
			UProperty* NewProp_StartOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartOffset, SplineMeshComponent_eventSetStartOffset_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the start offset"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartPosition()
	{
		struct SplineMeshComponent_eventSetStartPosition_Parms
		{
			FVector StartPos;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetStartPosition_Parms));
			UProperty* NewProp_StartPos = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartPos"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartPos, SplineMeshComponent_eventSetStartPosition_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the start position of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartRoll()
	{
		struct SplineMeshComponent_eventSetStartRoll_Parms
		{
			float StartRoll;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartRoll"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SplineMeshComponent_eventSetStartRoll_Parms));
			UProperty* NewProp_StartRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartRoll"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartRoll, SplineMeshComponent_eventSetStartRoll_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the start roll"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartScale()
	{
		struct SplineMeshComponent_eventSetStartScale_Parms
		{
			FVector2D StartScale;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetStartScale_Parms));
			UProperty* NewProp_StartScale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartScale, SplineMeshComponent_eventSetStartScale_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_StartScale"), TEXT("(X=1.000,Y=1.000)"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the start scaling"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USplineMeshComponent_SetStartTangent()
	{
		struct SplineMeshComponent_eventSetStartTangent_Parms
		{
			FVector StartTangent;
		};
		UObject* Outer=Z_Construct_UClass_USplineMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStartTangent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(SplineMeshComponent_eventSetStartTangent_Parms));
			UProperty* NewProp_StartTangent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartTangent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StartTangent, SplineMeshComponent_eventSetStartTangent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SplineMesh"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the start tangent vector of spline in local space"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USplineMeshComponent_NoRegister()
	{
		return USplineMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USplineMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UStaticMeshComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USplineMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMax());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMin());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetEndOffset());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetEndPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetEndRoll());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetEndScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetEndTangent());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetForwardAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetSplineUpDir());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetStartOffset());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetStartPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetStartRoll());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetStartScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_GetStartTangent());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMax());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMin());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetEndOffset());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetEndPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetEndRoll());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetEndScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetEndTangent());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetForwardAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetSplineUpDir());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetStartAndEnd());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetStartOffset());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetStartPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetStartRoll());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetStartScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USplineMeshComponent_SetStartTangent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSelected, USplineMeshComponent, uint8);
				UProperty* NewProp_bSelected = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSelected"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSelected, USplineMeshComponent), 0x0000000800002000, CPP_BOOL_PROPERTY_BITMASK(bSelected, USplineMeshComponent), sizeof(uint8), false);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_CachedMeshBodySetupGuid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedMeshBodySetupGuid"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CachedMeshBodySetupGuid, USplineMeshComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FGuid());
				UProperty* NewProp_BodySetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BodySetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(BodySetup, USplineMeshComponent), 0x0000000000000000, Z_Construct_UClass_UBodySetup_NoRegister());
				UProperty* NewProp_SplineBoundaryMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineBoundaryMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SplineBoundaryMax, USplineMeshComponent), 0x0000040000000001);
				UProperty* NewProp_SplineBoundaryMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineBoundaryMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SplineBoundaryMin, USplineMeshComponent), 0x0000040000000001);
				UProperty* NewProp_ForwardAxis = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ForwardAxis"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ForwardAxis, USplineMeshComponent), 0x0000000000000001, Z_Construct_UEnum_Engine_ESplineMeshAxis());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSmoothInterpRollScale, USplineMeshComponent, uint8);
				UProperty* NewProp_bSmoothInterpRollScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSmoothInterpRollScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSmoothInterpRollScale, USplineMeshComponent), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(bSmoothInterpRollScale, USplineMeshComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowSplineEditingPerInstance, USplineMeshComponent, uint8);
				UProperty* NewProp_bAllowSplineEditingPerInstance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowSplineEditingPerInstance"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowSplineEditingPerInstance, USplineMeshComponent), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(bAllowSplineEditingPerInstance, USplineMeshComponent), sizeof(uint8), false);
				UProperty* NewProp_SplineUpDir = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineUpDir"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SplineUpDir, USplineMeshComponent), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_SplineParams = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SplineParams"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SplineParams, USplineMeshComponent), 0x0000000000000001, Z_Construct_UScriptStruct_FSplineMeshParams());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMax()); // 2281361075
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetBoundaryMin()); // 3498163018
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetEndOffset()); // 3548201926
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetEndPosition()); // 1639152316
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetEndRoll()); // 1897966144
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetEndScale()); // 454640485
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetEndTangent()); // 4129183417
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetForwardAxis()); // 714556200
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetSplineUpDir()); // 234144287
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetStartOffset()); // 266608600
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetStartPosition()); // 3731893948
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetStartRoll()); // 1291429630
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetStartScale()); // 222596150
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_GetStartTangent()); // 3102819626
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMax()); // 3738751685
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetBoundaryMin()); // 3480325511
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetEndOffset()); // 2708016789
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetEndPosition()); // 2592945507
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetEndRoll()); // 1976309842
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetEndScale()); // 2192304880
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetEndTangent()); // 254253707
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetForwardAxis()); // 3653079380
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetSplineUpDir()); // 87054399
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetStartAndEnd()); // 1395504313
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetStartOffset()); // 2815154247
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetStartPosition()); // 3749447405
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetStartRoll()); // 1531818650
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetStartScale()); // 2027717838
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USplineMeshComponent_SetStartTangent()); // 3799300644
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UInterface_CollisionDataProvider_NoRegister(), VTABLE_OFFSET(USplineMeshComponent, IInterface_CollisionDataProvider), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Physics Object Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SplineMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A Spline Mesh Component is a derivation of a Static Mesh Component which can be deformed using a spline. Only a start and end position (and tangent) can be specified.\n@see https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/Blueprint_Splines"));
				MetaData->SetValue(NewProp_bSelected, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_CachedMeshBodySetupGuid, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_CachedMeshBodySetupGuid, TEXT("ToolTip"), TEXT("Used to automatically trigger rebuild of collision data"));
				MetaData->SetValue(NewProp_BodySetup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_BodySetup, TEXT("ToolTip"), TEXT("Physics data."));
				MetaData->SetValue(NewProp_SplineBoundaryMax, TEXT("Category"), TEXT("SplineMesh"));
				MetaData->SetValue(NewProp_SplineBoundaryMax, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_SplineBoundaryMax, TEXT("ToolTip"), TEXT("Maximum coordinate along the spline forward axis which corresponds to end of spline. If set to 0.0, will use bounding box to determine bounds"));
				MetaData->SetValue(NewProp_SplineBoundaryMin, TEXT("Category"), TEXT("SplineMesh"));
				MetaData->SetValue(NewProp_SplineBoundaryMin, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_SplineBoundaryMin, TEXT("ToolTip"), TEXT("Minimum coordinate along the spline forward axis which corresponds to start of spline. If set to 0.0, will use bounding box to determine bounds"));
				MetaData->SetValue(NewProp_ForwardAxis, TEXT("Category"), TEXT("SplineMesh"));
				MetaData->SetValue(NewProp_ForwardAxis, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_ForwardAxis, TEXT("ToolTip"), TEXT("Chooses the forward axis for the spline mesh orientation"));
				MetaData->SetValue(NewProp_bSmoothInterpRollScale, TEXT("Category"), TEXT("SplineMesh"));
				MetaData->SetValue(NewProp_bSmoothInterpRollScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_bSmoothInterpRollScale, TEXT("ToolTip"), TEXT("If true, will use smooth interpolation (ease in/out) for Scale, Roll, and Offset along this section of spline. If false, uses linear"));
				MetaData->SetValue(NewProp_bAllowSplineEditingPerInstance, TEXT("Category"), TEXT("Spline"));
				MetaData->SetValue(NewProp_bAllowSplineEditingPerInstance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_bAllowSplineEditingPerInstance, TEXT("ToolTip"), TEXT("If true, spline keys may be edited per instance in the level viewport. Otherwise, the spline should be initialized in the construction script."));
				MetaData->SetValue(NewProp_SplineUpDir, TEXT("Category"), TEXT("SplineMesh"));
				MetaData->SetValue(NewProp_SplineUpDir, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_SplineUpDir, TEXT("ToolTip"), TEXT("Axis (in component space) that is used to determine X axis for co-ordinates along spline"));
				MetaData->SetValue(NewProp_SplineParams, TEXT("Category"), TEXT("SplineMesh"));
				MetaData->SetValue(NewProp_SplineParams, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SplineMeshComponent.h"));
				MetaData->SetValue(NewProp_SplineParams, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_SplineParams, TEXT("ToolTip"), TEXT("Spline that is used to deform mesh"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USplineMeshComponent(Z_Construct_UClass_USplineMeshComponent, TEXT("USplineMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USplineMeshComponent);
	UClass* Z_Construct_UClass_UModelComponent_NoRegister()
	{
		return UModelComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UModelComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UModelComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ModelBodySetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ModelBodySetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ModelBodySetup, UModelComponent), 0x0000000000000000, Z_Construct_UClass_UBodySetup_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UInterface_CollisionDataProvider_NoRegister(), VTABLE_OFFSET(UModelComponent, IInterface_CollisionDataProvider), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ModelComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ModelComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("ModelComponents are PrimitiveComponents that represent elements of BSP geometry in a ULevel object.\nThey are used exclusively by ULevel and are not intended as general-purpose components.\n\n@see ULevel"));
				MetaData->SetValue(NewProp_ModelBodySetup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ModelComponent.h"));
				MetaData->SetValue(NewProp_ModelBodySetup, TEXT("ToolTip"), TEXT("Description of collision"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UModelComponent(Z_Construct_UClass_UModelComponent, TEXT("UModelComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UModelComponent);
	UClass* Z_Construct_UClass_UNavLinkRenderingComponent_NoRegister()
	{
		return UNavLinkRenderingComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavLinkRenderingComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavLinkRenderingComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavLinkRenderingComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavLinkRenderingComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavLinkRenderingComponent(Z_Construct_UClass_UNavLinkRenderingComponent, TEXT("UNavLinkRenderingComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavLinkRenderingComponent);
	UClass* Z_Construct_UClass_UNavMeshRenderingComponent_NoRegister()
	{
		return UNavMeshRenderingComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavMeshRenderingComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavMeshRenderingComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavMeshRenderingComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavMeshRenderingComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavMeshRenderingComponent(Z_Construct_UClass_UNavMeshRenderingComponent, TEXT("UNavMeshRenderingComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavMeshRenderingComponent);
	UClass* Z_Construct_UClass_UNavTestRenderingComponent_NoRegister()
	{
		return UNavTestRenderingComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UNavTestRenderingComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UNavTestRenderingComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/Navigation/NavTestRenderingComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/Navigation/NavTestRenderingComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UNavTestRenderingComponent(Z_Construct_UClass_UNavTestRenderingComponent, TEXT("UNavTestRenderingComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UNavTestRenderingComponent);
	UEnum* Z_Construct_UEnum_Engine_EMaterialUsage()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EMaterialUsage_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EMaterialUsage"), 0, Get_Z_Construct_UEnum_Engine_EMaterialUsage_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EMaterialUsage"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_SkeletalMesh")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_ParticleSprites")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_BeamTrails")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_MeshParticles")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_StaticLighting")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_MorphTargets")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_SplineMesh")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_Landscape")), 7));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_InstancedStaticMeshes")), 8));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_Clothing")), 9));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MATUSAGE_MAX")), 10));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EMaterialUsage_CRC() { return 198715100U; }
	UScriptStruct* Z_Construct_UScriptStruct_FLightmassMaterialInterfaceSettings()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FLightmassMaterialInterfaceSettings_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("LightmassMaterialInterfaceSettings"), sizeof(FLightmassMaterialInterfaceSettings), Get_Z_Construct_UScriptStruct_FLightmassMaterialInterfaceSettings_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LightmassMaterialInterfaceSettings"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FLightmassMaterialInterfaceSettings>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideExportResolutionScale, FLightmassMaterialInterfaceSettings, uint8);
			UProperty* NewProp_bOverrideExportResolutionScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideExportResolutionScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideExportResolutionScale, FLightmassMaterialInterfaceSettings), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideExportResolutionScale, FLightmassMaterialInterfaceSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideDiffuseBoost, FLightmassMaterialInterfaceSettings, uint8);
			UProperty* NewProp_bOverrideDiffuseBoost = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideDiffuseBoost"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideDiffuseBoost, FLightmassMaterialInterfaceSettings), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideDiffuseBoost, FLightmassMaterialInterfaceSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideEmissiveBoost, FLightmassMaterialInterfaceSettings, uint8);
			UProperty* NewProp_bOverrideEmissiveBoost = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideEmissiveBoost"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideEmissiveBoost, FLightmassMaterialInterfaceSettings), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideEmissiveBoost, FLightmassMaterialInterfaceSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideCastShadowAsMasked, FLightmassMaterialInterfaceSettings, uint8);
			UProperty* NewProp_bOverrideCastShadowAsMasked = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOverrideCastShadowAsMasked"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideCastShadowAsMasked, FLightmassMaterialInterfaceSettings), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOverrideCastShadowAsMasked, FLightmassMaterialInterfaceSettings), sizeof(uint8), false);
			UProperty* NewProp_ExportResolutionScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ExportResolutionScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ExportResolutionScale, FLightmassMaterialInterfaceSettings), 0x0000000000000005);
			UProperty* NewProp_DiffuseBoost = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DiffuseBoost"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DiffuseBoost, FLightmassMaterialInterfaceSettings), 0x0000000000000005);
			UProperty* NewProp_EmissiveBoost = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EmissiveBoost"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(EmissiveBoost, FLightmassMaterialInterfaceSettings), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastShadowAsMasked, FLightmassMaterialInterfaceSettings, uint8);
			UProperty* NewProp_bCastShadowAsMasked = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCastShadowAsMasked"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastShadowAsMasked, FLightmassMaterialInterfaceSettings), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bCastShadowAsMasked, FLightmassMaterialInterfaceSettings), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("UMaterial interface settings for Lightmass"));
			MetaData->SetValue(NewProp_bOverrideExportResolutionScale, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bOverrideExportResolutionScale, TEXT("ToolTip"), TEXT("If true, override the export resolution scale setting of the parent material."));
			MetaData->SetValue(NewProp_bOverrideDiffuseBoost, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bOverrideDiffuseBoost, TEXT("ToolTip"), TEXT("If true, override the diffuse boost setting of the parent material."));
			MetaData->SetValue(NewProp_bOverrideEmissiveBoost, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bOverrideEmissiveBoost, TEXT("ToolTip"), TEXT("If true, override the emissive boost setting of the parent material."));
			MetaData->SetValue(NewProp_bOverrideCastShadowAsMasked, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bOverrideCastShadowAsMasked, TEXT("ToolTip"), TEXT("If true, override the bCastShadowAsMasked setting of the parent material."));
			MetaData->SetValue(NewProp_ExportResolutionScale, TEXT("Category"), TEXT("Material"));
			MetaData->SetValue(NewProp_ExportResolutionScale, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_ExportResolutionScale, TEXT("ToolTip"), TEXT("Scales the resolution that this material's attributes were exported at.\nThis is useful for increasing material resolution when details are needed."));
			MetaData->SetValue(NewProp_DiffuseBoost, TEXT("Category"), TEXT("Material"));
			MetaData->SetValue(NewProp_DiffuseBoost, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_DiffuseBoost, TEXT("ToolTip"), TEXT("Scales the diffuse contribution of this material to static lighting."));
			MetaData->SetValue(NewProp_EmissiveBoost, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_EmissiveBoost, TEXT("ToolTip"), TEXT("Scales the emissive contribution of this material to static lighting."));
			MetaData->SetValue(NewProp_bCastShadowAsMasked, TEXT("Category"), TEXT("Material"));
			MetaData->SetValue(NewProp_bCastShadowAsMasked, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bCastShadowAsMasked, TEXT("ToolTip"), TEXT("If true, forces translucency to cast static shadows as if the material were masked."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightmassMaterialInterfaceSettings_CRC() { return 843486956U; }
	UScriptStruct* Z_Construct_UScriptStruct_FMaterialRelevance()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FMaterialRelevance_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("MaterialRelevance"), sizeof(FMaterialRelevance), Get_Z_Construct_UScriptStruct_FMaterialRelevance_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MaterialRelevance"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FMaterialRelevance>, EStructFlags(0x00000201));
			UProperty* NewProp_ShadingModelMask = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ShadingModelMask"), RF_Public|RF_Transient|RF_Native) UUInt16Property(CPP_PROPERTY_BASE(ShadingModelMask, FMaterialRelevance), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUsesGlobalDistanceField, FMaterialRelevance, uint8);
			UProperty* NewProp_bUsesGlobalDistanceField = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bUsesGlobalDistanceField"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUsesGlobalDistanceField, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUsesGlobalDistanceField, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOutputsVelocityInBasePass, FMaterialRelevance, uint8);
			UProperty* NewProp_bOutputsVelocityInBasePass = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOutputsVelocityInBasePass"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOutputsVelocityInBasePass, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOutputsVelocityInBasePass, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableDepthTest, FMaterialRelevance, uint8);
			UProperty* NewProp_bDisableDepthTest = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bDisableDepthTest"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableDepthTest, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDisableDepthTest, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNormalTranslucency, FMaterialRelevance, uint8);
			UProperty* NewProp_bNormalTranslucency = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bNormalTranslucency"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNormalTranslucency, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bNormalTranslucency, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSeparateTranslucency, FMaterialRelevance, uint8);
			UProperty* NewProp_bSeparateTranslucency = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSeparateTranslucency"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSeparateTranslucency, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bSeparateTranslucency, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDistortion, FMaterialRelevance, uint8);
			UProperty* NewProp_bDistortion = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bDistortion"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDistortion, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDistortion, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bMasked, FMaterialRelevance, uint8);
			UProperty* NewProp_bMasked = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bMasked"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bMasked, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bMasked, FMaterialRelevance), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOpaque, FMaterialRelevance, uint8);
			UProperty* NewProp_bOpaque = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOpaque"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOpaque, FMaterialRelevance), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bOpaque, FMaterialRelevance), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_ShadingModelMask, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bUsesGlobalDistanceField, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bOutputsVelocityInBasePass, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bDisableDepthTest, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bNormalTranslucency, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bSeparateTranslucency, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bDistortion, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bMasked, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(NewProp_bOpaque, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMaterialRelevance_CRC() { return 3762726818U; }
	UFunction* Z_Construct_UFunction_UMaterialInterface_GetBaseMaterial()
	{
		struct MaterialInterface_eventGetBaseMaterial_Parms
		{
			UMaterial* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMaterialInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBaseMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(MaterialInterface_eventGetBaseMaterial_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MaterialInterface_eventGetBaseMaterial_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterial_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Walks up parent chain and finds the base Material that this is an instance of."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMaterialInterface_GetPhysicalMaterial()
	{
		struct MaterialInterface_eventGetPhysicalMaterial_Parms
		{
			UPhysicalMaterial* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMaterialInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysicalMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(MaterialInterface_eventGetPhysicalMaterial_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MaterialInterface_eventGetPhysicalMaterial_Parms), 0x0000000000000580, Z_Construct_UClass_UPhysicalMaterial_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Return a pointer to the physical material used by this material instance.\n@return The physical material."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMaterialInterface_NoRegister()
	{
		return UMaterialInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UMaterialInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = UMaterialInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;

				OuterClass->LinkChild(Z_Construct_UFunction_UMaterialInterface_GetBaseMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UMaterialInterface_GetPhysicalMaterial());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_LightingGuid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightingGuid"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightingGuid, UMaterialInterface), 0x0000000800000000, Z_Construct_UScriptStruct_FGuid());
				UProperty* NewProp_ThumbnailInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailInfo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ThumbnailInfo, UMaterialInterface), 0x00020008000a0009, Z_Construct_UClass_UThumbnailInfo_NoRegister());
				UProperty* NewProp_PreviewMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewMesh"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PreviewMesh, UMaterialInterface), 0x0000000800000001, Z_Construct_UScriptStruct_FStringAssetReference());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_LightmassSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LightmassSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LightmassSettings, UMaterialInterface), 0x0000080000000005, Z_Construct_UScriptStruct_FLightmassMaterialInterfaceSettings());
				UProperty* NewProp_SubsurfaceProfile = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SubsurfaceProfile"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SubsurfaceProfile, UMaterialInterface), 0x0000000000000015, Z_Construct_UClass_USubsurfaceProfile_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMaterialInterface_GetBaseMaterial()); // 2197993702
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMaterialInterface_GetPhysicalMaterial()); // 103845027
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UBlendableInterface_NoRegister(), VTABLE_OFFSET(UMaterialInterface, IBlendableInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Materials/MaterialInterface.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
				MetaData->SetValue(NewProp_LightingGuid, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
				MetaData->SetValue(NewProp_LightingGuid, TEXT("ToolTip"), TEXT("Unique ID for this material, used for caching during distributed lighting"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("Category"), TEXT("Thumbnail"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
				MetaData->SetValue(NewProp_ThumbnailInfo, TEXT("ToolTip"), TEXT("Information for thumbnail rendering"));
				MetaData->SetValue(NewProp_PreviewMesh, TEXT("AllowedClasses"), TEXT("StaticMesh,SkeletalMesh"));
				MetaData->SetValue(NewProp_PreviewMesh, TEXT("Category"), TEXT("MaterialInterface"));
				MetaData->SetValue(NewProp_PreviewMesh, TEXT("ExactClass"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
				MetaData->SetValue(NewProp_PreviewMesh, TEXT("ToolTip"), TEXT("The mesh used by the material editor to preview the material."));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("Category"), TEXT("Lightmass"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
				MetaData->SetValue(NewProp_LightmassSettings, TEXT("ToolTip"), TEXT("The Lightmass settings for this object."));
				MetaData->SetValue(NewProp_SubsurfaceProfile, TEXT("Category"), TEXT("Material"));
				MetaData->SetValue(NewProp_SubsurfaceProfile, TEXT("DisplayName"), TEXT("Subsurface Profile"));
				MetaData->SetValue(NewProp_SubsurfaceProfile, TEXT("ModuleRelativePath"), TEXT("Classes/Materials/MaterialInterface.h"));
				MetaData->SetValue(NewProp_SubsurfaceProfile, TEXT("ToolTip"), TEXT("SubsurfaceProfile, for Screen Space Subsurface Scattering"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMaterialInterface(Z_Construct_UClass_UMaterialInterface, TEXT("UMaterialInterface"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMaterialInterface);
	UEnum* Z_Construct_UEnum_Engine_EParticleSystemOcclusionBoundsMethod()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EParticleSystemOcclusionBoundsMethod_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EParticleSystemOcclusionBoundsMethod"), 0, Get_Z_Construct_UEnum_Engine_EParticleSystemOcclusionBoundsMethod_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EParticleSystemOcclusionBoundsMethod"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSOBM_None")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSOBM_ParticleBounds")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSOBM_CustomBounds")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSOBM_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("EPSOBM_CustomBounds.DisplayName"), TEXT("Custom Bounds"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSOBM_CustomBounds.ToolTip"), TEXT("Use the custom occlusion bounds when determining occlusion"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSOBM_None.DisplayName"), TEXT("None"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSOBM_None.ToolTip"), TEXT("Don't determine occlusion on this particle system"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSOBM_ParticleBounds.DisplayName"), TEXT("Particle Bounds"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSOBM_ParticleBounds.ToolTip"), TEXT("Use the bounds of the particle system component when determining occlusion"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Occlusion method enumeration"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EParticleSystemOcclusionBoundsMethod_CRC() { return 1277855883U; }
	UEnum* Z_Construct_UEnum_Engine_ParticleSystemLODMethod()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ParticleSystemLODMethod_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ParticleSystemLODMethod"), 0, Get_Z_Construct_UEnum_Engine_ParticleSystemLODMethod_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ParticleSystemLODMethod"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PARTICLESYSTEMLODMETHOD_Automatic")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PARTICLESYSTEMLODMETHOD_DirectSet")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PARTICLESYSTEMLODMETHOD_ActivateAutomatic")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PARTICLESYSTEMLODMETHOD_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(ReturnEnum, TEXT("PARTICLESYSTEMLODMETHOD_ActivateAutomatic.DisplayName"), TEXT("Activate Automatic"));
			MetaData->SetValue(ReturnEnum, TEXT("PARTICLESYSTEMLODMETHOD_Automatic.DisplayName"), TEXT("Automatic"));
			MetaData->SetValue(ReturnEnum, TEXT("PARTICLESYSTEMLODMETHOD_DirectSet.DisplayName"), TEXT("Direct Set"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("ParticleSystemLODMethod"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ParticleSystemLODMethod_CRC() { return 3351869383U; }
	UEnum* Z_Construct_UEnum_Engine_EParticleSystemUpdateMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EParticleSystemUpdateMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EParticleSystemUpdateMode"), 0, Get_Z_Construct_UEnum_Engine_EParticleSystemUpdateMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EParticleSystemUpdateMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSUM_RealTime")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSUM_FixedTime")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPSUM_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("EPSUM_FixedTime.DisplayName"), TEXT("Fixed-Time"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSUM_FixedTime.ToolTip"), TEXT("FixedTime      - update via a fixed time step"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSUM_RealTime.DisplayName"), TEXT("Real-Time"));
			MetaData->SetValue(ReturnEnum, TEXT("EPSUM_RealTime.ToolTip"), TEXT("RealTime       - update via the delta time passed in"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("ParticleSystemUpdateMode\nEnumeration indicating the method by which the system should be updated"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EParticleSystemUpdateMode_CRC() { return 4014965357U; }
	UScriptStruct* Z_Construct_UScriptStruct_FNamedEmitterMaterial()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FNamedEmitterMaterial_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("NamedEmitterMaterial"), sizeof(FNamedEmitterMaterial), Get_Z_Construct_UScriptStruct_FNamedEmitterMaterial_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NamedEmitterMaterial"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FNamedEmitterMaterial>, EStructFlags(0x00000001));
			UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, FNamedEmitterMaterial), 0x0000000000000001, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_Name = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Name"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(Name, FNamedEmitterMaterial), 0x0000000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(NewProp_Material, TEXT("Category"), TEXT("NamedMaterial"));
			MetaData->SetValue(NewProp_Material, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(NewProp_Name, TEXT("Category"), TEXT("NamedMaterial"));
			MetaData->SetValue(NewProp_Name, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FNamedEmitterMaterial_CRC() { return 3821439662U; }
	UScriptStruct* Z_Construct_UScriptStruct_FLODSoloTrack()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FLODSoloTrack_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("LODSoloTrack"), sizeof(FLODSoloTrack), Get_Z_Construct_UScriptStruct_FLODSoloTrack_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LODSoloTrack"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FLODSoloTrack>, EStructFlags(0x00000001));
			UProperty* NewProp_SoloEnableSetting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SoloEnableSetting"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SoloEnableSetting, FLODSoloTrack), 0x0000000000002000);
			UProperty* NewProp_SoloEnableSetting_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SoloEnableSetting, TEXT("SoloEnableSetting"), RF_Public|RF_Transient|RF_Native) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Temporary array for tracking 'solo' emitter mode.\nEntry will be true if emitter was enabled"));
			MetaData->SetValue(NewProp_SoloEnableSetting, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLODSoloTrack_CRC() { return 3235399689U; }
	UScriptStruct* Z_Construct_UScriptStruct_FParticleSystemLOD()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FParticleSystemLOD_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ParticleSystemLOD"), sizeof(FParticleSystemLOD), Get_Z_Construct_UScriptStruct_FParticleSystemLOD_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ParticleSystemLOD"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FParticleSystemLOD>, EStructFlags(0x00000001));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Structure containing per-LOD settings that pertain to the entire UParticleSystem."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FParticleSystemLOD_CRC() { return 2820198480U; }
	UFunction* Z_Construct_UFunction_UParticleSystem_ContainsEmitterType()
	{
		struct ParticleSystem_eventContainsEmitterType_Parms
		{
			UClass* TypeData;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ContainsEmitterType"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystem_eventContainsEmitterType_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, ParticleSystem_eventContainsEmitterType_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, ParticleSystem_eventContainsEmitterType_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, ParticleSystem_eventContainsEmitterType_Parms), sizeof(bool), true);
			UProperty* NewProp_TypeData = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TypeData"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(TypeData, ParticleSystem_eventContainsEmitterType_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Particle System"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns true if this system contains an emitter of the pasesd type.\n@ param TypeData - The emitter type to check for. Must be a child class of UParticleModuleTypeDataBase"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UParticleSystem_NoRegister()
	{
		return UParticleSystem::StaticClass();
	}
	UClass* Z_Construct_UClass_UParticleSystem()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = UParticleSystem::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;

				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystem_ContainsEmitterType());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_NamedMaterialSlots = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NamedMaterialSlots"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(NamedMaterialSlots, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_NamedMaterialSlots_Inner = new(EC_InternalUseOnlyConstructor, NewProp_NamedMaterialSlots, TEXT("NamedMaterialSlots"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FNamedEmitterMaterial());
				UProperty* NewProp_SoloTracking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SoloTracking"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SoloTracking, UParticleSystem), 0x0000000000002000);
				UProperty* NewProp_SoloTracking_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SoloTracking, TEXT("SoloTracking"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FLODSoloTrack());
				UProperty* NewProp_CustomOcclusionBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomOcclusionBounds"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CustomOcclusionBounds, UParticleSystem), 0x0000000000000001, Z_Construct_UScriptStruct_FBox());
				UProperty* NewProp_OcclusionBoundsMethod = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OcclusionBoundsMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(OcclusionBoundsMethod, UParticleSystem), 0x0000000000000001, Z_Construct_UEnum_Engine_EParticleSystemOcclusionBoundsMethod());
				UProperty* NewProp_MacroUVRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MacroUVRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MacroUVRadius, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_MacroUVPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MacroUVPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(MacroUVPosition, UParticleSystem), 0x0000000000000001, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseDelayRange, UParticleSystem, uint8);
				UProperty* NewProp_bUseDelayRange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseDelayRange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseDelayRange, UParticleSystem), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bUseDelayRange, UParticleSystem), sizeof(uint8), false);
				UProperty* NewProp_DelayLow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DelayLow"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DelayLow, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_Delay = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Delay"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Delay, UParticleSystem), 0x0000010000000001);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_ThumbnailImage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailImage"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ThumbnailImage, UParticleSystem), 0x0000000800000000, Z_Construct_UClass_UTexture2D_NoRegister());
#endif // WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ThumbnailImageOutOfDate, UParticleSystem, uint8);
				UProperty* NewProp_ThumbnailImageOutOfDate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailImageOutOfDate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ThumbnailImageOutOfDate, UParticleSystem), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(ThumbnailImageOutOfDate, UParticleSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseRealtimeThumbnail, UParticleSystem, uint8);
				UProperty* NewProp_bUseRealtimeThumbnail = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseRealtimeThumbnail"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseRealtimeThumbnail, UParticleSystem), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bUseRealtimeThumbnail, UParticleSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasPhysics, UParticleSystem, uint8);
				UProperty* NewProp_bHasPhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasPhysics"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasPhysics, UParticleSystem), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bHasPhysics, UParticleSystem), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldResetPeakCounts, UParticleSystem, uint8);
				UProperty* NewProp_bShouldResetPeakCounts = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldResetPeakCounts"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldResetPeakCounts, UParticleSystem), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bShouldResetPeakCounts, UParticleSystem), sizeof(uint8), false);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_BackgroundColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BackgroundColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BackgroundColor, UParticleSystem), 0x0000000800000000, Z_Construct_UScriptStruct_FColor());
				UProperty* NewProp_FloorScale3D = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorScale3D"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FloorScale3D, UParticleSystem), 0x0000000800000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FloorScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FloorScale, UParticleSystem), 0x0000000800000000);
				UProperty* NewProp_FloorRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorRotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FloorRotation, UParticleSystem), 0x0000000800000000, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_FloorPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FloorPosition, UParticleSystem), 0x0000000800000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FloorMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorMesh"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(FloorMesh, UParticleSystem), 0x0000000800000000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_SecondsBeforeInactive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SecondsBeforeInactive"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SecondsBeforeInactive, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_FixedRelativeBoundingBox = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FixedRelativeBoundingBox"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FixedRelativeBoundingBox, UParticleSystem), 0x0000000000000001, Z_Construct_UScriptStruct_FBox());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseFixedRelativeBoundingBox, UParticleSystem, uint8);
				UProperty* NewProp_bUseFixedRelativeBoundingBox = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseFixedRelativeBoundingBox"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseFixedRelativeBoundingBox, UParticleSystem), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bUseFixedRelativeBoundingBox, UParticleSystem), sizeof(uint8), false);
				UProperty* NewProp_LODSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODSettings"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LODSettings, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_LODSettings_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LODSettings, TEXT("LODSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FParticleSystemLOD());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRegenerateLODDuplicate, UParticleSystem, uint8);
				UProperty* NewProp_bRegenerateLODDuplicate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRegenerateLODDuplicate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRegenerateLODDuplicate, UParticleSystem), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bRegenerateLODDuplicate, UParticleSystem), sizeof(uint8), false);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_EditorLODSetting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EditorLODSetting"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EditorLODSetting, UParticleSystem), 0x0000000800000000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_LODDistances = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODDistances"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LODDistances, UParticleSystem), 0x0000000000000041);
				UProperty* NewProp_LODDistances_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LODDistances, TEXT("LODDistances"), RF_Public|RF_Transient|RF_Native) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_LODMethod = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LODMethod, UParticleSystem), 0x0000000000000001, Z_Construct_UEnum_Engine_ParticleSystemLODMethod());
				UProperty* NewProp_LODDistanceCheckTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODDistanceCheckTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(LODDistanceCheckTime, UParticleSystem), 0x0000000000000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOrientZAxisTowardCamera, UParticleSystem, uint8);
				UProperty* NewProp_bOrientZAxisTowardCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOrientZAxisTowardCamera"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOrientZAxisTowardCamera, UParticleSystem), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bOrientZAxisTowardCamera, UParticleSystem), sizeof(uint8), false);
				UProperty* NewProp_CurveEdSetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurveEdSetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CurveEdSetup, UParticleSystem), 0x0000000000000008, Z_Construct_UClass_UInterpCurveEdSetup_NoRegister());
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_ThumbnailWarmup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailWarmup"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ThumbnailWarmup, UParticleSystem), 0x0000000800000001);
				UProperty* NewProp_ThumbnailDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ThumbnailDistance, UParticleSystem), 0x0000000800000000);
				UProperty* NewProp_ThumbnailAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThumbnailAngle"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ThumbnailAngle, UParticleSystem), 0x0000000800000000, Z_Construct_UScriptStruct_FRotator());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_PreviewComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewComponent, UParticleSystem), 0x0000000000082008, Z_Construct_UClass_UParticleSystemComponent_NoRegister());
				UProperty* NewProp_Emitters = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Emitters"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Emitters, UParticleSystem), 0x0000008000000008);
				UProperty* NewProp_Emitters_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Emitters, TEXT("Emitters"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UParticleEmitter_NoRegister());
				UProperty* NewProp_WarmupTickRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WarmupTickRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WarmupTickRate, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_WarmupTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WarmupTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WarmupTime, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_UpdateTime_Delta = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateTime_Delta"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(UpdateTime_Delta, UParticleSystem), 0x0000000000000000);
				UProperty* NewProp_UpdateTime_FPS = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateTime_FPS"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(UpdateTime_FPS, UParticleSystem), 0x0000000000000001);
				UProperty* NewProp_SystemUpdateMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SystemUpdateMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(SystemUpdateMode, UParticleSystem), 0x0000010000000001, Z_Construct_UEnum_Engine_EParticleSystemUpdateMode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystem_ContainsEmitterType()); // 474477678
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Particles/ParticleSystem.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A ParticleSystem is a complete particle effect that contains any number of ParticleEmitters. By allowing multiple emitters\nin a system, the designer can create elaborate particle effects that are held in a single system. Once created using\nCascade, a ParticleSystem can then be inserted into a level or created in script."));
				MetaData->SetValue(NewProp_NamedMaterialSlots, TEXT("Category"), TEXT("Materials"));
				MetaData->SetValue(NewProp_NamedMaterialSlots, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_NamedMaterialSlots, TEXT("ToolTip"), TEXT("Array of named material slots for use by emitters of this system.\nEmitters can use these instead of their own materials by providing the name to the NamedMaterialOverrides property of their required module.\nThese materials can be overriden using CreateNamedDynamicMaterialInstance() on a ParticleSystemComponent."));
				MetaData->SetValue(NewProp_SoloTracking, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_CustomOcclusionBounds, TEXT("Category"), TEXT("Occlusion"));
				MetaData->SetValue(NewProp_CustomOcclusionBounds, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_CustomOcclusionBounds, TEXT("ToolTip"), TEXT("The occlusion bounds to use if OcclusionBoundsMethod is set to EPSOBM_CustomBounds"));
				MetaData->SetValue(NewProp_OcclusionBoundsMethod, TEXT("Category"), TEXT("Occlusion"));
				MetaData->SetValue(NewProp_OcclusionBoundsMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_OcclusionBoundsMethod, TEXT("ToolTip"), TEXT("Which occlusion bounds method to use for this particle system.\nEPSOBM_None - Don't determine occlusion for this system.\nEPSOBM_ParticleBounds - Use the bounds of the component when determining occlusion."));
				MetaData->SetValue(NewProp_MacroUVRadius, TEXT("Category"), TEXT("MacroUV"));
				MetaData->SetValue(NewProp_MacroUVRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_MacroUVRadius, TEXT("ToolTip"), TEXT("World space radius that UVs generated with the ParticleMacroUV material node will tile based on."));
				MetaData->SetValue(NewProp_MacroUVPosition, TEXT("Category"), TEXT("MacroUV"));
				MetaData->SetValue(NewProp_MacroUVPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_MacroUVPosition, TEXT("ToolTip"), TEXT("Local space position that UVs generated with the ParticleMacroUV material node will be centered on."));
				MetaData->SetValue(NewProp_bUseDelayRange, TEXT("Category"), TEXT("Delay"));
				MetaData->SetValue(NewProp_bUseDelayRange, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bUseDelayRange, TEXT("ToolTip"), TEXT("If true, select the emitter delay from the range\n        [DelayLow..Delay]"));
				MetaData->SetValue(NewProp_DelayLow, TEXT("Category"), TEXT("Delay"));
				MetaData->SetValue(NewProp_DelayLow, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_DelayLow, TEXT("ToolTip"), TEXT("The low end of the emitter delay if using a range."));
				MetaData->SetValue(NewProp_Delay, TEXT("Category"), TEXT("Delay"));
				MetaData->SetValue(NewProp_Delay, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_Delay, TEXT("ToolTip"), TEXT("How long this Particle system should delay when ActivateSystem is called on it."));
				MetaData->SetValue(NewProp_ThumbnailImage, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_ThumbnailImage, TEXT("ToolTip"), TEXT("Internal: The PSys thumbnail image"));
				MetaData->SetValue(NewProp_ThumbnailImageOutOfDate, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_ThumbnailImageOutOfDate, TEXT("ToolTip"), TEXT("Internal: Indicates the PSys thumbnail image is out of date"));
				MetaData->SetValue(NewProp_bUseRealtimeThumbnail, TEXT("Category"), TEXT("Thumbnail"));
				MetaData->SetValue(NewProp_bUseRealtimeThumbnail, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bUseRealtimeThumbnail, TEXT("ToolTip"), TEXT("Inidicates the old 'real-time' thumbnail rendering should be used"));
				MetaData->SetValue(NewProp_bHasPhysics, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bHasPhysics, TEXT("ToolTip"), TEXT("Set during load time to indicate that physics is used..."));
				MetaData->SetValue(NewProp_bShouldResetPeakCounts, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bShouldResetPeakCounts, TEXT("ToolTip"), TEXT("EDITOR ONLY: Indicates that Cascade would like to have the PeakActiveParticles count reset"));
				MetaData->SetValue(NewProp_BackgroundColor, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_BackgroundColor, TEXT("ToolTip"), TEXT("The background color to display in Cascade"));
				MetaData->SetValue(NewProp_FloorScale3D, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_FloorScale, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_FloorRotation, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_FloorPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_FloorMesh, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_FloorMesh, TEXT("ToolTip"), TEXT("Cascade 'floor' mesh information."));
				MetaData->SetValue(NewProp_SecondsBeforeInactive, TEXT("Category"), TEXT("ParticleSystem"));
				MetaData->SetValue(NewProp_SecondsBeforeInactive, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_SecondsBeforeInactive, TEXT("ToolTip"), TEXT("Number of seconds of emitter not being rendered that need to pass before it\nno longer gets ticked/ becomes inactive."));
				MetaData->SetValue(NewProp_FixedRelativeBoundingBox, TEXT("Category"), TEXT("Bounds"));
				MetaData->SetValue(NewProp_FixedRelativeBoundingBox, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_FixedRelativeBoundingBox, TEXT("ToolTip"), TEXT("Fixed relative bounding box for particle system."));
				MetaData->SetValue(NewProp_bUseFixedRelativeBoundingBox, TEXT("Category"), TEXT("Bounds"));
				MetaData->SetValue(NewProp_bUseFixedRelativeBoundingBox, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bUseFixedRelativeBoundingBox, TEXT("ToolTip"), TEXT("Whether to use the fixed relative bounding box or calculate it every frame."));
				MetaData->SetValue(NewProp_LODSettings, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_LODSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bRegenerateLODDuplicate, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bRegenerateLODDuplicate, TEXT("ToolTip"), TEXT("Internal value that tracks the regenerate LOD levels preference.\nIf true, when autoregenerating LOD levels in code, the low level will\nbe a duplicate of the high."));
				MetaData->SetValue(NewProp_EditorLODSetting, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_EditorLODSetting, TEXT("ToolTip"), TEXT("LOD setting for intepolation (set by Cascade) Range [0..100]"));
				MetaData->SetValue(NewProp_LODDistances, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_LODDistances, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_LODDistances, TEXT("ToolTip"), TEXT("The array of distances for each LOD level in the system.\nUsed when LODMethod is set to PARTICLESYSTEMLODMETHOD_Automatic.\n\nExample: System with 3 LOD levels\n        LODDistances(0) = 0.0\n        LODDistances(1) = 2500.0\n        LODDistances(2) = 5000.0\n\n        In this case, when the system is [   0.0 ..   2499.9] from the camera, LOD level 0 will be used.\n                                                                         [2500.0 ..   4999.9] from the camera, LOD level 1 will be used.\n                                                                         [5000.0 .. INFINITY] from the camera, LOD level 2 will be used."));
				MetaData->SetValue(NewProp_LODMethod, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_LODMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_LODMethod, TEXT("ToolTip"), TEXT("The method of LOD level determination to utilize for this particle system\n  PARTICLESYSTEMLODMETHOD_Automatic - Automatically set the LOD level, checking every LODDistanceCheckTime seconds.\nPARTICLESYSTEMLODMETHOD_DirectSet - LOD level is directly set by the game code.\nPARTICLESYSTEMLODMETHOD_ActivateAutomatic - LOD level is determined at Activation time, then left alone unless directly set by game code."));
				MetaData->SetValue(NewProp_LODDistanceCheckTime, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_LODDistanceCheckTime, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_LODDistanceCheckTime, TEXT("ToolTip"), TEXT("How often (in seconds) the system should perform the LOD distance check."));
				MetaData->SetValue(NewProp_bOrientZAxisTowardCamera, TEXT("Category"), TEXT("ParticleSystem"));
				MetaData->SetValue(NewProp_bOrientZAxisTowardCamera, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_bOrientZAxisTowardCamera, TEXT("ToolTip"), TEXT("If true, the system's Z axis will be oriented toward the camera"));
				MetaData->SetValue(NewProp_CurveEdSetup, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_CurveEdSetup, TEXT("ToolTip"), TEXT("Used for curve editor to remember curve-editing setup."));
				MetaData->SetValue(NewProp_ThumbnailWarmup, TEXT("Category"), TEXT("Thumbnail"));
				MetaData->SetValue(NewProp_ThumbnailWarmup, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_ThumbnailWarmup, TEXT("ToolTip"), TEXT("The time to warm-up the system for the thumbnail image"));
				MetaData->SetValue(NewProp_ThumbnailDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_ThumbnailDistance, TEXT("ToolTip"), TEXT("The distance to place the system when rendering the thumbnail image"));
				MetaData->SetValue(NewProp_ThumbnailAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_ThumbnailAngle, TEXT("ToolTip"), TEXT("The angle to use when rendering the thumbnail image"));
				MetaData->SetValue(NewProp_PreviewComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_PreviewComponent, TEXT("ToolTip"), TEXT("The component used to preview the particle system in Cascade"));
				MetaData->SetValue(NewProp_Emitters, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Emitters, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_Emitters, TEXT("ToolTip"), TEXT("Emitters       - internal - the array of emitters in the system"));
				MetaData->SetValue(NewProp_Emitters_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Emitters_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_Emitters_Inner, TEXT("ToolTip"), TEXT("Emitters       - internal - the array of emitters in the system"));
				MetaData->SetValue(NewProp_WarmupTickRate, TEXT("Category"), TEXT("ParticleSystem"));
				MetaData->SetValue(NewProp_WarmupTickRate, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_WarmupTickRate, TEXT("ToolTip"), TEXT("WarmupTickRate - the time step for each tick during warm up.\n       Increasing this improves performance. Decreasing, improves accuracy.\n       Set to 0 to use the default tick time."));
				MetaData->SetValue(NewProp_WarmupTime, TEXT("Category"), TEXT("ParticleSystem"));
				MetaData->SetValue(NewProp_WarmupTime, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_WarmupTime, TEXT("ToolTip"), TEXT("WarmupTime     - the time to warm-up the particle system when first rendered"));
				MetaData->SetValue(NewProp_UpdateTime_Delta, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_UpdateTime_Delta, TEXT("ToolTip"), TEXT("UpdateTime_Delta       - internal"));
				MetaData->SetValue(NewProp_UpdateTime_FPS, TEXT("Category"), TEXT("ParticleSystem"));
				MetaData->SetValue(NewProp_UpdateTime_FPS, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
				MetaData->SetValue(NewProp_UpdateTime_FPS, TEXT("ToolTip"), TEXT("UpdateTime_FPS - the frame per second to update at in FixedTime mode"));
				MetaData->SetValue(NewProp_SystemUpdateMode, TEXT("Category"), TEXT("ParticleSystem"));
				MetaData->SetValue(NewProp_SystemUpdateMode, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystem.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UParticleSystem(Z_Construct_UClass_UParticleSystem, TEXT("UParticleSystem"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UParticleSystem);
	UFunction* Z_Construct_UDelegateFunction_Engine_OnSystemFinished__DelegateSignature()
	{
		struct _Script_Engine_eventOnSystemFinished_Parms
		{
			UParticleSystemComponent* PSystem;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnSystemFinished__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Engine_eventOnSystemFinished_Parms));
			UProperty* NewProp_PSystem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PSystem"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PSystem, _Script_Engine_eventOnSystemFinished_Parms), 0x0000000000080080, Z_Construct_UClass_UParticleSystemComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when the particle system is done"));
			MetaData->SetValue(NewProp_PSystem, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UEnum* Z_Construct_UEnum_Engine_EParticleEventType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EParticleEventType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EParticleEventType"), 0, Get_Z_Construct_UEnum_Engine_EParticleEventType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EParticleEventType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_Any")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_Spawn")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_Death")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_Collision")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_Burst")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_Blueprint")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EPET_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Any.DisplayName"), TEXT("Any"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Any.ToolTip"), TEXT("Any - allow any event"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Blueprint.DisplayName"), TEXT("Blueprint"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Blueprint.ToolTip"), TEXT("Blueprint - an event generated by level script"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Burst.DisplayName"), TEXT("Burst"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Burst.ToolTip"), TEXT("Burst - a particle burst event"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Collision.DisplayName"), TEXT("Collision"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Collision.ToolTip"), TEXT("Collision - a particle collision event"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Death.DisplayName"), TEXT("Death"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Death.ToolTip"), TEXT("Death - a particle death event"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Spawn.DisplayName"), TEXT("Spawn"));
			MetaData->SetValue(ReturnEnum, TEXT("EPET_Spawn.ToolTip"), TEXT("Spawn - a particle spawn event"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Event type"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EParticleEventType_CRC() { return 2269253843U; }
	UEnum* Z_Construct_UEnum_Engine_ParticleReplayState()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ParticleReplayState_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ParticleReplayState"), 0, Get_Z_Construct_UEnum_Engine_ParticleReplayState_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ParticleReplayState"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PRS_Disabled")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PRS_Capturing")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PRS_Replaying")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PRS_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("PRS_Capturing.DisplayName"), TEXT("Capturing"));
			MetaData->SetValue(ReturnEnum, TEXT("PRS_Capturing.ToolTip"), TEXT("Capture all particle data to the clip specified by ReplayClipIDNumber.  The frame to capture\n              must be specified using the ReplayFrameIndex"));
			MetaData->SetValue(ReturnEnum, TEXT("PRS_Disabled.DisplayName"), TEXT("Disabled"));
			MetaData->SetValue(ReturnEnum, TEXT("PRS_Disabled.ToolTip"), TEXT("Replay system is disabled.  Particles are simulated and rendered normally."));
			MetaData->SetValue(ReturnEnum, TEXT("PRS_Replaying.DisplayName"), TEXT("Replaying"));
			MetaData->SetValue(ReturnEnum, TEXT("PRS_Replaying.ToolTip"), TEXT("Replay captured particle state from the clip specified by ReplayClipIDNumber.  The frame to play\n              must be specified using the ReplayFrameIndex"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Particle system replay state"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ParticleReplayState_CRC() { return 4069511006U; }
	UEnum* Z_Construct_UEnum_Engine_EParticleSysParamType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EParticleSysParamType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EParticleSysParamType"), 0, Get_Z_Construct_UEnum_Engine_EParticleSysParamType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EParticleSysParamType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_None")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_Scalar")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_ScalarRand")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_Vector")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_VectorRand")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_Color")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_Actor")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_Material")), 7));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PSPT_MAX")), 8));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_Actor.DisplayName"), TEXT("Actor"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_Color.DisplayName"), TEXT("Color"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_Material.DisplayName"), TEXT("Material"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_None.DisplayName"), TEXT("None"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_Scalar.DisplayName"), TEXT("Scalar"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_ScalarRand.DisplayName"), TEXT("Scalar Random"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_Vector.DisplayName"), TEXT("Vector"));
			MetaData->SetValue(ReturnEnum, TEXT("PSPT_VectorRand.DisplayName"), TEXT("Vector Random"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enum for specifying type of a name instance parameter."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EParticleSysParamType_CRC() { return 3628874460U; }
	UScriptStruct* Z_Construct_UScriptStruct_FParticleSysParam()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FParticleSysParam_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ParticleSysParam"), sizeof(FParticleSysParam), Get_Z_Construct_UScriptStruct_FParticleSysParam_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ParticleSysParam"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FParticleSysParam>, EStructFlags(0x00000001));
			UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, FParticleSysParam), 0x0000000000000005, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_Actor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Actor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Actor, FParticleSysParam), 0x0000000000000005, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_Color = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Color"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Color, FParticleSysParam), 0x0000000000000005, Z_Construct_UScriptStruct_FColor());
			UProperty* NewProp_Vector_Low = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Vector_Low"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Vector_Low, FParticleSysParam), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Vector = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Vector"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Vector, FParticleSysParam), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Scalar_Low = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Scalar_Low"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scalar_Low, FParticleSysParam), 0x0000000000000005);
			UProperty* NewProp_Scalar = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Scalar"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scalar, FParticleSysParam), 0x0000000000000005);
			UProperty* NewProp_ParamType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ParamType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ParamType, FParticleSysParam), 0x0000000000000005, Z_Construct_UEnum_Engine_EParticleSysParamType());
			UProperty* NewProp_Name = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Name"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(Name, FParticleSysParam), 0x0000000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct used for a particular named instance parameter for this ParticleSystemComponent."));
			MetaData->SetValue(NewProp_Material, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Material, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Actor, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Actor, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Color, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Color, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Vector_Low, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Vector_Low, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Vector, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Vector, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Scalar_Low, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Scalar_Low, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Scalar, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Scalar, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_ParamType, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_ParamType, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_ParamType, TEXT("ToolTip"), TEXT("The type of parameters\nPSPT_None       - There is no data type\nPSPT_Scalar     - Use the scalar value\nPSPT_ScalarRand - Select a scalar value in the range [Scalar_Low..Scalar)\nPSPT_Vector     - Use the vector value\nPSPT_VectorRand - Select a vector value in the range [Vector_Low..Vector)\nPSPT_Color      - Use the color value\nPSPT_Actor      - Use the actor value\nPSPT_Material   - Use the material value"));
			MetaData->SetValue(NewProp_Name, TEXT("Category"), TEXT("ParticleSysParam"));
			MetaData->SetValue(NewProp_Name, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(NewProp_Name, TEXT("ToolTip"), TEXT("The name of the parameter"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FParticleSysParam_CRC() { return 3117658923U; }
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_BeginTrails()
	{
		struct ParticleSystemComponent_eventBeginTrails_Parms
		{
			FName InFirstSocketName;
			FName InSecondSocketName;
			TEnumAsByte<ETrailWidthMode> InWidthMode;
			float InWidth;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BeginTrails"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystemComponent_eventBeginTrails_Parms));
			UProperty* NewProp_InWidth = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWidth"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWidth, ParticleSystemComponent_eventBeginTrails_Parms), 0x0000000000000080);
			UProperty* NewProp_InWidthMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWidthMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(InWidthMode, ParticleSystemComponent_eventBeginTrails_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ETrailWidthMode());
			UProperty* NewProp_InSecondSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSecondSocketName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InSecondSocketName, ParticleSystemComponent_eventBeginTrails_Parms), 0x0000000000000080);
			UProperty* NewProp_InFirstSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InFirstSocketName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InFirstSocketName, ParticleSystemComponent_eventBeginTrails_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Particles|Trails"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Begins all trail emitters in this component.\n\n@param        InFirstSocketName       The name of the first socket for the trail.\n@param        InSecondSocketName      The name of the second socket for the trail.\n@param        InWidthMode                     How the width value is applied to the trail.\n@param        InWidth                         The width of the trail."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_CreateNamedDynamicMaterialInstance()
	{
		struct ParticleSystemComponent_eventCreateNamedDynamicMaterialInstance_Parms
		{
			FName InName;
			UMaterialInterface* SourceMaterial;
			UMaterialInstanceDynamic* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateNamedDynamicMaterialInstance"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(ParticleSystemComponent_eventCreateNamedDynamicMaterialInstance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, ParticleSystemComponent_eventCreateNamedDynamicMaterialInstance_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister());
			UProperty* NewProp_SourceMaterial = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SourceMaterial, ParticleSystemComponent_eventCreateNamedDynamicMaterialInstance_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_InName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InName, ParticleSystemComponent_eventCreateNamedDynamicMaterialInstance_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a Dynamic Material Instance for the specified named material override, optionally from the supplied material.\n@param Name - The slot name of the material to replace.  If invalid, the material is unchanged and NULL is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_EndTrails()
	{
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EndTrails"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Particles|Trails"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Ends all trail emitters in this component."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_GenerateParticleEvent()
	{
		struct ParticleSystemComponent_eventGenerateParticleEvent_Parms
		{
			FName InEventName;
			float InEmitterTime;
			FVector InLocation;
			FVector InDirection;
			FVector InVelocity;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GenerateParticleEvent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(ParticleSystemComponent_eventGenerateParticleEvent_Parms));
			UProperty* NewProp_InVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InVelocity, ParticleSystemComponent_eventGenerateParticleEvent_Parms), 0x0000000000000082, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDirection"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InDirection, ParticleSystemComponent_eventGenerateParticleEvent_Parms), 0x0000000000000082, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InLocation, ParticleSystemComponent_eventGenerateParticleEvent_Parms), 0x0000000000000082, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InEmitterTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InEmitterTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InEmitterTime, ParticleSystemComponent_eventGenerateParticleEvent_Parms), 0x0000000000000082);
			UProperty* NewProp_InEventName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InEventName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InEventName, ParticleSystemComponent_eventGenerateParticleEvent_Parms), 0x0000000000000082);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Record a kismet event.\n\n@param  InEventName                             The name of the event that fired.\n@param  InEmitterTime                   The emitter time when the event fired.\n@param  InLocation                              The location of the particle when the event fired.\n@param  InVelocity                              The velocity of the particle when the event fired.\n@param  InNormal                                Normal vector of the collision in coordinate system of the returner. Zero=none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_GetNamedMaterial()
	{
		struct ParticleSystemComponent_eventGetNamedMaterial_Parms
		{
			FName InName;
			UMaterialInterface* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetNamedMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(ParticleSystemComponent_eventGetNamedMaterial_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, ParticleSystemComponent_eventGetNamedMaterial_Parms), 0x0000000000000580, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_InName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InName, ParticleSystemComponent_eventGetNamedMaterial_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Material"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a named material. If this named material is not found, returns NULL."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_GetNumActiveParticles()
	{
		struct ParticleSystemComponent_eventGetNumActiveParticles_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetNumActiveParticles"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(ParticleSystemComponent_eventGetNumActiveParticles_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, ParticleSystemComponent_eventGetNumActiveParticles_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current number of active particles in this system"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetActorParameter()
	{
		struct ParticleSystemComponent_eventSetActorParameter_Parms
		{
			FName ParameterName;
			AActor* Param;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetActorParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystemComponent_eventSetActorParameter_Parms));
			UProperty* NewProp_Param = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Param"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Param, ParticleSystemComponent_eventSetActorParameter_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_ParameterName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ParameterName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParameterName, ParticleSystemComponent_eventSetActorParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a named actor instance parameter on this ParticleSystemComponent.\nUpdates the parameter if it already exists, or creates a new entry if not."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamEndPoint()
	{
		struct ParticleSystemComponent_eventSetBeamEndPoint_Parms
		{
			int32 EmitterIndex;
			FVector NewEndPoint;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamEndPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ParticleSystemComponent_eventSetBeamEndPoint_Parms));
			UProperty* NewProp_NewEndPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewEndPoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewEndPoint, ParticleSystemComponent_eventSetBeamEndPoint_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamEndPoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam end point\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewEndPoint                     The value to set it to"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourcePoint()
	{
		struct ParticleSystemComponent_eventSetBeamSourcePoint_Parms
		{
			int32 EmitterIndex;
			FVector NewSourcePoint;
			int32 SourceIndex;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamSourcePoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ParticleSystemComponent_eventSetBeamSourcePoint_Parms));
			UProperty* NewProp_SourceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SourceIndex, ParticleSystemComponent_eventSetBeamSourcePoint_Parms), 0x0000000000000080);
			UProperty* NewProp_NewSourcePoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSourcePoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewSourcePoint, ParticleSystemComponent_eventSetBeamSourcePoint_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamSourcePoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam source point\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewSourcePoint          The value to set it to\n@param  SourceIndex                     Which beam within the emitter to set it on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceStrength()
	{
		struct ParticleSystemComponent_eventSetBeamSourceStrength_Parms
		{
			int32 EmitterIndex;
			float NewSourceStrength;
			int32 SourceIndex;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamSourceStrength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(ParticleSystemComponent_eventSetBeamSourceStrength_Parms));
			UProperty* NewProp_SourceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SourceIndex, ParticleSystemComponent_eventSetBeamSourceStrength_Parms), 0x0000000000000080);
			UProperty* NewProp_NewSourceStrength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewSourceStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewSourceStrength, ParticleSystemComponent_eventSetBeamSourceStrength_Parms), 0x0000000000000080);
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamSourceStrength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam source strength\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewSourceStrength       The value to set it to\n@param  SourceIndex                     Which beam within the emitter to set it on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceTangent()
	{
		struct ParticleSystemComponent_eventSetBeamSourceTangent_Parms
		{
			int32 EmitterIndex;
			FVector NewTangentPoint;
			int32 SourceIndex;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamSourceTangent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ParticleSystemComponent_eventSetBeamSourceTangent_Parms));
			UProperty* NewProp_SourceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SourceIndex, ParticleSystemComponent_eventSetBeamSourceTangent_Parms), 0x0000000000000080);
			UProperty* NewProp_NewTangentPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTangentPoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewTangentPoint, ParticleSystemComponent_eventSetBeamSourceTangent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamSourceTangent_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam source tangent\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewTangentPoint         The value to set it to\n@param  SourceIndex                     Which beam within the emitter to set it on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetPoint()
	{
		struct ParticleSystemComponent_eventSetBeamTargetPoint_Parms
		{
			int32 EmitterIndex;
			FVector NewTargetPoint;
			int32 TargetIndex;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamTargetPoint"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ParticleSystemComponent_eventSetBeamTargetPoint_Parms));
			UProperty* NewProp_TargetIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TargetIndex, ParticleSystemComponent_eventSetBeamTargetPoint_Parms), 0x0000000000000080);
			UProperty* NewProp_NewTargetPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTargetPoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewTargetPoint, ParticleSystemComponent_eventSetBeamTargetPoint_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamTargetPoint_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam target point\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewTargetPoint          The value to set it to\n@param  TargetIndex                     Which beam within the emitter to set it on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetStrength()
	{
		struct ParticleSystemComponent_eventSetBeamTargetStrength_Parms
		{
			int32 EmitterIndex;
			float NewTargetStrength;
			int32 TargetIndex;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamTargetStrength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(ParticleSystemComponent_eventSetBeamTargetStrength_Parms));
			UProperty* NewProp_TargetIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TargetIndex, ParticleSystemComponent_eventSetBeamTargetStrength_Parms), 0x0000000000000080);
			UProperty* NewProp_NewTargetStrength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTargetStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewTargetStrength, ParticleSystemComponent_eventSetBeamTargetStrength_Parms), 0x0000000000000080);
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamTargetStrength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam target strength\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewTargetStrength       The value to set it to\n@param  TargetIndex                     Which beam within the emitter to set it on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetTangent()
	{
		struct ParticleSystemComponent_eventSetBeamTargetTangent_Parms
		{
			int32 EmitterIndex;
			FVector NewTangentPoint;
			int32 TargetIndex;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBeamTargetTangent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(ParticleSystemComponent_eventSetBeamTargetTangent_Parms));
			UProperty* NewProp_TargetIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TargetIndex, ParticleSystemComponent_eventSetBeamTargetTangent_Parms), 0x0000000000000080);
			UProperty* NewProp_NewTangentPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTangentPoint"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NewTangentPoint, ParticleSystemComponent_eventSetBeamTargetTangent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_EmitterIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EmitterIndex, ParticleSystemComponent_eventSetBeamTargetTangent_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the beam target tangent\n\n@param  EmitterIndex            The index of the emitter to set it on\n@param  NewTangentPoint         The value to set it to\n@param  TargetIndex                     Which beam within the emitter to set it on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetColorParameter()
	{
		struct ParticleSystemComponent_eventSetColorParameter_Parms
		{
			FName ParameterName;
			FLinearColor Param;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetColorParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(ParticleSystemComponent_eventSetColorParameter_Parms));
			UProperty* NewProp_Param = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Param"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Param, ParticleSystemComponent_eventSetColorParameter_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_ParameterName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ParameterName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParameterName, ParticleSystemComponent_eventSetColorParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a named color instance parameter on this ParticleSystemComponent.\nUpdates the parameter if it already exists, or creates a new entry if not."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetEmitterEnable()
	{
		struct ParticleSystemComponent_eventSetEmitterEnable_Parms
		{
			FName EmitterName;
			bool bNewEnableState;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEmitterEnable"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(ParticleSystemComponent_eventSetEmitterEnable_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewEnableState, ParticleSystemComponent_eventSetEmitterEnable_Parms, bool);
			UProperty* NewProp_bNewEnableState = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewEnableState"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewEnableState, ParticleSystemComponent_eventSetEmitterEnable_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewEnableState, ParticleSystemComponent_eventSetEmitterEnable_Parms), sizeof(bool), true);
			UProperty* NewProp_EmitterName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitterName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(EmitterName, ParticleSystemComponent_eventSetEmitterEnable_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables/Disables a sub-emitter\n\n@param  EmitterName                     The name of the sub-emitter to set it on\n@param  bNewEnableState         The value to set it to"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetFloatParameter()
	{
		struct ParticleSystemComponent_eventSetFloatParameter_Parms
		{
			FName ParameterName;
			float Param;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFloatParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystemComponent_eventSetFloatParameter_Parms));
			UProperty* NewProp_Param = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Param"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Param, ParticleSystemComponent_eventSetFloatParameter_Parms), 0x0000000000000080);
			UProperty* NewProp_ParameterName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ParameterName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParameterName, ParticleSystemComponent_eventSetFloatParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change a named float parameter"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetMaterialParameter()
	{
		struct ParticleSystemComponent_eventSetMaterialParameter_Parms
		{
			FName ParameterName;
			UMaterialInterface* Param;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMaterialParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystemComponent_eventSetMaterialParameter_Parms));
			UProperty* NewProp_Param = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Param"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Param, ParticleSystemComponent_eventSetMaterialParameter_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			UProperty* NewProp_ParameterName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ParameterName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParameterName, ParticleSystemComponent_eventSetMaterialParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a named material instance parameter on this ParticleSystemComponent.\nUpdates the parameter if it already exists, or creates a new entry if not."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetTemplate()
	{
		struct ParticleSystemComponent_eventSetTemplate_Parms
		{
			UParticleSystem* NewTemplate;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTemplate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystemComponent_eventSetTemplate_Parms));
			UProperty* NewProp_NewTemplate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTemplate"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(NewTemplate, ParticleSystemComponent_eventSetTemplate_Parms), 0x0000000000000080, Z_Construct_UClass_UParticleSystem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the ParticleSystem used by this ParticleSystemComponent"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetTrailSourceData()
	{
		struct ParticleSystemComponent_eventSetTrailSourceData_Parms
		{
			FName InFirstSocketName;
			FName InSecondSocketName;
			TEnumAsByte<ETrailWidthMode> InWidthMode;
			float InWidth;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTrailSourceData"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ParticleSystemComponent_eventSetTrailSourceData_Parms));
			UProperty* NewProp_InWidth = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWidth"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWidth, ParticleSystemComponent_eventSetTrailSourceData_Parms), 0x0000000000000080);
			UProperty* NewProp_InWidthMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWidthMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(InWidthMode, ParticleSystemComponent_eventSetTrailSourceData_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ETrailWidthMode());
			UProperty* NewProp_InSecondSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSecondSocketName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InSecondSocketName, ParticleSystemComponent_eventSetTrailSourceData_Parms), 0x0000000000000080);
			UProperty* NewProp_InFirstSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InFirstSocketName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(InFirstSocketName, ParticleSystemComponent_eventSetTrailSourceData_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Particles|Trails"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the defining data for all trails in this component.\n\n@param        InFirstSocketName       The name of the first socket for the trail.\n@param        InSecondSocketName      The name of the second socket for the trail.\n@param        InWidthMode                     How the width value is applied to the trail.\n@param        InWidth                         The width of the trail."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UParticleSystemComponent_SetVectorParameter()
	{
		struct ParticleSystemComponent_eventSetVectorParameter_Parms
		{
			FName ParameterName;
			FVector Param;
		};
		UObject* Outer=Z_Construct_UClass_UParticleSystemComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetVectorParameter"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(ParticleSystemComponent_eventSetVectorParameter_Parms));
			UProperty* NewProp_Param = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Param"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Param, ParticleSystemComponent_eventSetVectorParameter_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ParameterName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ParameterName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(ParameterName, ParticleSystemComponent_eventSetVectorParameter_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|ParticleSystem"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a named vector instance parameter on this ParticleSystemComponent.\nUpdates the parameter if it already exists, or creates a new entry if not."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UParticleSystemComponent_NoRegister()
	{
		return UParticleSystemComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UParticleSystemComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UParticleSystemComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_BeginTrails());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_CreateNamedDynamicMaterialInstance());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_EndTrails());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_GenerateParticleEvent());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_GetNamedMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_GetNumActiveParticles());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetActorParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamEndPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourcePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceStrength());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceTangent());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetStrength());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetTangent());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetColorParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetEmitterEnable());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetFloatParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetMaterialParameter());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetTemplate());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetTrailSourceData());
				OuterClass->LinkChild(Z_Construct_UFunction_UParticleSystemComponent_SetVectorParameter());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnSystemFinished = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnSystemFinished"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnSystemFinished, UParticleSystemComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_OnSystemFinished__DelegateSignature());
				UProperty* NewProp_CustomTimeDilation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomTimeDilation"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CustomTimeDilation, UParticleSystemComponent), 0x0000000000000005);
				UProperty* NewProp_ReplayClips = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplayClips"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReplayClips, UParticleSystemComponent), 0x0000000000000000);
				UProperty* NewProp_ReplayClips_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReplayClips, TEXT("ReplayClips"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UParticleSystemReplay_NoRegister());
				UProperty* NewProp_CachedViewRelevanceFlags = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CachedViewRelevanceFlags"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(CachedViewRelevanceFlags, UParticleSystemComponent), 0x0000000000002000);
				UProperty* NewProp_CachedViewRelevanceFlags_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CachedViewRelevanceFlags, TEXT("CachedViewRelevanceFlags"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FMaterialRelevance());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSkipUpdateDynamicDataDuringTick, UParticleSystemComponent, uint8);
				UProperty* NewProp_bSkipUpdateDynamicDataDuringTick = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSkipUpdateDynamicDataDuringTick"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSkipUpdateDynamicDataDuringTick, UParticleSystemComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bSkipUpdateDynamicDataDuringTick, UParticleSystemComponent), sizeof(uint8), false);
				UProperty* NewProp_LODMethod = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LODMethod"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LODMethod, UParticleSystemComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_ParticleSystemLODMethod());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideLODMethod, UParticleSystemComponent, uint8);
				UProperty* NewProp_bOverrideLODMethod = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideLODMethod"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideLODMethod, UParticleSystemComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bOverrideLODMethod, UParticleSystemComponent), sizeof(uint8), false);
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_EditorDetailMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EditorDetailMode"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EditorDetailMode, UParticleSystemComponent), 0x0000000800000000);
				UProperty* NewProp_EditorLODLevel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EditorLODLevel"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EditorLODLevel, UParticleSystemComponent), 0x0000000800000000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_MaxTimeBeforeForceUpdateTransform = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxTimeBeforeForceUpdateTransform"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxTimeBeforeForceUpdateTransform, UParticleSystemComponent), 0x0000000000000000);
				UProperty* NewProp_SecondsBeforeInactive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SecondsBeforeInactive"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SecondsBeforeInactive, UParticleSystemComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWarmingUp, UParticleSystemComponent, uint8);
				UProperty* NewProp_bWarmingUp = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWarmingUp"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWarmingUp, UParticleSystemComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bWarmingUp, UParticleSystemComponent), sizeof(uint8), false);
				UProperty* NewProp_WarmupTickRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WarmupTickRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WarmupTickRate, UParticleSystemComponent), 0x0000000000000000);
				UProperty* NewProp_WarmupTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WarmupTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WarmupTime, UParticleSystemComponent), 0x0000000000000000);
				UProperty* NewProp_PartSysVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PartSysVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PartSysVelocity, UParticleSystemComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_OldPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OldPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OldPosition, UParticleSystemComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_OnParticleCollide = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnParticleCollide"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnParticleCollide, UParticleSystemComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ParticleCollisionSignature__DelegateSignature());
				UProperty* NewProp_OnParticleDeath = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnParticleDeath"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnParticleDeath, UParticleSystemComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ParticleDeathSignature__DelegateSignature());
				UProperty* NewProp_OnParticleBurst = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnParticleBurst"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnParticleBurst, UParticleSystemComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ParticleBurstSignature__DelegateSignature());
				UProperty* NewProp_OnParticleSpawn = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnParticleSpawn"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnParticleSpawn, UParticleSystemComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Engine_ParticleSpawnSignature__DelegateSignature());
				UProperty* NewProp_InstanceParameters = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstanceParameters"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InstanceParameters, UParticleSystemComponent), 0x0000000000000005);
				UProperty* NewProp_InstanceParameters_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InstanceParameters, TEXT("InstanceParameters"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FParticleSysParam());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOnDedicatedServer, UParticleSystemComponent, uint8);
				UProperty* NewProp_bUpdateOnDedicatedServer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUpdateOnDedicatedServer"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOnDedicatedServer, UParticleSystemComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bUpdateOnDedicatedServer, UParticleSystemComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bResetOnDetach, UParticleSystemComponent, uint8);
				UProperty* NewProp_bResetOnDetach = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bResetOnDetach"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bResetOnDetach, UParticleSystemComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bResetOnDetach, UParticleSystemComponent), sizeof(uint8), false);
				UProperty* NewProp_SkelMeshComponents = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SkelMeshComponents"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(SkelMeshComponents, UParticleSystemComponent), 0x0000008000202008);
				UProperty* NewProp_SkelMeshComponents_Inner = new(EC_InternalUseOnlyConstructor, NewProp_SkelMeshComponents, TEXT("SkelMeshComponents"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000080008, Z_Construct_UClass_USkeletalMeshComponent_NoRegister());
				UProperty* NewProp_EmitterMaterials = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EmitterMaterials"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(EmitterMaterials, UParticleSystemComponent), 0x0000000000202000);
				UProperty* NewProp_EmitterMaterials_Inner = new(EC_InternalUseOnlyConstructor, NewProp_EmitterMaterials, TEXT("EmitterMaterials"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UMaterialInterface_NoRegister());
				UProperty* NewProp_Template = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Template"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Template, UParticleSystemComponent), 0x0000000000000015, Z_Construct_UClass_UParticleSystem_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_BeginTrails()); // 3161955261
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_CreateNamedDynamicMaterialInstance()); // 1521732003
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_EndTrails()); // 1234711928
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_GenerateParticleEvent()); // 1907864282
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_GetNamedMaterial()); // 2836781621
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_GetNumActiveParticles()); // 1248252636
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetActorParameter()); // 910327138
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamEndPoint()); // 3065390861
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourcePoint()); // 4104341820
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceStrength()); // 2912775044
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamSourceTangent()); // 4227753523
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetPoint()); // 3037058553
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetStrength()); // 3642045830
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetBeamTargetTangent()); // 873835519
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetColorParameter()); // 469912256
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetEmitterEnable()); // 1821226365
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetFloatParameter()); // 1080263884
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetMaterialParameter()); // 39032732
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetTemplate()); // 832355426
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetTrailSourceData()); // 3902242204
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UParticleSystemComponent_SetVectorParameter()); // 62457920
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering Common"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Physics Collision Mobility ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A particle emitter."));
				MetaData->SetValue(NewProp_OnSystemFinished, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_OnSystemFinished, TEXT("ToolTip"), TEXT("Called when the particle system is done"));
				MetaData->SetValue(NewProp_CustomTimeDilation, TEXT("Category"), TEXT("Particles"));
				MetaData->SetValue(NewProp_CustomTimeDilation, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_CustomTimeDilation, TEXT("ToolTip"), TEXT("Scales DeltaTime in UParticleSystemComponent::Tick(...)"));
				MetaData->SetValue(NewProp_ReplayClips, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_ReplayClips, TEXT("ToolTip"), TEXT("Array of replay clips for this particle system component.  These are serialized to disk.  You really should never add anything to this in the editor.  It's exposed so that you can delete clips if you need to, but be careful when doing so!"));
				MetaData->SetValue(NewProp_CachedViewRelevanceFlags, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_CachedViewRelevanceFlags, TEXT("ToolTip"), TEXT("The view relevance flags for each LODLevel."));
				MetaData->SetValue(NewProp_bSkipUpdateDynamicDataDuringTick, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_bSkipUpdateDynamicDataDuringTick, TEXT("ToolTip"), TEXT("Flag indicating that dynamic updating of render data should NOT occur during Tick.\nThis is used primarily to allow for warming up and simulated effects to a certain state."));
				MetaData->SetValue(NewProp_LODMethod, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_LODMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_LODMethod, TEXT("ToolTip"), TEXT("The method of LOD level determination to utilize for this particle system"));
				MetaData->SetValue(NewProp_bOverrideLODMethod, TEXT("Category"), TEXT("LOD"));
				MetaData->SetValue(NewProp_bOverrideLODMethod, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_bOverrideLODMethod, TEXT("ToolTip"), TEXT("indicates that the component's LODMethod overrides the Template's"));
				MetaData->SetValue(NewProp_EditorDetailMode, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_EditorDetailMode, TEXT("ToolTip"), TEXT("Used for applying Cascade's detail mode setting to in-level particle systems"));
				MetaData->SetValue(NewProp_EditorLODLevel, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_EditorLODLevel, TEXT("ToolTip"), TEXT("INTERNAL. Used by the editor to set the LODLevel"));
				MetaData->SetValue(NewProp_MaxTimeBeforeForceUpdateTransform, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_MaxTimeBeforeForceUpdateTransform, TEXT("ToolTip"), TEXT("Time between forced UpdateTransforms for systems that use dynamically calculated bounds,\nWhich is effectively how often the bounds are shrunk."));
				MetaData->SetValue(NewProp_SecondsBeforeInactive, TEXT("Category"), TEXT("Particles"));
				MetaData->SetValue(NewProp_SecondsBeforeInactive, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_SecondsBeforeInactive, TEXT("ToolTip"), TEXT("Number of seconds of emitter not being rendered that need to pass before it\nno longer gets ticked/ becomes inactive."));
				MetaData->SetValue(NewProp_bWarmingUp, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_WarmupTickRate, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_WarmupTime, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_PartSysVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_OldPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_OnParticleCollide, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_OnParticleDeath, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_OnParticleBurst, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_OnParticleSpawn, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_InstanceParameters, TEXT("Category"), TEXT("Particles"));
				MetaData->SetValue(NewProp_InstanceParameters, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_InstanceParameters, TEXT("ToolTip"), TEXT("Array holding name instance parameters for this ParticleSystemComponent.\nParameters can be used in Cascade using DistributionFloat/VectorParticleParameters."));
				MetaData->SetValue(NewProp_bUpdateOnDedicatedServer, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_bUpdateOnDedicatedServer, TEXT("ToolTip"), TEXT("whether to update the particle system on dedicated servers"));
				MetaData->SetValue(NewProp_bResetOnDetach, TEXT("Category"), TEXT("Particles"));
				MetaData->SetValue(NewProp_bResetOnDetach, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_SkelMeshComponents, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_SkelMeshComponents, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_SkelMeshComponents, TEXT("ToolTip"), TEXT("The skeletal mesh components used with the socket location module.\nThis is to prevent them from being garbage collected."));
				MetaData->SetValue(NewProp_EmitterMaterials, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
				MetaData->SetValue(NewProp_Template, TEXT("Category"), TEXT("Particles"));
				MetaData->SetValue(NewProp_Template, TEXT("ModuleRelativePath"), TEXT("Classes/Particles/ParticleSystemComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UParticleSystemComponent(Z_Construct_UClass_UParticleSystemComponent, TEXT("UParticleSystemComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UParticleSystemComponent);
	UClass* Z_Construct_UClass_UShapeComponent_NoRegister()
	{
		return UShapeComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UShapeComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UShapeComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_AreaClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AreaClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(AreaClass, UShapeComponent), 0x0004000000000001, Z_Construct_UClass_UNavArea_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDynamicObstacle, UShapeComponent, uint8);
				UProperty* NewProp_bDynamicObstacle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDynamicObstacle"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDynamicObstacle, UShapeComponent), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bDynamicObstacle, UShapeComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldCollideWhenPlacing, UShapeComponent, uint8);
				UProperty* NewProp_bShouldCollideWhenPlacing = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldCollideWhenPlacing"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldCollideWhenPlacing, UShapeComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bShouldCollideWhenPlacing, UShapeComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawOnlyIfSelected, UShapeComponent, uint8);
				UProperty* NewProp_bDrawOnlyIfSelected = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawOnlyIfSelected"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawOnlyIfSelected, UShapeComponent), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDrawOnlyIfSelected, UShapeComponent), sizeof(uint8), false);
				UProperty* NewProp_ShapeBodySetup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShapeBodySetup"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ShapeBodySetup, UShapeComponent), 0x0000000000202000, Z_Construct_UClass_UBodySetup_NoRegister());
				UProperty* NewProp_ShapeColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShapeColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ShapeColor, UShapeComponent), 0x0000040000000015, Z_Construct_UScriptStruct_FColor());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ShapeComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("ShapeComponent is a PrimitiveComponent that is represented by a simple geometrical shape (sphere, capsule, box, etc)."));
				MetaData->SetValue(NewProp_AreaClass, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_AreaClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(NewProp_AreaClass, TEXT("ToolTip"), TEXT("Navigation area type (empty = default obstacle)"));
				MetaData->SetValue(NewProp_bDynamicObstacle, TEXT("Category"), TEXT("Navigation"));
				MetaData->SetValue(NewProp_bDynamicObstacle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(NewProp_bDynamicObstacle, TEXT("ToolTip"), TEXT("If set, shape will be exported for navigation as dynamic modifier instead of using regular collision data"));
				MetaData->SetValue(NewProp_bShouldCollideWhenPlacing, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(NewProp_bShouldCollideWhenPlacing, TEXT("ToolTip"), TEXT("If true it allows Collision when placing even if collision is not enabled"));
				MetaData->SetValue(NewProp_bDrawOnlyIfSelected, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(NewProp_bDrawOnlyIfSelected, TEXT("ToolTip"), TEXT("Only show this component if the actor is selected"));
				MetaData->SetValue(NewProp_ShapeBodySetup, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(NewProp_ShapeBodySetup, TEXT("ToolTip"), TEXT("Description of collision"));
				MetaData->SetValue(NewProp_ShapeColor, TEXT("Category"), TEXT("Shape"));
				MetaData->SetValue(NewProp_ShapeColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ShapeComponent.h"));
				MetaData->SetValue(NewProp_ShapeColor, TEXT("ToolTip"), TEXT("Color used to draw the shape."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UShapeComponent(Z_Construct_UClass_UShapeComponent, TEXT("UShapeComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UShapeComponent);
	UFunction* Z_Construct_UFunction_UBoxComponent_GetScaledBoxExtent()
	{
		struct BoxComponent_eventGetScaledBoxExtent_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaledBoxExtent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(BoxComponent_eventGetScaledBoxExtent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, BoxComponent_eventGetScaledBoxExtent_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Box"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the box extent, scaled by the component scale."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UBoxComponent_GetUnscaledBoxExtent()
	{
		struct BoxComponent_eventGetUnscaledBoxExtent_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUnscaledBoxExtent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(BoxComponent_eventGetUnscaledBoxExtent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, BoxComponent_eventGetUnscaledBoxExtent_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Box"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the box extent, ignoring component scale."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UBoxComponent_SetBoxExtent()
	{
		struct BoxComponent_eventSetBoxExtent_Parms
		{
			FVector InBoxExtent;
			bool bUpdateOverlaps;
		};
		UObject* Outer=Z_Construct_UClass_UBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetBoxExtent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(BoxComponent_eventSetBoxExtent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOverlaps, BoxComponent_eventSetBoxExtent_Parms, bool);
			UProperty* NewProp_bUpdateOverlaps = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUpdateOverlaps"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOverlaps, BoxComponent_eventSetBoxExtent_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUpdateOverlaps, BoxComponent_eventSetBoxExtent_Parms), sizeof(bool), true);
			UProperty* NewProp_InBoxExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBoxExtent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(InBoxExtent, BoxComponent_eventSetBoxExtent_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Box"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUpdateOverlaps"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the box extent size. This is the unscaled size, before component scale is applied.\n@param       InBoxExtent: new extent (radius) for the box.\n@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UBoxComponent_NoRegister()
	{
		return UBoxComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBoxComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UShapeComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UBoxComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UBoxComponent_GetScaledBoxExtent());
				OuterClass->LinkChild(Z_Construct_UFunction_UBoxComponent_GetUnscaledBoxExtent());
				OuterClass->LinkChild(Z_Construct_UFunction_UBoxComponent_SetBoxExtent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BoxExtent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoxExtent"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BoxExtent, UBoxComponent), 0x000008000000001d, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UBoxComponent_GetScaledBoxExtent()); // 2045249051
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UBoxComponent_GetUnscaledBoxExtent()); // 1081305585
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UBoxComponent_SetBoxExtent()); // 3317931177
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Collision"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Box Collision"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/BoxComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A box generally used for simple collision. Bounds are rendered as lines in the editor."));
				MetaData->SetValue(NewProp_BoxExtent, TEXT("Category"), TEXT("Shape"));
				MetaData->SetValue(NewProp_BoxExtent, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxComponent.h"));
				MetaData->SetValue(NewProp_BoxExtent, TEXT("ToolTip"), TEXT("The extents (radii dimensions) of the box *"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBoxComponent(Z_Construct_UClass_UBoxComponent, TEXT("UBoxComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBoxComponent);
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleHalfHeight()
	{
		struct CapsuleComponent_eventGetScaledCapsuleHalfHeight_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaledCapsuleHalfHeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CapsuleComponent_eventGetScaledCapsuleHalfHeight_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CapsuleComponent_eventGetScaledCapsuleHalfHeight_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the capsule half height scaled by the component scale."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleRadius()
	{
		struct CapsuleComponent_eventGetScaledCapsuleRadius_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaledCapsuleRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CapsuleComponent_eventGetScaledCapsuleRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CapsuleComponent_eventGetScaledCapsuleRadius_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the capsule radius scaled by the component scale."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleSize()
	{
		struct CapsuleComponent_eventGetScaledCapsuleSize_Parms
		{
			float OutRadius;
			float OutHalfHeight;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaledCapsuleSize"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420401, 65535, sizeof(CapsuleComponent_eventGetScaledCapsuleSize_Parms));
			UProperty* NewProp_OutHalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHalfHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutHalfHeight, CapsuleComponent_eventGetScaledCapsuleSize_Parms), 0x0000000000000180);
			UProperty* NewProp_OutRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutRadius, CapsuleComponent_eventGetScaledCapsuleSize_Parms), 0x0000000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the capsule radius and half height scaled by the component scale."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetShapeScale()
	{
		struct CapsuleComponent_eventGetShapeScale_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetShapeScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CapsuleComponent_eventGetShapeScale_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CapsuleComponent_eventGetShapeScale_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the scale used by this shape. This is a uniform scale that is the minimum of any non-uniform scaling.\n@return the scale used by this shape."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleHalfHeight()
	{
		struct CapsuleComponent_eventGetUnscaledCapsuleHalfHeight_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUnscaledCapsuleHalfHeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CapsuleComponent_eventGetUnscaledCapsuleHalfHeight_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CapsuleComponent_eventGetUnscaledCapsuleHalfHeight_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the capsule half height, ignoring component scaling."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleRadius()
	{
		struct CapsuleComponent_eventGetUnscaledCapsuleRadius_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUnscaledCapsuleRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(CapsuleComponent_eventGetUnscaledCapsuleRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, CapsuleComponent_eventGetUnscaledCapsuleRadius_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the capsule radius, ignoring component scaling."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleSize()
	{
		struct CapsuleComponent_eventGetUnscaledCapsuleSize_Parms
		{
			float OutRadius;
			float OutHalfHeight;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUnscaledCapsuleSize"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420401, 65535, sizeof(CapsuleComponent_eventGetUnscaledCapsuleSize_Parms));
			UProperty* NewProp_OutHalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHalfHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutHalfHeight, CapsuleComponent_eventGetUnscaledCapsuleSize_Parms), 0x0000000000000180);
			UProperty* NewProp_OutRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutRadius, CapsuleComponent_eventGetUnscaledCapsuleSize_Parms), 0x0000000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the capsule radius and half height, ignoring component scaling."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_SetCapsuleHalfHeight()
	{
		struct CapsuleComponent_eventSetCapsuleHalfHeight_Parms
		{
			float HalfHeight;
			bool bUpdateOverlaps;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCapsuleHalfHeight"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CapsuleComponent_eventSetCapsuleHalfHeight_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleHalfHeight_Parms, bool);
			UProperty* NewProp_bUpdateOverlaps = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUpdateOverlaps"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleHalfHeight_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleHalfHeight_Parms), sizeof(bool), true);
			UProperty* NewProp_HalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HalfHeight, CapsuleComponent_eventSetCapsuleHalfHeight_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUpdateOverlaps"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the capsule half-height. This is the unscaled half-height, before component scale is applied.\nIf this capsule collides, updates touching array for owner actor.\n@param       HalfHeight : half-height, from capsule center to end of top or bottom hemisphere.\n@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_SetCapsuleRadius()
	{
		struct CapsuleComponent_eventSetCapsuleRadius_Parms
		{
			float Radius;
			bool bUpdateOverlaps;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCapsuleRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CapsuleComponent_eventSetCapsuleRadius_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleRadius_Parms, bool);
			UProperty* NewProp_bUpdateOverlaps = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUpdateOverlaps"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleRadius_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleRadius_Parms), sizeof(bool), true);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, CapsuleComponent_eventSetCapsuleRadius_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUpdateOverlaps"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the capsule radius. This is the unscaled radius, before component scale is applied.\nIf this capsule collides, updates touching array for owner actor.\n@param       Radius : radius of end-cap hemispheres and center cylinder.\n@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UCapsuleComponent_SetCapsuleSize()
	{
		struct CapsuleComponent_eventSetCapsuleSize_Parms
		{
			float InRadius;
			float InHalfHeight;
			bool bUpdateOverlaps;
		};
		UObject* Outer=Z_Construct_UClass_UCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCapsuleSize"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(CapsuleComponent_eventSetCapsuleSize_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleSize_Parms, bool);
			UProperty* NewProp_bUpdateOverlaps = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUpdateOverlaps"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleSize_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUpdateOverlaps, CapsuleComponent_eventSetCapsuleSize_Parms), sizeof(bool), true);
			UProperty* NewProp_InHalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InHalfHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InHalfHeight, CapsuleComponent_eventSetCapsuleSize_Parms), 0x0000000000000080);
			UProperty* NewProp_InRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InRadius, CapsuleComponent_eventSetCapsuleSize_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Capsule"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUpdateOverlaps"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the capsule size. This is the unscaled size, before component scale is applied.\n@param       InRadius : radius of end-cap hemispheres and center cylinder.\n@param       InHalfHeight : half-height, from capsule center to end of top or bottom hemisphere.\n@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UCapsuleComponent_NoRegister()
	{
		return UCapsuleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UCapsuleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UShapeComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UCapsuleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleHalfHeight());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleSize());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetShapeScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleHalfHeight());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleSize());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_SetCapsuleHalfHeight());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_SetCapsuleRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_UCapsuleComponent_SetCapsuleSize());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CapsuleHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CapsuleHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CapsuleHeight_DEPRECATED, UCapsuleComponent), 0x0000080020000000);
				UProperty* NewProp_CapsuleRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CapsuleRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CapsuleRadius, UCapsuleComponent), 0x000008000000001d);
				UProperty* NewProp_CapsuleHalfHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CapsuleHalfHeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CapsuleHalfHeight, UCapsuleComponent), 0x000008000000001d);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleHalfHeight()); // 4164400790
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleRadius()); // 3602567447
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetScaledCapsuleSize()); // 1442179798
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetShapeScale()); // 3435366875
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleHalfHeight()); // 1222449049
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleRadius()); // 4020917425
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_GetUnscaledCapsuleSize()); // 1774563073
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_SetCapsuleHalfHeight()); // 1367222869
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_SetCapsuleRadius()); // 3235968502
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UCapsuleComponent_SetCapsuleSize()); // 738993163
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Collision"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Capsule Collision"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/CapsuleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A capsule generally used for simple collision. Bounds are rendered as lines in the editor."));
				MetaData->SetValue(NewProp_CapsuleHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
				MetaData->SetValue(NewProp_CapsuleRadius, TEXT("Category"), TEXT("Shape"));
				MetaData->SetValue(NewProp_CapsuleRadius, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CapsuleRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
				MetaData->SetValue(NewProp_CapsuleRadius, TEXT("ToolTip"), TEXT("Radius of cap hemispheres and center cylinder.\nThis cannot be more than CapsuleHalfHeight."));
				MetaData->SetValue(NewProp_CapsuleRadius, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CapsuleHalfHeight, TEXT("Category"), TEXT("Shape"));
				MetaData->SetValue(NewProp_CapsuleHalfHeight, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_CapsuleHalfHeight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/CapsuleComponent.h"));
				MetaData->SetValue(NewProp_CapsuleHalfHeight, TEXT("ToolTip"), TEXT("Half-height, from center of capsule to the end of top or bottom hemisphere.\nThis cannot be less than CapsuleRadius."));
				MetaData->SetValue(NewProp_CapsuleHalfHeight, TEXT("UIMin"), TEXT("0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UCapsuleComponent(Z_Construct_UClass_UCapsuleComponent, TEXT("UCapsuleComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UCapsuleComponent);
	UFunction* Z_Construct_UFunction_USphereComponent_GetScaledSphereRadius()
	{
		struct SphereComponent_eventGetScaledSphereRadius_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScaledSphereRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SphereComponent_eventGetScaledSphereRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SphereComponent_eventGetScaledSphereRadius_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Sphere"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the radius of the sphere, with component scale applied."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USphereComponent_GetShapeScale()
	{
		struct SphereComponent_eventGetShapeScale_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetShapeScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SphereComponent_eventGetShapeScale_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SphereComponent_eventGetShapeScale_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Sphere"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the scale used by this shape. This is a uniform scale that is the minimum of any non-uniform scaling.\n@return the scale used by this shape."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USphereComponent_GetUnscaledSphereRadius()
	{
		struct SphereComponent_eventGetUnscaledSphereRadius_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_USphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUnscaledSphereRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(SphereComponent_eventGetUnscaledSphereRadius_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, SphereComponent_eventGetUnscaledSphereRadius_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Sphere"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return the radius of the sphere, ignoring component scale."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USphereComponent_SetSphereRadius()
	{
		struct SphereComponent_eventSetSphereRadius_Parms
		{
			float InSphereRadius;
			bool bUpdateOverlaps;
		};
		UObject* Outer=Z_Construct_UClass_USphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetSphereRadius"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(SphereComponent_eventSetSphereRadius_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateOverlaps, SphereComponent_eventSetSphereRadius_Parms, bool);
			UProperty* NewProp_bUpdateOverlaps = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUpdateOverlaps"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateOverlaps, SphereComponent_eventSetSphereRadius_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bUpdateOverlaps, SphereComponent_eventSetSphereRadius_Parms), sizeof(bool), true);
			UProperty* NewProp_InSphereRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InSphereRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InSphereRadius, SphereComponent_eventSetSphereRadius_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Sphere"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUpdateOverlaps"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the sphere radius. This is the unscaled radius, before component scale is applied.\n@param       InSphereRadius: the new sphere radius\n@param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USphereComponent_NoRegister()
	{
		return USphereComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USphereComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UShapeComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USphereComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_USphereComponent_GetScaledSphereRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_USphereComponent_GetShapeScale());
				OuterClass->LinkChild(Z_Construct_UFunction_USphereComponent_GetUnscaledSphereRadius());
				OuterClass->LinkChild(Z_Construct_UFunction_USphereComponent_SetSphereRadius());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SphereRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SphereRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SphereRadius, USphereComponent), 0x000008000000001d);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USphereComponent_GetScaledSphereRadius()); // 4205550161
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USphereComponent_GetShapeScale()); // 2281795286
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USphereComponent_GetUnscaledSphereRadius()); // 2625039423
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USphereComponent_SetSphereRadius()); // 820871321
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Collision"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Sphere Collision"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SphereComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A sphere generally used for simple collision. Bounds are rendered as lines in the editor."));
				MetaData->SetValue(NewProp_SphereRadius, TEXT("Category"), TEXT("Shape"));
				MetaData->SetValue(NewProp_SphereRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereComponent.h"));
				MetaData->SetValue(NewProp_SphereRadius, TEXT("ToolTip"), TEXT("The radius of the sphere *"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USphereComponent(Z_Construct_UClass_USphereComponent, TEXT("USphereComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USphereComponent);
	UClass* Z_Construct_UClass_UDrawSphereComponent_NoRegister()
	{
		return UDrawSphereComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UDrawSphereComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USphereComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UDrawSphereComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A83080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/DrawSphereComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/DrawSphereComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A sphere generally used for simple collision. Bounds are rendered as lines in the editor."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UDrawSphereComponent(Z_Construct_UClass_UDrawSphereComponent, TEXT("UDrawSphereComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UDrawSphereComponent);
	UEnum* Z_Construct_UEnum_Engine_EVerticalTextAligment()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EVerticalTextAligment_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EVerticalTextAligment"), 0, Get_Z_Construct_UEnum_Engine_EVerticalTextAligment_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EVerticalTextAligment"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRTA_TextTop")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRTA_TextCenter")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRTA_TextBottom")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRTA_QuadTop")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRTA_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("EVRTA_QuadTop.DisplayName"), TEXT("Quad Top"));
			MetaData->SetValue(ReturnEnum, TEXT("EVRTA_TextBottom.DisplayName"), TEXT("Text Bottom"));
			MetaData->SetValue(ReturnEnum, TEXT("EVRTA_TextCenter.DisplayName"), TEXT("Text Center"));
			MetaData->SetValue(ReturnEnum, TEXT("EVRTA_TextTop.DisplayName"), TEXT("Text Top"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EVerticalTextAligment_CRC() { return 617088648U; }
	UEnum* Z_Construct_UEnum_Engine_EHorizTextAligment()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EHorizTextAligment_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EHorizTextAligment"), 0, Get_Z_Construct_UEnum_Engine_EHorizTextAligment_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EHorizTextAligment"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHTA_Left")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHTA_Center")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHTA_Right")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EHTA_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("EHTA_Center.DisplayName"), TEXT("Center"));
			MetaData->SetValue(ReturnEnum, TEXT("EHTA_Left.DisplayName"), TEXT("Left"));
			MetaData->SetValue(ReturnEnum, TEXT("EHTA_Right.DisplayName"), TEXT("Right"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EHorizTextAligment_CRC() { return 1596638001U; }
	UFunction* Z_Construct_UFunction_UTextRenderComponent_GetTextLocalSize()
	{
		struct TextRenderComponent_eventGetTextLocalSize_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTextLocalSize"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(TextRenderComponent_eventGetTextLocalSize_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, TextRenderComponent_eventGetTextLocalSize_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get local size of text"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_GetTextWorldSize()
	{
		struct TextRenderComponent_eventGetTextWorldSize_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTextWorldSize"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(TextRenderComponent_eventGetTextWorldSize_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, TextRenderComponent_eventGetTextWorldSize_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get world space size of text"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_K2_SetText()
	{
		struct TextRenderComponent_eventK2_SetText_Parms
		{
			FText Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("K2_SetText"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(TextRenderComponent_eventK2_SetText_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UTextProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventK2_SetText_Parms), 0x0000000008000182);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set Text"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the text value and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetFont()
	{
		struct TextRenderComponent_eventSetFont_Parms
		{
			UFont* Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFont"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetFont_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetFont_Parms), 0x0000000000000080, Z_Construct_UClass_UFont_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the font and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetHorizontalAlignment()
	{
		struct TextRenderComponent_eventSetHorizontalAlignment_Parms
		{
			TEnumAsByte<EHorizTextAligment> Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetHorizontalAlignment"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetHorizontalAlignment_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetHorizontalAlignment_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EHorizTextAligment());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the horizontal alignment and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetHorizSpacingAdjust()
	{
		struct TextRenderComponent_eventSetHorizSpacingAdjust_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetHorizSpacingAdjust"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetHorizSpacingAdjust_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetHorizSpacingAdjust_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the text horizontal spacing adjustment and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetText()
	{
		struct TextRenderComponent_eventSetText_Parms
		{
			FString Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetText"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetText_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetText_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecatedFunction"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DeprecationMessage"), TEXT("Use the SetText function taking an FText instead."));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Set Text (String)"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetTextMaterial()
	{
		struct TextRenderComponent_eventSetTextMaterial_Parms
		{
			UMaterialInterface* Material;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTextMaterial"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetTextMaterial_Parms));
			UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, TextRenderComponent_eventSetTextMaterial_Parms), 0x0000000000000080, Z_Construct_UClass_UMaterialInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the text material and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetTextRenderColor()
	{
		struct TextRenderComponent_eventSetTextRenderColor_Parms
		{
			FColor Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTextRenderColor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(TextRenderComponent_eventSetTextRenderColor_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetTextRenderColor_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the text render color and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetWorldSize()
	{
		struct TextRenderComponent_eventSetWorldSize_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetWorldSize"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetWorldSize_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetWorldSize_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the world size of the text and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetXScale()
	{
		struct TextRenderComponent_eventSetXScale_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetXScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetXScale_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetXScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the text X scale and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTextRenderComponent_SetYScale()
	{
		struct TextRenderComponent_eventSetYScale_Parms
		{
			float Value;
		};
		UObject* Outer=Z_Construct_UClass_UTextRenderComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetYScale"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TextRenderComponent_eventSetYScale_Parms));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Value"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Value, TextRenderComponent_eventSetYScale_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|Components|TextRender"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Change the text Y scale and signal the primitives to be rebuilt"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UTextRenderComponent_NoRegister()
	{
		return UTextRenderComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UTextRenderComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UTextRenderComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_GetTextLocalSize());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_GetTextWorldSize());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_K2_SetText());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetFont());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetHorizontalAlignment());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetHorizSpacingAdjust());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetText());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetTextMaterial());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetTextRenderColor());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetWorldSize());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetXScale());
				OuterClass->LinkChild(Z_Construct_UFunction_UTextRenderComponent_SetYScale());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAlwaysRenderAsText, UTextRenderComponent, uint8);
				UProperty* NewProp_bAlwaysRenderAsText = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAlwaysRenderAsText"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAlwaysRenderAsText, UTextRenderComponent), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bAlwaysRenderAsText, UTextRenderComponent), sizeof(uint8), false);
				UProperty* NewProp_HorizSpacingAdjust = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HorizSpacingAdjust"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HorizSpacingAdjust, UTextRenderComponent), 0x0000040000000015);
				UProperty* NewProp_InvDefaultSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InvDefaultSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InvDefaultSize, UTextRenderComponent), 0x0000000000000000);
				UProperty* NewProp_WorldSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WorldSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(WorldSize, UTextRenderComponent), 0x0000000000000015);
				UProperty* NewProp_YScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("YScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(YScale, UTextRenderComponent), 0x0000000000000015);
				UProperty* NewProp_XScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("XScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(XScale, UTextRenderComponent), 0x0000000000000015);
				UProperty* NewProp_TextRenderColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TextRenderColor"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TextRenderColor, UTextRenderComponent), 0x0000000000000015, Z_Construct_UScriptStruct_FColor());
				UProperty* NewProp_VerticalAlignment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VerticalAlignment"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(VerticalAlignment, UTextRenderComponent), 0x0000000000000015, Z_Construct_UEnum_Engine_EVerticalTextAligment());
				UProperty* NewProp_HorizontalAlignment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HorizontalAlignment"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(HorizontalAlignment, UTextRenderComponent), 0x0000000000000015, Z_Construct_UEnum_Engine_EHorizTextAligment());
				UProperty* NewProp_Font = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Font"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Font, UTextRenderComponent), 0x0000000000000015, Z_Construct_UClass_UFont_NoRegister());
				UProperty* NewProp_TextMaterial = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TextMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TextMaterial, UTextRenderComponent), 0x0000000000000015, Z_Construct_UClass_UMaterialInterface_NoRegister());
				UProperty* NewProp_Text = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Text"), RF_Public|RF_Transient|RF_Native) UTextProperty(CPP_PROPERTY_BASE(Text, UTextRenderComponent), 0x0000000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_GetTextLocalSize()); // 553000422
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_GetTextWorldSize()); // 1954940102
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_K2_SetText()); // 1307726831
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetFont()); // 3324479200
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetHorizontalAlignment()); // 4080964357
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetHorizSpacingAdjust()); // 1730180014
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetText()); // 2054491293
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetTextMaterial()); // 2778732035
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetTextRenderColor()); // 1616736201
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetWorldSize()); // 3753967439
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetXScale()); // 1544007892
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTextRenderComponent_SetYScale()); // 364820739
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Physics TextureStreaming Activation Components|Activation Collision Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/TextRenderComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Renders text in the world with given font. Contains usual font related attributes such as Scale, Alignment, Color etc."));
				MetaData->SetValue(NewProp_bAlwaysRenderAsText, TEXT("Category"), TEXT("Rendering"));
				MetaData->SetValue(NewProp_bAlwaysRenderAsText, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_bAlwaysRenderAsText, TEXT("ToolTip"), TEXT("Allows text to draw unmodified when using debug visualization modes. *"));
				MetaData->SetValue(NewProp_HorizSpacingAdjust, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_HorizSpacingAdjust, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_HorizSpacingAdjust, TEXT("ToolTip"), TEXT("Horizontal adjustment per character, default is 0.0"));
				MetaData->SetValue(NewProp_InvDefaultSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_InvDefaultSize, TEXT("ToolTip"), TEXT("The inverse of the Font's character height."));
				MetaData->SetValue(NewProp_WorldSize, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_WorldSize, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_WorldSize, TEXT("ToolTip"), TEXT("Vertical size of the fonts largest character in world units. Transform, XScale and YScale will affect final size."));
				MetaData->SetValue(NewProp_YScale, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_YScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_YScale, TEXT("ToolTip"), TEXT("Vertical scale, default is 1.0"));
				MetaData->SetValue(NewProp_XScale, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_XScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_XScale, TEXT("ToolTip"), TEXT("Horizontal scale, default is 1.0"));
				MetaData->SetValue(NewProp_TextRenderColor, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_TextRenderColor, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_TextRenderColor, TEXT("ToolTip"), TEXT("Color of the text, can be accessed as vertex color"));
				MetaData->SetValue(NewProp_VerticalAlignment, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_VerticalAlignment, TEXT("DisplayName"), TEXT("Vertical Alignment"));
				MetaData->SetValue(NewProp_VerticalAlignment, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_VerticalAlignment, TEXT("ToolTip"), TEXT("Vertical text alignment"));
				MetaData->SetValue(NewProp_HorizontalAlignment, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_HorizontalAlignment, TEXT("DisplayName"), TEXT("Horizontal Alignment"));
				MetaData->SetValue(NewProp_HorizontalAlignment, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_HorizontalAlignment, TEXT("ToolTip"), TEXT("Horizontal text alignment"));
				MetaData->SetValue(NewProp_Font, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_Font, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_Font, TEXT("ToolTip"), TEXT("Text font"));
				MetaData->SetValue(NewProp_TextMaterial, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_TextMaterial, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_TextMaterial, TEXT("ToolTip"), TEXT("Text material"));
				MetaData->SetValue(NewProp_Text, TEXT("Category"), TEXT("Text"));
				MetaData->SetValue(NewProp_Text, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TextRenderComponent.h"));
				MetaData->SetValue(NewProp_Text, TEXT("MultiLine"), TEXT("TRUE"));
				MetaData->SetValue(NewProp_Text, TEXT("ToolTip"), TEXT("Text content, can be multi line using <br> as line separator"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTextRenderComponent(Z_Construct_UClass_UTextRenderComponent, TEXT("UTextRenderComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTextRenderComponent);
	UFunction* Z_Construct_UFunction_UVectorFieldComponent_SetIntensity()
	{
		struct VectorFieldComponent_eventSetIntensity_Parms
		{
			float NewIntensity;
		};
		UObject* Outer=Z_Construct_UClass_UVectorFieldComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetIntensity"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(VectorFieldComponent_eventSetIntensity_Parms));
			UProperty* NewProp_NewIntensity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewIntensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewIntensity, VectorFieldComponent_eventSetIntensity_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Effects|Components|VectorField"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/VectorFieldComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the intensity of the vector field.\n@param NewIntensity - The new intensity of the vector field."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVectorFieldComponent_NoRegister()
	{
		return UVectorFieldComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UVectorFieldComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UVectorFieldComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;

				OuterClass->LinkChild(Z_Construct_UFunction_UVectorFieldComponent_SetIntensity());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPreviewVectorField, UVectorFieldComponent, uint8);
				UProperty* NewProp_bPreviewVectorField = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bPreviewVectorField"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPreviewVectorField, UVectorFieldComponent), 0x0000000000002000, CPP_BOOL_PROPERTY_BITMASK(bPreviewVectorField, UVectorFieldComponent), sizeof(uint8), false);
				UProperty* NewProp_Tightness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Tightness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Tightness, UVectorFieldComponent), 0x0000000000000005);
				UProperty* NewProp_Intensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Intensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Intensity, UVectorFieldComponent), 0x0000000200000005);
				UProperty* NewProp_VectorField = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VectorField"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VectorField, UVectorFieldComponent), 0x0000000000000005, Z_Construct_UClass_UVectorField_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UVectorFieldComponent_SetIntensity()); // 271390712
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/VectorFieldComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/VectorFieldComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A Component referencing a vector field."));
				MetaData->SetValue(NewProp_bPreviewVectorField, TEXT("ModuleRelativePath"), TEXT("Classes/Components/VectorFieldComponent.h"));
				MetaData->SetValue(NewProp_bPreviewVectorField, TEXT("ToolTip"), TEXT("If true, the vector field is only used for preview visualizations."));
				MetaData->SetValue(NewProp_Tightness, TEXT("Category"), TEXT("VectorFieldComponent"));
				MetaData->SetValue(NewProp_Tightness, TEXT("ModuleRelativePath"), TEXT("Classes/Components/VectorFieldComponent.h"));
				MetaData->SetValue(NewProp_Tightness, TEXT("ToolTip"), TEXT("How tightly particles follow the vector field."));
				MetaData->SetValue(NewProp_Intensity, TEXT("Category"), TEXT("VectorFieldComponent"));
				MetaData->SetValue(NewProp_Intensity, TEXT("ModuleRelativePath"), TEXT("Classes/Components/VectorFieldComponent.h"));
				MetaData->SetValue(NewProp_Intensity, TEXT("ToolTip"), TEXT("The intensity at which the vector field is applied."));
				MetaData->SetValue(NewProp_VectorField, TEXT("Category"), TEXT("VectorFieldComponent"));
				MetaData->SetValue(NewProp_VectorField, TEXT("ModuleRelativePath"), TEXT("Classes/Components/VectorFieldComponent.h"));
				MetaData->SetValue(NewProp_VectorField, TEXT("ToolTip"), TEXT("The vector field asset."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVectorFieldComponent(Z_Construct_UClass_UVectorFieldComponent, TEXT("UVectorFieldComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVectorFieldComponent);
	UFunction* Z_Construct_UFunction_URadialForceComponent_AddObjectTypeToAffect()
	{
		struct RadialForceComponent_eventAddObjectTypeToAffect_Parms
		{
			TEnumAsByte<EObjectTypeQuery> ObjectType;
		};
		UObject* Outer=Z_Construct_UClass_URadialForceComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddObjectTypeToAffect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(RadialForceComponent_eventAddObjectTypeToAffect_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ObjectType, RadialForceComponent_eventAddObjectTypeToAffect_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|RadialForce"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an object type for this radial force to affect"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_URadialForceComponent_FireImpulse()
	{
		UObject* Outer=Z_Construct_UClass_URadialForceComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FireImpulse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|RadialForce"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Fire a single impulse"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_URadialForceComponent_RemoveObjectTypeToAffect()
	{
		struct RadialForceComponent_eventRemoveObjectTypeToAffect_Parms
		{
			TEnumAsByte<EObjectTypeQuery> ObjectType;
		};
		UObject* Outer=Z_Construct_UClass_URadialForceComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveObjectTypeToAffect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(RadialForceComponent_eventRemoveObjectTypeToAffect_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ObjectType, RadialForceComponent_eventRemoveObjectTypeToAffect_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Physics|Components|RadialForce"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Remove an object type that is affected by this radial force"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_URadialForceComponent_NoRegister()
	{
		return URadialForceComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_URadialForceComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = URadialForceComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;

				OuterClass->LinkChild(Z_Construct_UFunction_URadialForceComponent_AddObjectTypeToAffect());
				OuterClass->LinkChild(Z_Construct_UFunction_URadialForceComponent_FireImpulse());
				OuterClass->LinkChild(Z_Construct_UFunction_URadialForceComponent_RemoveObjectTypeToAffect());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ObjectTypesToAffect = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ObjectTypesToAffect"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypesToAffect, URadialForceComponent), 0x0000080000000001);
				UProperty* NewProp_ObjectTypesToAffect_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypesToAffect, TEXT("ObjectTypesToAffect"), RF_Public|RF_Transient|RF_Native) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
				UProperty* NewProp_DestructibleDamage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DestructibleDamage"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DestructibleDamage, URadialForceComponent), 0x0000000000000005);
				UProperty* NewProp_ForceStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ForceStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ForceStrength, URadialForceComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreOwningActor, URadialForceComponent, uint8);
				UProperty* NewProp_bIgnoreOwningActor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreOwningActor"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreOwningActor, URadialForceComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIgnoreOwningActor, URadialForceComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bImpulseVelChange, URadialForceComponent, uint8);
				UProperty* NewProp_bImpulseVelChange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bImpulseVelChange"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bImpulseVelChange, URadialForceComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bImpulseVelChange, URadialForceComponent), sizeof(uint8), false);
				UProperty* NewProp_ImpulseStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ImpulseStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ImpulseStrength, URadialForceComponent), 0x0000000000000005);
				UProperty* NewProp_Falloff = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Falloff"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Falloff, URadialForceComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_ERadialImpulseFalloff());
				UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, URadialForceComponent), 0x0000000200000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_URadialForceComponent_AddObjectTypeToAffect()); // 1846022218
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_URadialForceComponent_FireImpulse()); // 1492559876
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_URadialForceComponent_RemoveObjectTypeToAffect()); // 3793095763
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD Physics PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Used to emit a radial force or impulse that can affect physics objects and or destructible objects."));
				MetaData->SetValue(NewProp_ObjectTypesToAffect, TEXT("Category"), TEXT("RadialForceComponent"));
				MetaData->SetValue(NewProp_ObjectTypesToAffect, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_ObjectTypesToAffect, TEXT("ToolTip"), TEXT("The object types that are affected by this radial force"));
				MetaData->SetValue(NewProp_DestructibleDamage, TEXT("Category"), TEXT("Destructible"));
				MetaData->SetValue(NewProp_DestructibleDamage, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_DestructibleDamage, TEXT("ToolTip"), TEXT("If > 0.f, will cause damage to destructible meshes as well"));
				MetaData->SetValue(NewProp_ForceStrength, TEXT("Category"), TEXT("Force"));
				MetaData->SetValue(NewProp_ForceStrength, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_ForceStrength, TEXT("ToolTip"), TEXT("How strong the force should be"));
				MetaData->SetValue(NewProp_bIgnoreOwningActor, TEXT("Category"), TEXT("Impulse"));
				MetaData->SetValue(NewProp_bIgnoreOwningActor, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_bIgnoreOwningActor, TEXT("ToolTip"), TEXT("If true, do not apply force/impulse to any physics objects that are part of the Actor that owns this component."));
				MetaData->SetValue(NewProp_bImpulseVelChange, TEXT("Category"), TEXT("Impulse"));
				MetaData->SetValue(NewProp_bImpulseVelChange, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_bImpulseVelChange, TEXT("ToolTip"), TEXT("If true, the impulse will ignore mass of objects and will always result in a fixed velocity change"));
				MetaData->SetValue(NewProp_ImpulseStrength, TEXT("Category"), TEXT("Impulse"));
				MetaData->SetValue(NewProp_ImpulseStrength, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_ImpulseStrength, TEXT("ToolTip"), TEXT("How strong the impulse should be"));
				MetaData->SetValue(NewProp_Falloff, TEXT("Category"), TEXT("RadialForceComponent"));
				MetaData->SetValue(NewProp_Falloff, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_Falloff, TEXT("ToolTip"), TEXT("How the force or impulse should fall off as object are further away from the center"));
				MetaData->SetValue(NewProp_Radius, TEXT("Category"), TEXT("RadialForceComponent"));
				MetaData->SetValue(NewProp_Radius, TEXT("ModuleRelativePath"), TEXT("Classes/PhysicsEngine/RadialForceComponent.h"));
				MetaData->SetValue(NewProp_Radius, TEXT("ToolTip"), TEXT("The radius to apply the force or impulse in"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_URadialForceComponent(Z_Construct_UClass_URadialForceComponent, TEXT("URadialForceComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(URadialForceComponent);
	UClass* Z_Construct_UClass_UReflectionCaptureComponent_NoRegister()
	{
		return UReflectionCaptureComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UReflectionCaptureComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UReflectionCaptureComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_StateId = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StateId"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(StateId, UReflectionCaptureComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FGuid());
				UProperty* NewProp_Brightness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Brightness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Brightness, UReflectionCaptureComponent), 0x0000000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent Activation Components|Activation Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/ReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("-> will be exported to EngineDecalClasses.h"));
				MetaData->SetValue(NewProp_StateId, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_Brightness, TEXT("Category"), TEXT("ReflectionCapture"));
				MetaData->SetValue(NewProp_Brightness, TEXT("ModuleRelativePath"), TEXT("Classes/Components/ReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_Brightness, TEXT("ToolTip"), TEXT("A brightness control to scale the captured scene's reflection intensity."));
				MetaData->SetValue(NewProp_Brightness, TEXT("UIMax"), TEXT("4"));
				MetaData->SetValue(NewProp_Brightness, TEXT("UIMin"), TEXT(".5"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UReflectionCaptureComponent(Z_Construct_UClass_UReflectionCaptureComponent, TEXT("UReflectionCaptureComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UReflectionCaptureComponent);
	UClass* Z_Construct_UClass_UBoxReflectionCaptureComponent_NoRegister()
	{
		return UBoxReflectionCaptureComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBoxReflectionCaptureComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UReflectionCaptureComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UBoxReflectionCaptureComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PreviewCaptureBox = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewCaptureBox"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewCaptureBox, UBoxReflectionCaptureComponent), 0x0000000000080008, Z_Construct_UClass_UBoxComponent_NoRegister());
				UProperty* NewProp_PreviewInfluenceBox = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewInfluenceBox"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewInfluenceBox, UBoxReflectionCaptureComponent), 0x0000000000080008, Z_Construct_UClass_UBoxComponent_NoRegister());
				UProperty* NewProp_BoxTransitionDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoxTransitionDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BoxTransitionDistance, UBoxReflectionCaptureComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent Collision Object Physics SceneComponent Activation Components|Activation Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/BoxReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("-> will be exported to EngineDecalClasses.h"));
				MetaData->SetValue(NewProp_PreviewCaptureBox, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewCaptureBox, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_PreviewInfluenceBox, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewInfluenceBox, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_BoxTransitionDistance, TEXT("Category"), TEXT("ReflectionCapture"));
				MetaData->SetValue(NewProp_BoxTransitionDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Components/BoxReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_BoxTransitionDistance, TEXT("ToolTip"), TEXT("Adjust capture transition distance"));
				MetaData->SetValue(NewProp_BoxTransitionDistance, TEXT("UIMax"), TEXT("1000"));
				MetaData->SetValue(NewProp_BoxTransitionDistance, TEXT("UIMin"), TEXT("1"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBoxReflectionCaptureComponent(Z_Construct_UClass_UBoxReflectionCaptureComponent, TEXT("UBoxReflectionCaptureComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBoxReflectionCaptureComponent);
	UClass* Z_Construct_UClass_UPlaneReflectionCaptureComponent_NoRegister()
	{
		return UPlaneReflectionCaptureComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UPlaneReflectionCaptureComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UReflectionCaptureComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UPlaneReflectionCaptureComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PreviewCaptureBox = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewCaptureBox"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewCaptureBox, UPlaneReflectionCaptureComponent), 0x0000000000080008, Z_Construct_UClass_UBoxComponent_NoRegister());
				UProperty* NewProp_PreviewInfluenceRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewInfluenceRadius"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewInfluenceRadius, UPlaneReflectionCaptureComponent), 0x0000000000080008, Z_Construct_UClass_UDrawSphereComponent_NoRegister());
				UProperty* NewProp_InfluenceRadiusScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InfluenceRadiusScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InfluenceRadiusScale, UPlaneReflectionCaptureComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent Collision Object Physics SceneComponent Activation Components|Activation Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/PlaneReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlaneReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("-> will be exported to EngineDecalClasses.h"));
				MetaData->SetValue(NewProp_PreviewCaptureBox, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewCaptureBox, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlaneReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_PreviewInfluenceRadius, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewInfluenceRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlaneReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_InfluenceRadiusScale, TEXT("Category"), TEXT("ReflectionCapture"));
				MetaData->SetValue(NewProp_InfluenceRadiusScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/PlaneReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_InfluenceRadiusScale, TEXT("ToolTip"), TEXT("Radius of the area that can receive reflections from this capture."));
				MetaData->SetValue(NewProp_InfluenceRadiusScale, TEXT("UIMax"), TEXT("16384.0"));
				MetaData->SetValue(NewProp_InfluenceRadiusScale, TEXT("UIMin"), TEXT("8.0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UPlaneReflectionCaptureComponent(Z_Construct_UClass_UPlaneReflectionCaptureComponent, TEXT("UPlaneReflectionCaptureComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UPlaneReflectionCaptureComponent);
	UClass* Z_Construct_UClass_USphereReflectionCaptureComponent_NoRegister()
	{
		return USphereReflectionCaptureComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USphereReflectionCaptureComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UReflectionCaptureComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USphereReflectionCaptureComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PreviewInfluenceRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewInfluenceRadius"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewInfluenceRadius, USphereReflectionCaptureComponent), 0x0000000000080008, Z_Construct_UClass_UDrawSphereComponent_NoRegister());
				UProperty* NewProp_CaptureDistanceScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CaptureDistanceScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CaptureDistanceScale, USphereReflectionCaptureComponent), 0x0000000000000000);
				UProperty* NewProp_InfluenceRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InfluenceRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InfluenceRadius, USphereReflectionCaptureComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent Collision Object Physics SceneComponent Activation Components|Activation Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SphereReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereReflectionCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("-> will be exported to EngineDecalClasses.h"));
				MetaData->SetValue(NewProp_PreviewInfluenceRadius, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PreviewInfluenceRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_CaptureDistanceScale, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_CaptureDistanceScale, TEXT("ToolTip"), TEXT("Not needed anymore, not yet removed in case the artist setup values are needed in the future"));
				MetaData->SetValue(NewProp_InfluenceRadius, TEXT("Category"), TEXT("ReflectionCapture"));
				MetaData->SetValue(NewProp_InfluenceRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SphereReflectionCaptureComponent.h"));
				MetaData->SetValue(NewProp_InfluenceRadius, TEXT("ToolTip"), TEXT("Radius of the area that can receive reflections from this capture."));
				MetaData->SetValue(NewProp_InfluenceRadius, TEXT("UIMax"), TEXT("16384.0"));
				MetaData->SetValue(NewProp_InfluenceRadius, TEXT("UIMin"), TEXT("8.0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USphereReflectionCaptureComponent(Z_Construct_UClass_USphereReflectionCaptureComponent, TEXT("USphereReflectionCaptureComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USphereReflectionCaptureComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FEngineShowFlagsSetting()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FEngineShowFlagsSetting_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("EngineShowFlagsSetting"), sizeof(FEngineShowFlagsSetting), Get_Z_Construct_UScriptStruct_FEngineShowFlagsSetting_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EngineShowFlagsSetting"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FEngineShowFlagsSetting>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Enabled, FEngineShowFlagsSetting, bool);
			UProperty* NewProp_Enabled = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Enabled"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Enabled, FEngineShowFlagsSetting), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(Enabled, FEngineShowFlagsSetting), sizeof(bool), true);
			UProperty* NewProp_ShowFlagName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ShowFlagName"), RF_Public|RF_Transient|RF_Native) UStrProperty(CPP_PROPERTY_BASE(ShowFlagName, FEngineShowFlagsSetting), 0x0000000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
			MetaData->SetValue(NewProp_Enabled, TEXT("Category"), TEXT("SceneCapture"));
			MetaData->SetValue(NewProp_Enabled, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
			MetaData->SetValue(NewProp_ShowFlagName, TEXT("Category"), TEXT("SceneCapture"));
			MetaData->SetValue(NewProp_ShowFlagName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FEngineShowFlagsSetting_CRC() { return 3208696428U; }
	UFunction* Z_Construct_UFunction_USceneCaptureComponent_HideActorComponents()
	{
		struct SceneCaptureComponent_eventHideActorComponents_Parms
		{
			AActor* InActor;
		};
		UObject* Outer=Z_Construct_UClass_USceneCaptureComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HideActorComponents"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(SceneCaptureComponent_eventHideActorComponents_Parms));
			UProperty* NewProp_InActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(InActor, SceneCaptureComponent_eventHideActorComponents_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|SceneCapture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds all primitive components in the actor to our list of hidden components."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USceneCaptureComponent_HideComponent()
	{
		struct SceneCaptureComponent_eventHideComponent_Parms
		{
			UPrimitiveComponent* InComponent;
		};
		UObject* Outer=Z_Construct_UClass_USceneCaptureComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HideComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(SceneCaptureComponent_eventHideComponent_Parms));
			UProperty* NewProp_InComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(InComponent, SceneCaptureComponent_eventHideComponent_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|SceneCapture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds the component to our list of hidden components."));
			MetaData->SetValue(NewProp_InComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USceneCaptureComponent_NoRegister()
	{
		return USceneCaptureComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USceneCaptureComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USceneCaptureComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;

				OuterClass->LinkChild(Z_Construct_UFunction_USceneCaptureComponent_HideActorComponents());
				OuterClass->LinkChild(Z_Construct_UFunction_USceneCaptureComponent_HideComponent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ShowFlagSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShowFlagSettings"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ShowFlagSettings, USceneCaptureComponent), 0x0000000200000005);
				UProperty* NewProp_ShowFlagSettings_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ShowFlagSettings, TEXT("ShowFlagSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FEngineShowFlagsSetting());
				UProperty* NewProp_MaxViewDistanceOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxViewDistanceOverride"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxViewDistanceOverride, USceneCaptureComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCaptureEveryFrame, USceneCaptureComponent, bool);
				UProperty* NewProp_bCaptureEveryFrame = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCaptureEveryFrame"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCaptureEveryFrame, USceneCaptureComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bCaptureEveryFrame, USceneCaptureComponent), sizeof(bool), true);
				UProperty* NewProp_HiddenComponents = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HiddenComponents"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(HiddenComponents, USceneCaptureComponent), 0x0004008000000008);
				UProperty* NewProp_HiddenComponents_Inner = new(EC_InternalUseOnlyConstructor, NewProp_HiddenComponents, TEXT("HiddenComponents"), RF_Public|RF_Transient|RF_Native) UWeakObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000080008, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USceneCaptureComponent_HideActorComponents()); // 118752788
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USceneCaptureComponent_HideComponent()); // 1272119272
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("abstract Collision Object Physics SceneComponent Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SceneCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("-> will be exported to EngineDecalClasses.h"));
				MetaData->SetValue(NewProp_ShowFlagSettings, TEXT("Category"), TEXT("SceneComponent"));
				MetaData->SetValue(NewProp_ShowFlagSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
				MetaData->SetValue(NewProp_ShowFlagSettings, TEXT("ToolTip"), TEXT("ShowFlags for the SceneCapture's ViewFamily, to control rendering settings for this view. Hidden but accessible through details customization"));
				MetaData->SetValue(NewProp_MaxViewDistanceOverride, TEXT("Category"), TEXT("SceneCapture"));
				MetaData->SetValue(NewProp_MaxViewDistanceOverride, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
				MetaData->SetValue(NewProp_MaxViewDistanceOverride, TEXT("ToolTip"), TEXT("if > 0, sets a maximum render distance override.  Can be used to cull distant objects from a reflection if the reflecting plane is in an enclosed area like a hallway or room"));
				MetaData->SetValue(NewProp_MaxViewDistanceOverride, TEXT("UIMax"), TEXT("10000"));
				MetaData->SetValue(NewProp_MaxViewDistanceOverride, TEXT("UIMin"), TEXT("100"));
				MetaData->SetValue(NewProp_bCaptureEveryFrame, TEXT("Category"), TEXT("SceneCapture"));
				MetaData->SetValue(NewProp_bCaptureEveryFrame, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
				MetaData->SetValue(NewProp_bCaptureEveryFrame, TEXT("ToolTip"), TEXT("Whether to update the capture's contents every frame.  If disabled, the component will render once on load and then only when moved."));
				MetaData->SetValue(NewProp_HiddenComponents, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent.h"));
				MetaData->SetValue(NewProp_HiddenComponents, TEXT("ToolTip"), TEXT("The components won't rendered by current component."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USceneCaptureComponent(Z_Construct_UClass_USceneCaptureComponent, TEXT("USceneCaptureComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USceneCaptureComponent);
	UEnum* Z_Construct_UEnum_Engine_ESceneCaptureSource()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ESceneCaptureSource_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESceneCaptureSource"), 0, Get_Z_Construct_UEnum_Engine_ESceneCaptureSource_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESceneCaptureSource"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SCS_SceneColorHDR")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SCS_FinalColorLDR")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SCS_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
			MetaData->SetValue(ReturnEnum, TEXT("SCS_FinalColorLDR.DisplayName"), TEXT("Final Color (LDR with PostProcess)"));
			MetaData->SetValue(ReturnEnum, TEXT("SCS_SceneColorHDR.DisplayName"), TEXT("Scene Color (HDR)"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("-> will be exported to EngineDecalClasses.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ESceneCaptureSource_CRC() { return 515299493U; }
	UFunction* Z_Construct_UFunction_USceneCaptureComponent2D_AddOrUpdateBlendable()
	{
		struct SceneCaptureComponent2D_eventAddOrUpdateBlendable_Parms
		{
			TScriptInterface<IBlendableInterface> InBlendableObject;
			float InWeight;
		};
		UObject* Outer=Z_Construct_UClass_USceneCaptureComponent2D();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddOrUpdateBlendable"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(SceneCaptureComponent2D_eventAddOrUpdateBlendable_Parms));
			UProperty* NewProp_InWeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InWeight, SceneCaptureComponent2D_eventAddOrUpdateBlendable_Parms), 0x0000000000000080);
			UProperty* NewProp_InBlendableObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InBlendableObject"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(InBlendableObject, SceneCaptureComponent2D_eventAddOrUpdateBlendable_Parms), 0x0004000000000080, Z_Construct_UClass_UBlendableInterface_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_InWeight"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds an Blendable (implements IBlendableInterface) to the array of Blendables (if it doesn't exist) and update the weight"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USceneCaptureComponent2D_UpdateContent()
	{
		UObject* Outer=Z_Construct_UClass_USceneCaptureComponent2D();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UpdateContent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|SceneCapture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Render the scene to the texture"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USceneCaptureComponent2D_NoRegister()
	{
		return USceneCaptureComponent2D::StaticClass();
	}
	UClass* Z_Construct_UClass_USceneCaptureComponent2D()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneCaptureComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USceneCaptureComponent2D::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A81080;

				OuterClass->LinkChild(Z_Construct_UFunction_USceneCaptureComponent2D_AddOrUpdateBlendable());
				OuterClass->LinkChild(Z_Construct_UFunction_USceneCaptureComponent2D_UpdateContent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PostProcessBlendWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PostProcessBlendWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PostProcessBlendWeight, USceneCaptureComponent2D), 0x0000000200000005);
				UProperty* NewProp_PostProcessSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PostProcessSettings"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(PostProcessSettings, USceneCaptureComponent2D), 0x0000000200000005, Z_Construct_UScriptStruct_FPostProcessSettings());
				UProperty* NewProp_CaptureSource = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CaptureSource"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CaptureSource, USceneCaptureComponent2D), 0x0000000200000005, Z_Construct_UEnum_Engine_ESceneCaptureSource());
				UProperty* NewProp_TextureTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TextureTarget"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TextureTarget, USceneCaptureComponent2D), 0x0000000000000005, Z_Construct_UClass_UTextureRenderTarget2D_NoRegister());
				UProperty* NewProp_FOVAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FOVAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FOVAngle, USceneCaptureComponent2D), 0x0000000200000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USceneCaptureComponent2D_AddOrUpdateBlendable()); // 1477787672
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USceneCaptureComponent2D_UpdateContent()); // 3380566417
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent abstract Collision Object Physics SceneComponent Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Used to capture a 'snapshot' of the scene from a single plane and feed it to a render target."));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("ToolTip"), TEXT("Range (0.0, 1.0) where 0 indicates no effect, 1 indicates full effect."));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("UIMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_PostProcessBlendWeight, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_PostProcessSettings, TEXT("Category"), TEXT("PostProcessVolume"));
				MetaData->SetValue(NewProp_PostProcessSettings, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(NewProp_PostProcessSettings, TEXT("ShowOnlyInnerProperties"), TEXT(""));
				MetaData->SetValue(NewProp_CaptureSource, TEXT("Category"), TEXT("SceneCapture"));
				MetaData->SetValue(NewProp_CaptureSource, TEXT("DisplayName"), TEXT("Capture Source"));
				MetaData->SetValue(NewProp_CaptureSource, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(NewProp_TextureTarget, TEXT("Category"), TEXT("SceneCapture"));
				MetaData->SetValue(NewProp_TextureTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(NewProp_TextureTarget, TEXT("ToolTip"), TEXT("Temporary render target that can be used by the editor."));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("Category"), TEXT("SceneCapture"));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("ClampMax"), TEXT("360.0"));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("ClampMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("DisplayName"), TEXT("Field of View"));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponent2D.h"));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("ToolTip"), TEXT("Camera field of view (in degrees)."));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("UIMax"), TEXT("170"));
				MetaData->SetValue(NewProp_FOVAngle, TEXT("UIMin"), TEXT("5.0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USceneCaptureComponent2D(Z_Construct_UClass_USceneCaptureComponent2D, TEXT("USceneCaptureComponent2D"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USceneCaptureComponent2D);
	UFunction* Z_Construct_UFunction_USceneCaptureComponentCube_UpdateContent()
	{
		UObject* Outer=Z_Construct_UClass_USceneCaptureComponentCube();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UpdateContent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Rendering|SceneCapture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponentCube.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Render the scene to the texture"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USceneCaptureComponentCube_NoRegister()
	{
		return USceneCaptureComponentCube::StaticClass();
	}
	UClass* Z_Construct_UClass_USceneCaptureComponentCube()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneCaptureComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USceneCaptureComponentCube::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A81080;

				OuterClass->LinkChild(Z_Construct_UFunction_USceneCaptureComponentCube_UpdateContent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TextureTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TextureTarget"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TextureTarget, USceneCaptureComponentCube), 0x0000000000000005, Z_Construct_UClass_UTextureRenderTargetCube_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USceneCaptureComponentCube_UpdateContent()); // 605424034
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Rendering"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Object Physics SceneComponent abstract Collision Object Physics SceneComponent Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/SceneCaptureComponentCube.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponentCube.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Used to capture a 'snapshot' of the scene from a 6 planes and feed it to a render target."));
				MetaData->SetValue(NewProp_TextureTarget, TEXT("Category"), TEXT("SceneCapture"));
				MetaData->SetValue(NewProp_TextureTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Components/SceneCaptureComponentCube.h"));
				MetaData->SetValue(NewProp_TextureTarget, TEXT("ToolTip"), TEXT("Temporary render target that can be used by the editor."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USceneCaptureComponentCube(Z_Construct_UClass_USceneCaptureComponentCube, TEXT("USceneCaptureComponentCube"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USceneCaptureComponentCube);
	UClass* Z_Construct_UClass_USpringArmComponent_NoRegister()
	{
		return USpringArmComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_USpringArmComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = USpringArmComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CameraLagMaxDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraLagMaxDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CameraLagMaxDistance, USpringArmComponent), 0x0000000000000005);
				UProperty* NewProp_CameraLagMaxTimeStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraLagMaxTimeStep"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CameraLagMaxTimeStep, USpringArmComponent), 0x0000040000000005);
				UProperty* NewProp_CameraRotationLagSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraRotationLagSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CameraRotationLagSpeed, USpringArmComponent), 0x0000000000000005);
				UProperty* NewProp_CameraLagSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraLagSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CameraLagSpeed, USpringArmComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawDebugLagMarkers, USpringArmComponent, uint8);
				UProperty* NewProp_bDrawDebugLagMarkers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawDebugLagMarkers"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawDebugLagMarkers, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawDebugLagMarkers, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseCameraLagSubstepping, USpringArmComponent, uint8);
				UProperty* NewProp_bUseCameraLagSubstepping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseCameraLagSubstepping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseCameraLagSubstepping, USpringArmComponent), 0x0000040000000005, CPP_BOOL_PROPERTY_BITMASK(bUseCameraLagSubstepping, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableCameraRotationLag, USpringArmComponent, uint8);
				UProperty* NewProp_bEnableCameraRotationLag = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableCameraRotationLag"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableCameraRotationLag, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnableCameraRotationLag, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableCameraLag, USpringArmComponent, uint8);
				UProperty* NewProp_bEnableCameraLag = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableCameraLag"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableCameraLag, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnableCameraLag, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInheritRoll, USpringArmComponent, uint8);
				UProperty* NewProp_bInheritRoll = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInheritRoll"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInheritRoll, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bInheritRoll, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInheritYaw, USpringArmComponent, uint8);
				UProperty* NewProp_bInheritYaw = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInheritYaw"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInheritYaw, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bInheritYaw, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInheritPitch, USpringArmComponent, uint8);
				UProperty* NewProp_bInheritPitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInheritPitch"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInheritPitch, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bInheritPitch, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUsePawnControlRotation, USpringArmComponent, uint8);
				UProperty* NewProp_bUsePawnControlRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUsePawnControlRotation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUsePawnControlRotation, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bUsePawnControlRotation, USpringArmComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDoCollisionTest, USpringArmComponent, uint8);
				UProperty* NewProp_bDoCollisionTest = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDoCollisionTest"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDoCollisionTest, USpringArmComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bDoCollisionTest, USpringArmComponent), sizeof(uint8), false);
				UProperty* NewProp_ProbeChannel = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProbeChannel"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(ProbeChannel, USpringArmComponent), 0x0000000000000005, Z_Construct_UEnum_Engine_ECollisionChannel());
				UProperty* NewProp_ProbeSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProbeSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ProbeSize, USpringArmComponent), 0x0000000000000005);
				UProperty* NewProp_TargetOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TargetOffset, USpringArmComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_SocketOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SocketOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(SocketOffset, USpringArmComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TargetArmLength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetArmLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TargetArmLength, USpringArmComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Camera"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("This component tries to maintain its children at a fixed distance from the parent,\nbut will retract the children if there is a collision, and spring back when there is no collision.\n\nExample: Use as a 'camera boom' to keep the follow camera for a player from colliding into the world."));
				MetaData->SetValue(NewProp_CameraLagMaxDistance, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_CameraLagMaxDistance, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CameraLagMaxDistance, TEXT("editcondition"), TEXT("bEnableCameraLag"));
				MetaData->SetValue(NewProp_CameraLagMaxDistance, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_CameraLagMaxDistance, TEXT("ToolTip"), TEXT("Max distance the camera target may lag behind the current location. If set to zero, no max distance is enforced."));
				MetaData->SetValue(NewProp_CameraLagMaxDistance, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("ClampMax"), TEXT("0.5"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("ClampMin"), TEXT("0.005"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("editcondition"), TEXT("bUseCameraLagSubstepping"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("ToolTip"), TEXT("Max time step used when sub-stepping camera lag."));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("UIMax"), TEXT("0.5"));
				MetaData->SetValue(NewProp_CameraLagMaxTimeStep, TEXT("UIMin"), TEXT("0.005"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("ClampMax"), TEXT("1000.0"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("editcondition"), TEXT("bEnableCameraRotationLag"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("ToolTip"), TEXT("If bEnableCameraRotationLag is true, controls how quickly camera reaches target position. Low values are slower (more lag), high values are faster (less lag), while zero is instant (no lag)."));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("UIMax"), TEXT("1000.0"));
				MetaData->SetValue(NewProp_CameraRotationLagSpeed, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("ClampMax"), TEXT("1000.0"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("editcondition"), TEXT("bEnableCameraLag"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("ToolTip"), TEXT("If bEnableCameraLag is true, controls how quickly camera reaches target position. Low values are slower (more lag), high values are faster (less lag), while zero is instant (no lag)."));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("UIMax"), TEXT("1000.0"));
				MetaData->SetValue(NewProp_CameraLagSpeed, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_bDrawDebugLagMarkers, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_bDrawDebugLagMarkers, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bDrawDebugLagMarkers, TEXT("ToolTip"), TEXT("If true and camera location lag is enabled, draws markers at the camera target (in green) and the lagged position (in yellow).\nA line is drawn between the two locations, in green normally but in red if the distance to the lag target has been clamped (by CameraLagMaxDistance)."));
				MetaData->SetValue(NewProp_bUseCameraLagSubstepping, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_bUseCameraLagSubstepping, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bUseCameraLagSubstepping, TEXT("ToolTip"), TEXT("If bUseCameraLagSubstepping is true, sub-step camera damping so that it handles fluctuating frame rates well (though this comes at a cost).\n@see CameraLagMaxTimeStep"));
				MetaData->SetValue(NewProp_bEnableCameraRotationLag, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_bEnableCameraRotationLag, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bEnableCameraRotationLag, TEXT("ToolTip"), TEXT("If true, camera lags behind target rotation to smooth its movement.\n@see CameraRotationLagSpeed"));
				MetaData->SetValue(NewProp_bEnableCameraLag, TEXT("Category"), TEXT("Lag"));
				MetaData->SetValue(NewProp_bEnableCameraLag, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bEnableCameraLag, TEXT("ToolTip"), TEXT("If true, camera lags behind target position to smooth its movement.\n@see CameraLagSpeed"));
				MetaData->SetValue(NewProp_bInheritRoll, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bInheritRoll, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bInheritRoll, TEXT("ToolTip"), TEXT("Should we inherit roll from parent component. Does nothing if using Absolute Rotation."));
				MetaData->SetValue(NewProp_bInheritYaw, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bInheritYaw, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bInheritYaw, TEXT("ToolTip"), TEXT("Should we inherit yaw from parent component. Does nothing if using Absolute Rotation."));
				MetaData->SetValue(NewProp_bInheritPitch, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bInheritPitch, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bInheritPitch, TEXT("ToolTip"), TEXT("Should we inherit pitch from parent component. Does nothing if using Absolute Rotation."));
				MetaData->SetValue(NewProp_bUsePawnControlRotation, TEXT("Category"), TEXT("CameraSettings"));
				MetaData->SetValue(NewProp_bUsePawnControlRotation, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bUsePawnControlRotation, TEXT("ToolTip"), TEXT("If this component is placed on a pawn, should it use the view/control rotation of the pawn where possible?\n@see APawn::GetViewRotation()"));
				MetaData->SetValue(NewProp_bDoCollisionTest, TEXT("Category"), TEXT("CameraCollision"));
				MetaData->SetValue(NewProp_bDoCollisionTest, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_bDoCollisionTest, TEXT("ToolTip"), TEXT("If true, do a collision test using ProbeChannel and ProbeSize to prevent camera clipping into level."));
				MetaData->SetValue(NewProp_ProbeChannel, TEXT("Category"), TEXT("CameraCollision"));
				MetaData->SetValue(NewProp_ProbeChannel, TEXT("editcondition"), TEXT("bDoCollisionTest"));
				MetaData->SetValue(NewProp_ProbeChannel, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_ProbeChannel, TEXT("ToolTip"), TEXT("Collision channel of the query probe (defaults to ECC_Camera)"));
				MetaData->SetValue(NewProp_ProbeSize, TEXT("Category"), TEXT("CameraCollision"));
				MetaData->SetValue(NewProp_ProbeSize, TEXT("editcondition"), TEXT("bDoCollisionTest"));
				MetaData->SetValue(NewProp_ProbeSize, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_ProbeSize, TEXT("ToolTip"), TEXT("How big should the query probe sphere be (in unreal units)"));
				MetaData->SetValue(NewProp_TargetOffset, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_TargetOffset, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_TargetOffset, TEXT("ToolTip"), TEXT("Offset at start of spring, applied in world space. Use this if you want a world-space offset from the parent component instead of the usual relative-space offset."));
				MetaData->SetValue(NewProp_SocketOffset, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_SocketOffset, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_SocketOffset, TEXT("ToolTip"), TEXT("offset at end of spring arm; use this instead of the relative offset of the attached component to ensure the line trace works as desired"));
				MetaData->SetValue(NewProp_TargetArmLength, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_TargetArmLength, TEXT("ModuleRelativePath"), TEXT("Classes/GameFramework/SpringArmComponent.h"));
				MetaData->SetValue(NewProp_TargetArmLength, TEXT("ToolTip"), TEXT("Natural length of the spring arm when there are no collisions"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USpringArmComponent(Z_Construct_UClass_USpringArmComponent, TEXT("USpringArmComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USpringArmComponent);
	UClass* Z_Construct_UClass_UWindDirectionalSourceComponent_NoRegister()
	{
		return UWindDirectionalSourceComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UWindDirectionalSourceComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UWindDirectionalSourceComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A03080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MaxGustAmount = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxGustAmount"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxGustAmount, UWindDirectionalSourceComponent), 0x0000000200000005);
				UProperty* NewProp_MinGustAmount = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinGustAmount"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinGustAmount, UWindDirectionalSourceComponent), 0x0000000200000005);
				UProperty* NewProp_Speed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Speed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Speed, UWindDirectionalSourceComponent), 0x0000000200000005);
				UProperty* NewProp_Strength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Strength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Strength, UWindDirectionalSourceComponent), 0x0000000200000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/WindDirectionalSourceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/WindDirectionalSourceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Component that provides a directional wind source. Only affects SpeedTree assets."));
				MetaData->SetValue(NewProp_MaxGustAmount, TEXT("Category"), TEXT("WindDirectionalSourceComponent"));
				MetaData->SetValue(NewProp_MaxGustAmount, TEXT("ModuleRelativePath"), TEXT("Classes/Components/WindDirectionalSourceComponent.h"));
				MetaData->SetValue(NewProp_MinGustAmount, TEXT("Category"), TEXT("WindDirectionalSourceComponent"));
				MetaData->SetValue(NewProp_MinGustAmount, TEXT("ModuleRelativePath"), TEXT("Classes/Components/WindDirectionalSourceComponent.h"));
				MetaData->SetValue(NewProp_Speed, TEXT("Category"), TEXT("WindDirectionalSourceComponent"));
				MetaData->SetValue(NewProp_Speed, TEXT("ModuleRelativePath"), TEXT("Classes/Components/WindDirectionalSourceComponent.h"));
				MetaData->SetValue(NewProp_Strength, TEXT("Category"), TEXT("WindDirectionalSourceComponent"));
				MetaData->SetValue(NewProp_Strength, TEXT("ModuleRelativePath"), TEXT("Classes/Components/WindDirectionalSourceComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UWindDirectionalSourceComponent(Z_Construct_UClass_UWindDirectionalSourceComponent, TEXT("UWindDirectionalSourceComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UWindDirectionalSourceComponent);
	UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineLinearColor__DelegateSignature()
	{
		struct _Script_Engine_eventOnTimelineLinearColor_Parms
		{
			FLinearColor Output;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnTimelineLinearColor__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00120000, 65535, sizeof(_Script_Engine_eventOnTimelineLinearColor_Parms));
			UProperty* NewProp_Output = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Output"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Output, _Script_Engine_eventOnTimelineLinearColor_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FLinearColor());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Signature of function to handle linear color track"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineVector__DelegateSignature()
	{
		struct _Script_Engine_eventOnTimelineVector_Parms
		{
			FVector Output;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnTimelineVector__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00120000, 65535, sizeof(_Script_Engine_eventOnTimelineVector_Parms));
			UProperty* NewProp_Output = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Output"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Output, _Script_Engine_eventOnTimelineVector_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Signature of function to handle timeline vector track"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineFloat__DelegateSignature()
	{
		struct _Script_Engine_eventOnTimelineFloat_Parms
		{
			float Output;
		};
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnTimelineFloat__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00120000, 65535, sizeof(_Script_Engine_eventOnTimelineFloat_Parms));
			UProperty* NewProp_Output = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Output"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Output, _Script_Engine_eventOnTimelineFloat_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Signature of function to handle timeline float track"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_OnTimelineEvent__DelegateSignature()
	{
		UObject* Outer=Z_Construct_UPackage_Engine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnTimelineEvent__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00120000, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Signature of function to handle a timeline 'event'"));
#endif
		}
		return ReturnFunction;
	}
	UEnum* Z_Construct_UEnum_Engine_ETimelineDirection()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ETimelineDirection_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ETimelineDirection"), 0, Get_Z_Construct_UEnum_Engine_ETimelineDirection_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ETimelineDirection"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETimelineDirection::Forward")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETimelineDirection::Backward")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETimelineDirection::ETimelineDirection_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Does timeline play or reverse ?"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ETimelineDirection_CRC() { return 2420442805U; }
	UEnum* Z_Construct_UEnum_Engine_ETimelineLengthMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ETimelineLengthMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ETimelineLengthMode"), 0, Get_Z_Construct_UEnum_Engine_ETimelineLengthMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ETimelineLengthMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TL_TimelineLength")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TL_LastKeyFrame")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TL_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Whether or not the timeline should be finished after the specified length, or the last keyframe in the tracks"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ETimelineLengthMode_CRC() { return 1136675201U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTimeline()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimeline_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("Timeline"), sizeof(FTimeline), Get_Z_Construct_UScriptStruct_FTimeline_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Timeline"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimeline>, EStructFlags(0x00000005));
			UProperty* NewProp_DirectionProperty = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DirectionProperty"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DirectionProperty, FTimeline), 0x0000000080002000, UByteProperty::StaticClass());
			UProperty* NewProp_DirectionPropertyName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DirectionPropertyName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(DirectionPropertyName, FTimeline), 0x0000000080000000);
			UProperty* NewProp_PropertySetObject = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PropertySetObject"), RF_Public|RF_Transient|RF_Native) UWeakObjectProperty(CPP_PROPERTY_BASE(PropertySetObject, FTimeline), 0x0004000080000000, Z_Construct_UClass_UObject_NoRegister());
			UProperty* NewProp_TimelineFinishedFunc = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TimelineFinishedFunc"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(TimelineFinishedFunc, FTimeline), 0x0000000080080000, Z_Construct_UDelegateFunction_Engine_OnTimelineEvent__DelegateSignature());
			UProperty* NewProp_TimelinePostUpdateFunc = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TimelinePostUpdateFunc"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(TimelinePostUpdateFunc, FTimeline), 0x0000000080080000, Z_Construct_UDelegateFunction_Engine_OnTimelineEvent__DelegateSignature());
			UProperty* NewProp_InterpLinearColors = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpLinearColors"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InterpLinearColors, FTimeline), 0x0000008080000000);
			UProperty* NewProp_InterpLinearColors_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InterpLinearColors, TEXT("InterpLinearColors"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FTimelineLinearColorTrack());
			UProperty* NewProp_InterpFloats = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpFloats"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InterpFloats, FTimeline), 0x0000008080000000);
			UProperty* NewProp_InterpFloats_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InterpFloats, TEXT("InterpFloats"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FTimelineFloatTrack());
			UProperty* NewProp_InterpVectors = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpVectors"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InterpVectors, FTimeline), 0x0000008080000000);
			UProperty* NewProp_InterpVectors_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InterpVectors, TEXT("InterpVectors"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FTimelineVectorTrack());
			UProperty* NewProp_Events = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Events"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Events, FTimeline), 0x0000008080000000);
			UProperty* NewProp_Events_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Events, TEXT("Events"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FTimelineEventEntry());
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Position"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Position, FTimeline), 0x0000000000000000);
			UProperty* NewProp_PlayRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PlayRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PlayRate, FTimeline), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPlaying, FTimeline, uint8);
			UProperty* NewProp_bPlaying = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bPlaying"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPlaying, FTimeline), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bPlaying, FTimeline), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bReversePlayback, FTimeline, uint8);
			UProperty* NewProp_bReversePlayback = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bReversePlayback"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bReversePlayback, FTimeline), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bReversePlayback, FTimeline), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLooping, FTimeline, uint8);
			UProperty* NewProp_bLooping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLooping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLooping, FTimeline), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bLooping, FTimeline), sizeof(uint8), false);
			UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Length"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Length, FTimeline), 0x0000000080000000);
			UProperty* NewProp_LengthMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LengthMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LengthMode, FTimeline), 0x0000000080000000, Z_Construct_UEnum_Engine_ETimelineLengthMode());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_DirectionProperty, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_DirectionProperty, TEXT("ToolTip"), TEXT("Cached property pointer for setting timeline direction"));
			MetaData->SetValue(NewProp_DirectionPropertyName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_DirectionPropertyName, TEXT("ToolTip"), TEXT("Optional. If set, Timeline will also set ETimelineDirection property on PropertySetObject using the name."));
			MetaData->SetValue(NewProp_PropertySetObject, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_PropertySetObject, TEXT("ToolTip"), TEXT("Optional. If set, Timeline will also set float/vector properties on this object using the PropertyName set in the tracks."));
			MetaData->SetValue(NewProp_TimelineFinishedFunc, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_TimelineFinishedFunc, TEXT("ToolTip"), TEXT("Called whenever this timeline is finished. Is not called if 'stop' is used to terminate timeline early"));
			MetaData->SetValue(NewProp_TimelinePostUpdateFunc, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_TimelinePostUpdateFunc, TEXT("ToolTip"), TEXT("Called whenever this timeline is playing and updates - done after all delegates are executed and variables updated"));
			MetaData->SetValue(NewProp_InterpLinearColors, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_InterpLinearColors, TEXT("ToolTip"), TEXT("Array of linear color interpolations performed during the timeline"));
			MetaData->SetValue(NewProp_InterpFloats, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_InterpFloats, TEXT("ToolTip"), TEXT("Array of float interpolations performed during the timeline"));
			MetaData->SetValue(NewProp_InterpVectors, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_InterpVectors, TEXT("ToolTip"), TEXT("Array of vector interpolations performed during the timeline"));
			MetaData->SetValue(NewProp_Events, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_Events, TEXT("ToolTip"), TEXT("Array of events that are fired at various times during the timeline"));
			MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_Position, TEXT("ToolTip"), TEXT("Current position in the timeline"));
			MetaData->SetValue(NewProp_PlayRate, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_PlayRate, TEXT("ToolTip"), TEXT("How fast we should play through the timeline"));
			MetaData->SetValue(NewProp_bPlaying, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_bPlaying, TEXT("ToolTip"), TEXT("Are we currently playing (moving Position)"));
			MetaData->SetValue(NewProp_bReversePlayback, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_bReversePlayback, TEXT("ToolTip"), TEXT("If playback should move the current position backwards instead of forwards"));
			MetaData->SetValue(NewProp_bLooping, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_bLooping, TEXT("ToolTip"), TEXT("Whether timeline should loop when it reaches the end, or stop"));
			MetaData->SetValue(NewProp_Length, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_Length, TEXT("ToolTip"), TEXT("How long the timeline is, will stop or loop at the end"));
			MetaData->SetValue(NewProp_LengthMode, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_LengthMode, TEXT("ToolTip"), TEXT("Specified how the timeline determines its own length (e.g. specified length, last keyframe)"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimeline_CRC() { return 1570323045U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTimelineLinearColorTrack()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimelineLinearColorTrack_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TimelineLinearColorTrack"), sizeof(FTimelineLinearColorTrack), Get_Z_Construct_UScriptStruct_FTimelineLinearColorTrack_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TimelineLinearColorTrack"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimelineLinearColorTrack>, EStructFlags(0x00000005));
			UProperty* NewProp_LinearColorProperty = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearColorProperty"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LinearColorProperty, FTimelineLinearColorTrack), 0x0000000000002000, UStructProperty::StaticClass());
			UProperty* NewProp_LinearColorPropertyName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearColorPropertyName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(LinearColorPropertyName, FTimelineLinearColorTrack), 0x0000000000000000);
			UProperty* NewProp_InterpFunc = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpFunc"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(InterpFunc, FTimelineLinearColorTrack), 0x0000000000080000, Z_Construct_UDelegateFunction_Engine_OnTimelineLinearColor__DelegateSignature());
			UProperty* NewProp_LinearColorCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LinearColorCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LinearColorCurve, FTimelineLinearColorTrack), 0x0000000000000000, Z_Construct_UClass_UCurveLinearColor_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct that contains one entry for each linear color interpolation performed by the timeline"));
			MetaData->SetValue(NewProp_LinearColorProperty, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_LinearColorProperty, TEXT("ToolTip"), TEXT("Cached linear color struct property pointer"));
			MetaData->SetValue(NewProp_LinearColorPropertyName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_LinearColorPropertyName, TEXT("ToolTip"), TEXT("Name of property that we should update from this curve"));
			MetaData->SetValue(NewProp_InterpFunc, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_InterpFunc, TEXT("ToolTip"), TEXT("Function that the output from ValueCurve will be passed to"));
			MetaData->SetValue(NewProp_LinearColorCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_LinearColorCurve, TEXT("ToolTip"), TEXT("Float curve to be evaluated"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimelineLinearColorTrack_CRC() { return 605388479U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTimelineFloatTrack()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimelineFloatTrack_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TimelineFloatTrack"), sizeof(FTimelineFloatTrack), Get_Z_Construct_UScriptStruct_FTimelineFloatTrack_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TimelineFloatTrack"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimelineFloatTrack>, EStructFlags(0x00000005));
			UProperty* NewProp_FloatProperty = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatProperty"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FloatProperty, FTimelineFloatTrack), 0x0000000000002000, UFloatProperty::StaticClass());
			UProperty* NewProp_FloatPropertyName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatPropertyName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(FloatPropertyName, FTimelineFloatTrack), 0x0000000000000000);
			UProperty* NewProp_InterpFunc = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpFunc"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(InterpFunc, FTimelineFloatTrack), 0x0000000000080000, Z_Construct_UDelegateFunction_Engine_OnTimelineFloat__DelegateSignature());
			UProperty* NewProp_FloatCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FloatCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FloatCurve, FTimelineFloatTrack), 0x0000000000000000, Z_Construct_UClass_UCurveFloat_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct that contains one entry for each vector interpolation performed by the timeline"));
			MetaData->SetValue(NewProp_FloatProperty, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_FloatProperty, TEXT("ToolTip"), TEXT("Cached float property pointer"));
			MetaData->SetValue(NewProp_FloatPropertyName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_FloatPropertyName, TEXT("ToolTip"), TEXT("Name of property that we should update from this curve"));
			MetaData->SetValue(NewProp_InterpFunc, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_InterpFunc, TEXT("ToolTip"), TEXT("Function that the output from ValueCurve will be passed to"));
			MetaData->SetValue(NewProp_FloatCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_FloatCurve, TEXT("ToolTip"), TEXT("Float curve to be evaluated"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimelineFloatTrack_CRC() { return 3327917906U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTimelineVectorTrack()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimelineVectorTrack_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TimelineVectorTrack"), sizeof(FTimelineVectorTrack), Get_Z_Construct_UScriptStruct_FTimelineVectorTrack_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TimelineVectorTrack"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimelineVectorTrack>, EStructFlags(0x00000005));
			UProperty* NewProp_VectorProperty = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VectorProperty"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VectorProperty, FTimelineVectorTrack), 0x0000000000002000, UStructProperty::StaticClass());
			UProperty* NewProp_VectorPropertyName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VectorPropertyName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(VectorPropertyName, FTimelineVectorTrack), 0x0000000000000000);
			UProperty* NewProp_InterpFunc = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpFunc"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(InterpFunc, FTimelineVectorTrack), 0x0000000000080000, Z_Construct_UDelegateFunction_Engine_OnTimelineVector__DelegateSignature());
			UProperty* NewProp_VectorCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("VectorCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(VectorCurve, FTimelineVectorTrack), 0x0000000000000000, Z_Construct_UClass_UCurveVector_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct that contains one entry for each vector interpolation performed by the timeline"));
			MetaData->SetValue(NewProp_VectorProperty, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_VectorProperty, TEXT("ToolTip"), TEXT("Cached vector struct property pointer"));
			MetaData->SetValue(NewProp_VectorPropertyName, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_VectorPropertyName, TEXT("ToolTip"), TEXT("Name of property that we should update from this curve"));
			MetaData->SetValue(NewProp_InterpFunc, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_InterpFunc, TEXT("ToolTip"), TEXT("Function that the output from ValueCurve will be passed to"));
			MetaData->SetValue(NewProp_VectorCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_VectorCurve, TEXT("ToolTip"), TEXT("Vector curve to be evaluated"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimelineVectorTrack_CRC() { return 1439941252U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTimelineEventEntry()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimelineEventEntry_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("TimelineEventEntry"), sizeof(FTimelineEventEntry), Get_Z_Construct_UScriptStruct_FTimelineEventEntry_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TimelineEventEntry"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimelineEventEntry>, EStructFlags(0x00000005));
			UProperty* NewProp_EventFunc = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EventFunc"), RF_Public|RF_Transient|RF_Native) UDelegateProperty(CPP_PROPERTY_BASE(EventFunc, FTimelineEventEntry), 0x0000000000080000, Z_Construct_UDelegateFunction_Engine_OnTimelineEvent__DelegateSignature());
			UProperty* NewProp_Time = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Time"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Time, FTimelineEventEntry), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct that contains one entry for an 'event' during the timeline"));
			MetaData->SetValue(NewProp_EventFunc, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_EventFunc, TEXT("ToolTip"), TEXT("Function to execute when Time is reached"));
			MetaData->SetValue(NewProp_Time, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(NewProp_Time, TEXT("ToolTip"), TEXT("Time at which event should fire"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimelineEventEntry_CRC() { return 726814465U; }
	UFunction* Z_Construct_UFunction_UTimelineComponent_GetPlaybackPosition()
	{
		struct TimelineComponent_eventGetPlaybackPosition_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlaybackPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(TimelineComponent_eventGetPlaybackPosition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimelineComponent_eventGetPlaybackPosition_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current playback position of the Timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_GetPlayRate()
	{
		struct TimelineComponent_eventGetPlayRate_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlayRate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(TimelineComponent_eventGetPlayRate_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimelineComponent_eventGetPlayRate_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current play rate for this timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_GetTimelineLength()
	{
		struct TimelineComponent_eventGetTimelineLength_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTimelineLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(TimelineComponent_eventGetTimelineLength_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimelineComponent_eventGetTimelineLength_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get length of the timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_IsLooping()
	{
		struct TimelineComponent_eventIsLooping_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsLooping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(TimelineComponent_eventIsLooping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, TimelineComponent_eventIsLooping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, TimelineComponent_eventIsLooping_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, TimelineComponent_eventIsLooping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get whether we are looping or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_IsPlaying()
	{
		struct TimelineComponent_eventIsPlaying_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsPlaying"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(TimelineComponent_eventIsPlaying_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, TimelineComponent_eventIsPlaying_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, TimelineComponent_eventIsPlaying_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, TimelineComponent_eventIsPlaying_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get whether this timeline is playing or not."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_IsReversing()
	{
		struct TimelineComponent_eventIsReversing_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsReversing"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020403, 65535, sizeof(TimelineComponent_eventIsReversing_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, TimelineComponent_eventIsReversing_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, TimelineComponent_eventIsReversing_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, TimelineComponent_eventIsReversing_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get whether we are reversing or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_OnRep_Timeline()
	{
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_Timeline"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_Play()
	{
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Play"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Start playback of timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_PlayFromStart()
	{
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayFromStart"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Start playback of timeline from the start"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_Reverse()
	{
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Reverse"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Start playback of timeline in reverse"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_ReverseFromEnd()
	{
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReverseFromEnd"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Start playback of timeline in reverse from the end"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_SetLooping()
	{
		struct TimelineComponent_eventSetLooping_Parms
		{
			bool bNewLooping;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLooping"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(TimelineComponent_eventSetLooping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNewLooping, TimelineComponent_eventSetLooping_Parms, bool);
			UProperty* NewProp_bNewLooping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bNewLooping"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNewLooping, TimelineComponent_eventSetLooping_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bNewLooping, TimelineComponent_eventSetLooping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("true means we whould loop, false means we should not."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_SetNewTime()
	{
		struct TimelineComponent_eventSetNewTime_Parms
		{
			float NewTime;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNewTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(TimelineComponent_eventSetNewTime_Parms));
			UProperty* NewProp_NewTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewTime, TimelineComponent_eventSetNewTime_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the new playback position time to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_SetPlaybackPosition()
	{
		struct TimelineComponent_eventSetPlaybackPosition_Parms
		{
			float NewPosition;
			bool bFireEvents;
			bool bFireUpdate;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlaybackPosition"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(TimelineComponent_eventSetPlaybackPosition_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFireUpdate, TimelineComponent_eventSetPlaybackPosition_Parms, bool);
			UProperty* NewProp_bFireUpdate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFireUpdate"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFireUpdate, TimelineComponent_eventSetPlaybackPosition_Parms), 0x0000040000000080, CPP_BOOL_PROPERTY_BITMASK(bFireUpdate, TimelineComponent_eventSetPlaybackPosition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFireEvents, TimelineComponent_eventSetPlaybackPosition_Parms, bool);
			UProperty* NewProp_bFireEvents = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFireEvents"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFireEvents, TimelineComponent_eventSetPlaybackPosition_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFireEvents, TimelineComponent_eventSetPlaybackPosition_Parms), sizeof(bool), true);
			UProperty* NewProp_NewPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewPosition"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewPosition, TimelineComponent_eventSetPlaybackPosition_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AdvancedDisplay"), TEXT("bFireUpdate"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bFireUpdate"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Jump to a position in the timeline.\n@param bFireEvents If true, event functions that are between current position and new playback position will fire.\n@param bFireUpdate If true, the update output exec will fire after setting the new playback position."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_SetPlayRate()
	{
		struct TimelineComponent_eventSetPlayRate_Parms
		{
			float NewRate;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetPlayRate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(TimelineComponent_eventSetPlayRate_Parms));
			UProperty* NewProp_NewRate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewRate, TimelineComponent_eventSetPlayRate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the new play rate for this timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_SetTimelineLength()
	{
		struct TimelineComponent_eventSetTimelineLength_Parms
		{
			float NewLength;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTimelineLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(TimelineComponent_eventSetTimelineLength_Parms));
			UProperty* NewProp_NewLength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(NewLength, TimelineComponent_eventSetTimelineLength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set length of the timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_SetTimelineLengthMode()
	{
		struct TimelineComponent_eventSetTimelineLengthMode_Parms
		{
			TEnumAsByte<ETimelineLengthMode> NewLengthMode;
		};
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTimelineLengthMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535, sizeof(TimelineComponent_eventSetTimelineLengthMode_Parms));
			UProperty* NewProp_NewLengthMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLengthMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(NewLengthMode, TimelineComponent_eventSetTimelineLengthMode_Parms), 0x0000000000000080, Z_Construct_UEnum_Engine_ETimelineLengthMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the length mode of the timeline"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTimelineComponent_Stop()
	{
		UObject* Outer=Z_Construct_UClass_UTimelineComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Stop"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020403, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Components|Timeline"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stop playback of timeline"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UTimelineComponent_NoRegister()
	{
		return UTimelineComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UTimelineComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Engine();
			OuterClass = UTimelineComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;

				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_GetPlaybackPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_GetPlayRate());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_GetTimelineLength());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_IsLooping());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_IsPlaying());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_IsReversing());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_OnRep_Timeline());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_Play());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_PlayFromStart());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_Reverse());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_ReverseFromEnd());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_SetLooping());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_SetNewTime());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_SetPlaybackPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_SetPlayRate());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_SetTimelineLength());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_SetTimelineLengthMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UTimelineComponent_Stop());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TheTimeline = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TheTimeline"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TheTimeline, UTimelineComponent), 0x0000008100000020, Z_Construct_UScriptStruct_FTimeline());
				NewProp_TheTimeline->RepNotifyFunc = FName(TEXT("OnRep_Timeline"));
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_GetPlaybackPosition()); // 1960328253
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_GetPlayRate()); // 2058552654
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_GetTimelineLength()); // 1957052957
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_IsLooping()); // 2874737805
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_IsPlaying()); // 1920785792
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_IsReversing()); // 3148667606
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_OnRep_Timeline()); // 134676696
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_Play()); // 850750438
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_PlayFromStart()); // 3658455582
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_Reverse()); // 4097298908
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_ReverseFromEnd()); // 937528620
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_SetLooping()); // 1254113963
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_SetNewTime()); // 2957561466
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_SetPlaybackPosition()); // 1048202149
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_SetPlayRate()); // 2070043491
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_SetTimelineLength()); // 1086254721
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_SetTimelineLengthMode()); // 826513182
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTimelineComponent_Stop()); // 3878019280
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Components/TimelineComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("TimelineComponent holds a series of events, floats, vectors or colors with associated keyframes.\nEvents can be triggered at keyframes along the timeline.\nFloats, vectors, and colors are interpolated between keyframes along the timeline."));
				MetaData->SetValue(NewProp_TheTimeline, TEXT("ModuleRelativePath"), TEXT("Classes/Components/TimelineComponent.h"));
				MetaData->SetValue(NewProp_TheTimeline, TEXT("ToolTip"), TEXT("The actual timeline structure"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTimelineComponent(Z_Construct_UClass_UTimelineComponent, TEXT("UTimelineComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTimelineComponent);
	UClass* Z_Construct_UClass_UAISystemBase_NoRegister()
	{
		return UAISystemBase::StaticClass();
	}
	UClass* Z_Construct_UClass_UAISystemBase()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Engine();
			OuterClass = UAISystemBase::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100087;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_AISystemModuleName = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AISystemModuleName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(AISystemModuleName, UAISystemBase), 0x0000000002044000);
				UProperty* NewProp_AISystemClassName = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AISystemClassName"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AISystemClassName, UAISystemBase), 0x0000000002044000, Z_Construct_UScriptStruct_FStringClassReference());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AI/AISystemBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AI/AISystemBase.h"));
				MetaData->SetValue(NewProp_AISystemModuleName, TEXT("DisplayName"), TEXT("AISystem Module"));
				MetaData->SetValue(NewProp_AISystemModuleName, TEXT("MetaClass"), TEXT("AISystem"));
				MetaData->SetValue(NewProp_AISystemModuleName, TEXT("ModuleRelativePath"), TEXT("Classes/AI/AISystemBase.h"));
				MetaData->SetValue(NewProp_AISystemClassName, TEXT("DisplayName"), TEXT("AISystem Class"));
				MetaData->SetValue(NewProp_AISystemClassName, TEXT("MetaClass"), TEXT("AISystem"));
				MetaData->SetValue(NewProp_AISystemClassName, TEXT("ModuleRelativePath"), TEXT("Classes/AI/AISystemBase.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAISystemBase(Z_Construct_UClass_UAISystemBase, TEXT("UAISystemBase"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAISystemBase);
	UEnum* Z_Construct_UEnum_Engine_ETypeAdvanceAnim()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ETypeAdvanceAnim_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ETypeAdvanceAnim"), 0, Get_Z_Construct_UEnum_Engine_ETypeAdvanceAnim_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ETypeAdvanceAnim"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETAA_Default")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETAA_Finished")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETAA_Looped")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETAA_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ETypeAdvanceAnim_CRC() { return 4228257346U; }
	UFunction* Z_Construct_UFunction_UAnimSequenceBase_GetPlayLength()
	{
		struct AnimSequenceBase_eventGetPlayLength_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAnimSequenceBase();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPlayLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AnimSequenceBase_eventGetPlayLength_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, AnimSequenceBase_eventGetPlayLength_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the total play length of the montage, if played back with a speed of 1.0."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAnimSequenceBase_NoRegister()
	{
		return UAnimSequenceBase::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimSequenceBase()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimationAsset();
			Z_Construct_UPackage_Engine();
			OuterClass = UAnimSequenceBase::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;

				OuterClass->LinkChild(Z_Construct_UFunction_UAnimSequenceBase_GetPlayLength());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_AnimNotifyTracks = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimNotifyTracks"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(AnimNotifyTracks, UAnimSequenceBase), 0x0000000800000000);
				UProperty* NewProp_AnimNotifyTracks_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AnimNotifyTracks, TEXT("AnimNotifyTracks"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000800000000, Z_Construct_UScriptStruct_FAnimNotifyTrack());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_RawCurveData = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RawCurveData"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(RawCurveData, UAnimSequenceBase), 0x0000000000000000, Z_Construct_UScriptStruct_FRawCurveTracks());
				UProperty* NewProp_RateScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RateScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RateScale, UAnimSequenceBase), 0x0000000000000001);
				UProperty* NewProp_SequenceLength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SequenceLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SequenceLength, UAnimSequenceBase), 0x0000010000020001);
				UProperty* NewProp_Notifies = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Notifies"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Notifies, UAnimSequenceBase), 0x0000008000000000);
				UProperty* NewProp_Notifies_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Notifies, TEXT("Notifies"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FAnimNotifyEvent());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UAnimSequenceBase_GetPlayLength()); // 2172679743
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Animation/AnimSequenceBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
				MetaData->SetValue(NewProp_AnimNotifyTracks, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
				MetaData->SetValue(NewProp_AnimNotifyTracks, TEXT("ToolTip"), TEXT("if you change Notifies array, this will need to be rebuilt"));
				MetaData->SetValue(NewProp_RawCurveData, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
				MetaData->SetValue(NewProp_RawCurveData, TEXT("ToolTip"), TEXT("Raw uncompressed float curve data"));
				MetaData->SetValue(NewProp_RateScale, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_RateScale, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
				MetaData->SetValue(NewProp_RateScale, TEXT("ToolTip"), TEXT("Number for tweaking playback rate of this animation globally."));
				MetaData->SetValue(NewProp_SequenceLength, TEXT("Category"), TEXT("Length"));
				MetaData->SetValue(NewProp_SequenceLength, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
				MetaData->SetValue(NewProp_SequenceLength, TEXT("ToolTip"), TEXT("Length (in seconds) of this AnimSequence if played back with a speed of 1.0."));
				MetaData->SetValue(NewProp_Notifies, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimSequenceBase.h"));
				MetaData->SetValue(NewProp_Notifies, TEXT("ToolTip"), TEXT("Animation notifies, sorted by time (earliest notification first)."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimSequenceBase(Z_Construct_UClass_UAnimSequenceBase, TEXT("UAnimSequenceBase"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimSequenceBase);
	UScriptStruct* Z_Construct_UScriptStruct_FAnimTrack()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimTrack_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimTrack"), sizeof(FAnimTrack), Get_Z_Construct_UScriptStruct_FAnimTrack_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimTrack"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimTrack>, EStructFlags(0x00000001));
			UProperty* NewProp_AnimSegments = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimSegments"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(AnimSegments, FAnimTrack), 0x0000000000000045);
			UProperty* NewProp_AnimSegments_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AnimSegments, TEXT("AnimSegments"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAnimSegment());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("This is list of anim segments for this track\nFor now this is only one TArray, but in the future\nwe should define more transition/blending behaviors"));
			MetaData->SetValue(NewProp_AnimSegments, TEXT("Category"), TEXT("AnimTrack"));
			MetaData->SetValue(NewProp_AnimSegments, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimTrack_CRC() { return 1014866294U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimSegment()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimSegment_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimSegment"), sizeof(FAnimSegment), Get_Z_Construct_UScriptStruct_FAnimSegment_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimSegment"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimSegment>, EStructFlags(0x00000001));
			UProperty* NewProp_LoopingCount = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopingCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(LoopingCount, FAnimSegment), 0x0000000000000005);
			UProperty* NewProp_AnimPlayRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimPlayRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AnimPlayRate, FAnimSegment), 0x0000000000000005);
			UProperty* NewProp_AnimEndTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimEndTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AnimEndTime, FAnimSegment), 0x0000000000000005);
			UProperty* NewProp_AnimStartTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimStartTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AnimStartTime, FAnimSegment), 0x0000000000000005);
			UProperty* NewProp_StartPos = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartPos"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartPos, FAnimSegment), 0x0000000000020005);
			UProperty* NewProp_AnimReference = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimReference"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimReference, FAnimSegment), 0x0000000000000005, Z_Construct_UClass_UAnimSequenceBase_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("this is anim segment that defines what animation and how *"));
			MetaData->SetValue(NewProp_LoopingCount, TEXT("Category"), TEXT("AnimSegment"));
			MetaData->SetValue(NewProp_LoopingCount, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_AnimPlayRate, TEXT("Category"), TEXT("AnimSegment"));
			MetaData->SetValue(NewProp_AnimPlayRate, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_AnimPlayRate, TEXT("ToolTip"), TEXT("Playback speed of this animation. If you'd like to reverse, set -1"));
			MetaData->SetValue(NewProp_AnimEndTime, TEXT("Category"), TEXT("AnimSegment"));
			MetaData->SetValue(NewProp_AnimEndTime, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_AnimEndTime, TEXT("ToolTip"), TEXT("Time to end playing the AnimSequence at."));
			MetaData->SetValue(NewProp_AnimStartTime, TEXT("Category"), TEXT("AnimSegment"));
			MetaData->SetValue(NewProp_AnimStartTime, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_AnimStartTime, TEXT("ToolTip"), TEXT("Time to start playing AnimSequence at."));
			MetaData->SetValue(NewProp_StartPos, TEXT("Category"), TEXT("AnimSegment"));
			MetaData->SetValue(NewProp_StartPos, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_StartPos, TEXT("ToolTip"), TEXT("Start Pos within this AnimCompositeBase"));
			MetaData->SetValue(NewProp_AnimReference, TEXT("Category"), TEXT("AnimSegment"));
			MetaData->SetValue(NewProp_AnimReference, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_AnimReference, TEXT("ToolTip"), TEXT("Anim Reference to play - only allow AnimSequence or AnimComposite *"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimSegment_CRC() { return 61905161U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRootMotionExtractionStep()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FRootMotionExtractionStep_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("RootMotionExtractionStep"), sizeof(FRootMotionExtractionStep), Get_Z_Construct_UScriptStruct_FRootMotionExtractionStep_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RootMotionExtractionStep"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRootMotionExtractionStep>, EStructFlags(0x00000001));
			UProperty* NewProp_EndPosition = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndPosition"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(EndPosition, FRootMotionExtractionStep), 0x0000000000000000);
			UProperty* NewProp_StartPosition = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartPosition"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(StartPosition, FRootMotionExtractionStep), 0x0000000000000000);
			UProperty* NewProp_AnimSequence = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimSequence"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(AnimSequence, FRootMotionExtractionStep), 0x0000000000000000, Z_Construct_UClass_UAnimSequence_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct defining a RootMotionExtractionStep.\nWhen extracting RootMotion we can encounter looping animations (wrap around), or different animations.\nWe break those up into different steps, to help with RootMotion extraction,\nas we can only extract a contiguous range per AnimSequence."));
			MetaData->SetValue(NewProp_EndPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_EndPosition, TEXT("ToolTip"), TEXT("End position to extract root motion to."));
			MetaData->SetValue(NewProp_StartPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_StartPosition, TEXT("ToolTip"), TEXT("Start position to extract root motion from."));
			MetaData->SetValue(NewProp_AnimSequence, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
			MetaData->SetValue(NewProp_AnimSequence, TEXT("ToolTip"), TEXT("AnimSequence ref"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRootMotionExtractionStep_CRC() { return 3689929413U; }
	UClass* Z_Construct_UClass_UAnimCompositeBase_NoRegister()
	{
		return UAnimCompositeBase::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimCompositeBase()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimSequenceBase();
			Z_Construct_UPackage_Engine();
			OuterClass = UAnimCompositeBase::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Animation/AnimCompositeBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimCompositeBase.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimCompositeBase(Z_Construct_UClass_UAnimCompositeBase, TEXT("UAnimCompositeBase"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimCompositeBase);
	UClass* Z_Construct_UClass_UAnimComposite_NoRegister()
	{
		return UAnimComposite::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimComposite()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimCompositeBase();
			Z_Construct_UPackage_Engine();
			OuterClass = UAnimComposite::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_PreviewBasePose = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviewBasePose"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PreviewBasePose, UAnimComposite), 0x0000000800000001, Z_Construct_UClass_UAnimSequence_NoRegister());
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_AnimationTrack = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimationTrack"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(AnimationTrack, UAnimComposite), 0x0000000000000000, Z_Construct_UScriptStruct_FAnimTrack());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("UObject"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Animation/AnimComposite.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimComposite.h"));
				MetaData->SetValue(NewProp_PreviewBasePose, TEXT("Category"), TEXT("AdditiveSettings"));
				MetaData->SetValue(NewProp_PreviewBasePose, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimComposite.h"));
				MetaData->SetValue(NewProp_PreviewBasePose, TEXT("ToolTip"), TEXT("Preview Base pose for additive BlendSpace *"));
				MetaData->SetValue(NewProp_AnimationTrack, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimComposite.h"));
				MetaData->SetValue(NewProp_AnimationTrack, TEXT("ToolTip"), TEXT("Serializable data that stores section/anim pairing *"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimComposite(Z_Construct_UClass_UAnimComposite, TEXT("UAnimComposite"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimComposite);
	UEnum* Z_Construct_UEnum_Engine_EAlphaBlendOption()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_EAlphaBlendOption_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EAlphaBlendOption"), 0, Get_Z_Construct_UEnum_Engine_EAlphaBlendOption_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAlphaBlendOption"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::Linear")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::Cubic")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::HermiteCubic")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::Sinusoidal")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::QuadraticInOut")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::CubicInOut")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::QuarticInOut")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::QuinticInOut")), 7));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::CircularIn")), 8));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::CircularOut")), 9));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::CircularInOut")), 10));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::ExpIn")), 11));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::ExpOut")), 12));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::ExpInOut")), 13));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::Custom")), 14));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAlphaBlendOption::EAlphaBlendOption_MAX")), 15));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("CircularIn.ToolTip"), TEXT("Circular-in interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("CircularInOut.ToolTip"), TEXT("Circular in-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("CircularOut.ToolTip"), TEXT("Circular-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("Cubic.ToolTip"), TEXT("Cubic-in interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("CubicInOut.ToolTip"), TEXT("Cubic in-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("Custom.ToolTip"), TEXT("Custom interpolation, will use custom curve inside an FAlphaBlend or linear if none has been set"));
			MetaData->SetValue(ReturnEnum, TEXT("ExpIn.ToolTip"), TEXT("Exponential-in interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("ExpInOut.ToolTip"), TEXT("Exponential in-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("ExpOut.ToolTip"), TEXT("Exponential-Out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("HermiteCubic.ToolTip"), TEXT("Hermite-Cubic"));
			MetaData->SetValue(ReturnEnum, TEXT("Linear.ToolTip"), TEXT("Linear interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(ReturnEnum, TEXT("QuadraticInOut.ToolTip"), TEXT("Quadratic in-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("QuarticInOut.ToolTip"), TEXT("Quartic in-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("QuinticInOut.ToolTip"), TEXT("Quintic in-out interpolation"));
			MetaData->SetValue(ReturnEnum, TEXT("Sinusoidal.ToolTip"), TEXT("Sinusoidal interpolation"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_EAlphaBlendOption_CRC() { return 1735049333U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAlphaBlend()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAlphaBlend_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AlphaBlend"), sizeof(FAlphaBlend), Get_Z_Construct_UScriptStruct_FAlphaBlend_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AlphaBlend"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAlphaBlend>, EStructFlags(0x00000001));
			UProperty* NewProp_BlendedValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BlendedValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BlendedValue, FAlphaBlend), 0x0000080000000000);
			UProperty* NewProp_BlendTimeRemaining = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BlendTimeRemaining"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BlendTimeRemaining, FAlphaBlend), 0x0000080000000000);
			UProperty* NewProp_AlphaTarget = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AlphaTarget"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AlphaTarget, FAlphaBlend), 0x0000080000000000);
			UProperty* NewProp_AlphaBlend = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AlphaBlend"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AlphaBlend, FAlphaBlend), 0x0000080000000000);
			UProperty* NewProp_AlphaLerp = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AlphaLerp"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AlphaLerp, FAlphaBlend), 0x0000080000000000);
			UProperty* NewProp_CustomCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CustomCurve, FAlphaBlend), 0x0000000000000001, Z_Construct_UClass_UCurveFloat_NoRegister());
			UProperty* NewProp_BlendTime = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BlendTime"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BlendTime, FAlphaBlend), 0x0000000000000001);
			UProperty* NewProp_DesiredValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("DesiredValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DesiredValue, FAlphaBlend), 0x0000000000000001);
			UProperty* NewProp_BeginValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BeginValue"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(BeginValue, FAlphaBlend), 0x0000000000000001);
			UProperty* NewProp_BlendOption = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BlendOption"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BlendOption, FAlphaBlend), 0x0000000000000001, Z_Construct_UEnum_Engine_EAlphaBlendOption());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Alpha Blend Type"));
			MetaData->SetValue(NewProp_BlendedValue, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_BlendedValue, TEXT("ToolTip"), TEXT("The current blended value derived from the begin and desired values"));
			MetaData->SetValue(NewProp_BlendTimeRemaining, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_BlendTimeRemaining, TEXT("ToolTip"), TEXT("Time left to reach target"));
			MetaData->SetValue(NewProp_AlphaTarget, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_AlphaTarget, TEXT("ToolTip"), TEXT("Target to reach"));
			MetaData->SetValue(NewProp_AlphaBlend, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_AlphaBlend, TEXT("ToolTip"), TEXT("Resulting Alpha value, between 0.f and 1.f"));
			MetaData->SetValue(NewProp_AlphaLerp, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_AlphaLerp, TEXT("ToolTip"), TEXT("Internal Lerped value for Alpha"));
			MetaData->SetValue(NewProp_CustomCurve, TEXT("Category"), TEXT("Blend"));
			MetaData->SetValue(NewProp_CustomCurve, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_BlendTime, TEXT("Category"), TEXT("Blend"));
			MetaData->SetValue(NewProp_BlendTime, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_DesiredValue, TEXT("Category"), TEXT("Blend"));
			MetaData->SetValue(NewProp_DesiredValue, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_BeginValue, TEXT("Category"), TEXT("Blend"));
			MetaData->SetValue(NewProp_BeginValue, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_BlendOption, TEXT("Category"), TEXT("Blend"));
			MetaData->SetValue(NewProp_BlendOption, TEXT("ModuleRelativePath"), TEXT("Public/AlphaBlend.h"));
			MetaData->SetValue(NewProp_BlendOption, TEXT("ToolTip"), TEXT("Type of blending used (Linear, Cubic, etc.)"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAlphaBlend_CRC() { return 3639699782U; }
	UEnum* Z_Construct_UEnum_Engine_ETransitionLogicType()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ETransitionLogicType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ETransitionLogicType"), 0, Get_Z_Construct_UEnum_Engine_ETransitionLogicType_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ETransitionLogicType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETransitionLogicType::TLT_StandardBlend")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETransitionLogicType::TLT_Custom")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETransitionLogicType::TLT_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("TLT_Custom.DisplayName"), TEXT("Custom"));
			MetaData->SetValue(ReturnEnum, TEXT("TLT_StandardBlend.DisplayName"), TEXT("Standard Blend"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@TODO: Document"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ETransitionLogicType_CRC() { return 2414757695U; }
	UEnum* Z_Construct_UEnum_Engine_ETransitionBlendMode()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UEnum_Engine_ETransitionBlendMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ETransitionBlendMode"), 0, Get_Z_Construct_UEnum_Engine_ETransitionBlendMode_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ETransitionBlendMode"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETransitionBlendMode::TBM_Linear")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETransitionBlendMode::TBM_Cubic")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ETransitionBlendMode::TBM_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("TBM_Cubic.DisplayName"), TEXT("Cubic"));
			MetaData->SetValue(ReturnEnum, TEXT("TBM_Linear.DisplayName"), TEXT("Linear"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@TODO: Document"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Engine_ETransitionBlendMode_CRC() { return 2297858928U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBakedAnimationStateMachine()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBakedAnimationStateMachine_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BakedAnimationStateMachine"), sizeof(FBakedAnimationStateMachine), Get_Z_Construct_UScriptStruct_FBakedAnimationStateMachine_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BakedAnimationStateMachine"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBakedAnimationStateMachine>, EStructFlags(0x00000001));
			UProperty* NewProp_Transitions = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Transitions"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Transitions, FBakedAnimationStateMachine), 0x0000000000000000);
			UProperty* NewProp_Transitions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Transitions, TEXT("Transitions"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAnimationTransitionBetweenStates());
			UProperty* NewProp_States = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("States"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(States, FBakedAnimationStateMachine), 0x0000000000000000);
			UProperty* NewProp_States_Inner = new(EC_InternalUseOnlyConstructor, NewProp_States, TEXT("States"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FBakedAnimationState());
			UProperty* NewProp_InitialState = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InitialState"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InitialState, FBakedAnimationStateMachine), 0x0000000000000000);
			UProperty* NewProp_MachineName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MachineName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(MachineName, FBakedAnimationStateMachine), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_Transitions, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_Transitions, TEXT("ToolTip"), TEXT("List of all transitions between states"));
			MetaData->SetValue(NewProp_States, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_States, TEXT("ToolTip"), TEXT("List of all states this machine can be in"));
			MetaData->SetValue(NewProp_InitialState, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_InitialState, TEXT("ToolTip"), TEXT("Index of the initial state that the machine will start in"));
			MetaData->SetValue(NewProp_MachineName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_MachineName, TEXT("ToolTip"), TEXT("Name of this machine (primarily for debugging purposes)"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBakedAnimationStateMachine_CRC() { return 107155310U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBakedAnimationState()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBakedAnimationState_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BakedAnimationState"), sizeof(FBakedAnimationState), Get_Z_Construct_UScriptStruct_FBakedAnimationState_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BakedAnimationState"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBakedAnimationState>, EStructFlags(0x00000001));
			UProperty* NewProp_PlayerNodeIndices = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PlayerNodeIndices"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(PlayerNodeIndices, FBakedAnimationState), 0x0000000000000000);
			UProperty* NewProp_PlayerNodeIndices_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PlayerNodeIndices, TEXT("PlayerNodeIndices"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			UProperty* NewProp_EntryRuleNodeIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EntryRuleNodeIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EntryRuleNodeIndex, FBakedAnimationState), 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsAConduit, FBakedAnimationState, bool);
			UProperty* NewProp_bIsAConduit = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsAConduit"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsAConduit, FBakedAnimationState), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bIsAConduit, FBakedAnimationState), sizeof(bool), true);
			UProperty* NewProp_FullyBlendedNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FullyBlendedNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(FullyBlendedNotify, FBakedAnimationState), 0x0000000000000000);
			UProperty* NewProp_EndNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EndNotify, FBakedAnimationState), 0x0000000000000000);
			UProperty* NewProp_StartNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StartNotify, FBakedAnimationState), 0x0000000000000000);
			UProperty* NewProp_StateRootNodeIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StateRootNodeIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StateRootNodeIndex, FBakedAnimationState), 0x0000000000000000);
			UProperty* NewProp_Transitions = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Transitions"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Transitions, FBakedAnimationState), 0x0000000000000000);
			UProperty* NewProp_Transitions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Transitions, TEXT("Transitions"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FBakedStateExitTransition());
			UProperty* NewProp_StateName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StateName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(StateName, FBakedAnimationState), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_PlayerNodeIndices, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_PlayerNodeIndices, TEXT("ToolTip"), TEXT("Indices into the property array for player nodes in the state"));
			MetaData->SetValue(NewProp_EntryRuleNodeIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_bIsAConduit, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_FullyBlendedNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_EndNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StartNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StateRootNodeIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StateRootNodeIndex, TEXT("ToolTip"), TEXT("The root node index (into the AnimNodeProperties array of the UAnimBlueprintGeneratedClass)"));
			MetaData->SetValue(NewProp_Transitions, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_Transitions, TEXT("ToolTip"), TEXT("Set of legal transitions out of this state; already in priority order"));
			MetaData->SetValue(NewProp_StateName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StateName, TEXT("ToolTip"), TEXT("The name of this state"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBakedAnimationState_CRC() { return 2044348762U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBakedStateExitTransition()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FBakedStateExitTransition_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("BakedStateExitTransition"), sizeof(FBakedStateExitTransition), Get_Z_Construct_UScriptStruct_FBakedStateExitTransition_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BakedStateExitTransition"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBakedStateExitTransition>, EStructFlags(0x00000001));
			UProperty* NewProp_PoseEvaluatorLinks = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PoseEvaluatorLinks"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(PoseEvaluatorLinks, FBakedStateExitTransition), 0x0000000000000000);
			UProperty* NewProp_PoseEvaluatorLinks_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PoseEvaluatorLinks, TEXT("PoseEvaluatorLinks"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDesiredTransitionReturnValue, FBakedStateExitTransition, bool);
			UProperty* NewProp_bDesiredTransitionReturnValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bDesiredTransitionReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDesiredTransitionReturnValue, FBakedStateExitTransition), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bDesiredTransitionReturnValue, FBakedStateExitTransition), sizeof(bool), true);
			UProperty* NewProp_StateSequencePlayerToQueryIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StateSequencePlayerToQueryIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StateSequencePlayerToQueryIndex, FBakedStateExitTransition), 0x0000000000000000);
			UProperty* NewProp_TransitionIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TransitionIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(TransitionIndex, FBakedStateExitTransition), 0x0000000000000000);
			UProperty* NewProp_CustomResultNodeIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomResultNodeIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(CustomResultNodeIndex, FBakedStateExitTransition), 0x0000000000000000);
			UProperty* NewProp_CanTakeDelegateIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CanTakeDelegateIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(CanTakeDelegateIndex, FBakedStateExitTransition), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_PoseEvaluatorLinks, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_bDesiredTransitionReturnValue, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_bDesiredTransitionReturnValue, TEXT("ToolTip"), TEXT("What the transition rule node needs to return to take this transition (for bidirectional transitions)"));
			MetaData->SetValue(NewProp_StateSequencePlayerToQueryIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StateSequencePlayerToQueryIndex, TEXT("ToolTip"), TEXT("For transitions that go automatically at the end of the sequence, this is the index for the sole sequence player node in the graph"));
			MetaData->SetValue(NewProp_TransitionIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_TransitionIndex, TEXT("ToolTip"), TEXT("The index into the machine table of transitions"));
			MetaData->SetValue(NewProp_CustomResultNodeIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_CustomResultNodeIndex, TEXT("ToolTip"), TEXT("The blend graph result node index"));
			MetaData->SetValue(NewProp_CanTakeDelegateIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_CanTakeDelegateIndex, TEXT("ToolTip"), TEXT("The node property index for this rule"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBakedStateExitTransition_CRC() { return 186565357U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimationTransitionBetweenStates()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimationTransitionBetweenStates_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimationTransitionBetweenStates"), sizeof(FAnimationTransitionBetweenStates), Get_Z_Construct_UScriptStruct_FAnimationTransitionBetweenStates_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimationTransitionBetweenStates"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FAnimationStateBase(), new UScriptStruct::TCppStructOps<FAnimationTransitionBetweenStates>, EStructFlags(0x00000001));
			UProperty* NewProp_LogicType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LogicType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LogicType, FAnimationTransitionBetweenStates), 0x0000000000000000, Z_Construct_UEnum_Engine_ETransitionLogicType());
			UProperty* NewProp_CustomCurve = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CustomCurve"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CustomCurve, FAnimationTransitionBetweenStates), 0x0000000000000000, Z_Construct_UClass_UCurveFloat_NoRegister());
			UProperty* NewProp_BlendMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BlendMode"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(BlendMode, FAnimationTransitionBetweenStates), 0x0000000000000000, Z_Construct_UEnum_Engine_EAlphaBlendOption());
			UProperty* NewProp_InterruptNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterruptNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InterruptNotify, FAnimationTransitionBetweenStates), 0x0000000000000000);
			UProperty* NewProp_EndNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EndNotify, FAnimationTransitionBetweenStates), 0x0000000000000000);
			UProperty* NewProp_StartNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StartNotify, FAnimationTransitionBetweenStates), 0x0000000000000000);
			UProperty* NewProp_CrossfadeDuration = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("CrossfadeDuration"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CrossfadeDuration, FAnimationTransitionBetweenStates), 0x0000000000000000);
			UProperty* NewProp_NextState = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("NextState"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NextState, FAnimationTransitionBetweenStates), 0x0000000000000000);
			UProperty* NewProp_PreviousState = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PreviousState"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(PreviousState, FAnimationTransitionBetweenStates), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("This represents a baked transition"));
			MetaData->SetValue(NewProp_LogicType, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_CustomCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_BlendMode, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_InterruptNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_EndNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StartNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_CrossfadeDuration, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_NextState, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_NextState, TEXT("ToolTip"), TEXT("Transition-only: State being transitioned to"));
			MetaData->SetValue(NewProp_PreviousState, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_PreviousState, TEXT("ToolTip"), TEXT("Transition-only: State being transitioned from"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimationTransitionBetweenStates_CRC() { return 249594015U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimationState()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimationState_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimationState"), sizeof(FAnimationState), Get_Z_Construct_UScriptStruct_FAnimationState_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimationState"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FAnimationStateBase(), new UScriptStruct::TCppStructOps<FAnimationState>, EStructFlags(0x00000001));
			UProperty* NewProp_FullyBlendedNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FullyBlendedNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(FullyBlendedNotify, FAnimationState), 0x0000000000000000);
			UProperty* NewProp_EndNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EndNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EndNotify, FAnimationState), 0x0000000000000000);
			UProperty* NewProp_StartNotify = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartNotify"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StartNotify, FAnimationState), 0x0000000000000000);
			UProperty* NewProp_StateRootNodeIndex = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StateRootNodeIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StateRootNodeIndex, FAnimationState), 0x0000000000000000);
			UProperty* NewProp_Transitions = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Transitions"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Transitions, FAnimationState), 0x0000000000000000);
			UProperty* NewProp_Transitions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Transitions, TEXT("Transitions"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAnimationTransitionRule());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_FullyBlendedNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_FullyBlendedNotify, TEXT("ToolTip"), TEXT("The index of the notify to fire when this state is fully entered (weight within the machine becomes one)"));
			MetaData->SetValue(NewProp_EndNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_EndNotify, TEXT("ToolTip"), TEXT("The index of the notify to fire when this state is finished exiting (weight within the machine becomes zero)"));
			MetaData->SetValue(NewProp_StartNotify, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StartNotify, TEXT("ToolTip"), TEXT("The index of the notify to fire when this state is first entered (weight within the machine becomes non-zero)"));
			MetaData->SetValue(NewProp_StateRootNodeIndex, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StateRootNodeIndex, TEXT("ToolTip"), TEXT("The root node index (into the AnimNodeProperties array of the UAnimBlueprintGeneratedClass)"));
			MetaData->SetValue(NewProp_Transitions, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_Transitions, TEXT("ToolTip"), TEXT("Set of legal transitions out of this state; already in priority order"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimationState_CRC() { return 58375980U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAnimationStateBase()
	{
		UPackage* Outer=Z_Construct_UPackage_Engine();
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimationStateBase_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("AnimationStateBase"), sizeof(FAnimationStateBase), Get_Z_Construct_UScriptStruct_FAnimationStateBase_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimationStateBase"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAnimationStateBase>, EStructFlags(0x00000001));
			UProperty* NewProp_StateName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StateName"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(StateName, FAnimationStateBase), 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("This is the base class that both baked states and transitions use"));
			MetaData->SetValue(NewProp_StateName, TEXT("ModuleRelativePath"), TEXT("Classes/Animation/AnimStateMachineTypes.h"));
			MetaData->SetValue(NewProp_StateName, TEXT("ToolTip"), TEXT("The name of this state"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimationStateBase_CRC() { return 2441344917U; }
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
