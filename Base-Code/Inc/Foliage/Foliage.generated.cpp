// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/FoliagePrivate.h"
#include "Foliage.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeFoliage() {}
	void UFoliageInstancedStaticMeshComponent::StaticRegisterNativesUFoliageInstancedStaticMeshComponent()
	{
	}
	IMPLEMENT_CLASS(UFoliageInstancedStaticMeshComponent, 2713016755);
	void UFoliageStatistics::StaticRegisterNativesUFoliageStatistics()
	{
		FNativeFunctionRegistrar::RegisterFunction(UFoliageStatistics::StaticClass(),"FoliageOverlappingBoxCount",(Native)&UFoliageStatistics::execFoliageOverlappingBoxCount);
		FNativeFunctionRegistrar::RegisterFunction(UFoliageStatistics::StaticClass(),"FoliageOverlappingSphereCount",(Native)&UFoliageStatistics::execFoliageOverlappingSphereCount);
	}
	IMPLEMENT_CLASS(UFoliageStatistics, 2685694500);
static class UEnum* EFoliageScaling_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_EFoliageScaling();
		extern FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
		Singleton = GetStaticEnum(Z_Construct_UEnum_Foliage_EFoliageScaling, Z_Construct_UPackage_Foliage(), TEXT("EFoliageScaling"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EFoliageScaling(EFoliageScaling_StaticEnum, TEXT("/Script/Foliage"));
static class UEnum* FoliageVertexColorMask_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_FoliageVertexColorMask();
		extern FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
		Singleton = GetStaticEnum(Z_Construct_UEnum_Foliage_FoliageVertexColorMask, Z_Construct_UPackage_Foliage(), TEXT("FoliageVertexColorMask"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_FoliageVertexColorMask(FoliageVertexColorMask_StaticEnum, TEXT("/Script/Foliage"));
	void UFoliageType::StaticRegisterNativesUFoliageType()
	{
	}
	IMPLEMENT_CLASS(UFoliageType, 814805609);
	void UFoliageType_InstancedStaticMesh::StaticRegisterNativesUFoliageType_InstancedStaticMesh()
	{
	}
	IMPLEMENT_CLASS(UFoliageType_InstancedStaticMesh, 336372084);
	void AInstancedFoliageActor::StaticRegisterNativesAInstancedFoliageActor()
	{
	}
	IMPLEMENT_CLASS(AInstancedFoliageActor, 2778616773);
	void AInteractiveFoliageActor::StaticRegisterNativesAInteractiveFoliageActor()
	{
		FNativeFunctionRegistrar::RegisterFunction(AInteractiveFoliageActor::StaticClass(),"CapsuleTouched",(Native)&AInteractiveFoliageActor::execCapsuleTouched);
	}
	IMPLEMENT_CLASS(AInteractiveFoliageActor, 2345428588);
	void UInteractiveFoliageComponent::StaticRegisterNativesUInteractiveFoliageComponent()
	{
	}
	IMPLEMENT_CLASS(UInteractiveFoliageComponent, 1134448159);
	void AProceduralFoliageBlockingVolume::StaticRegisterNativesAProceduralFoliageBlockingVolume()
	{
	}
	IMPLEMENT_CLASS(AProceduralFoliageBlockingVolume, 3010347935);
static class UEnum* ESimulationQuery_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_ESimulationQuery();
		extern FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
		Singleton = GetStaticEnum(Z_Construct_UEnum_Foliage_ESimulationQuery, Z_Construct_UPackage_Foliage(), TEXT("ESimulationQuery"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESimulationQuery(ESimulationQuery_StaticEnum, TEXT("/Script/Foliage"));
static class UEnum* ESimulationOverlap_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_ESimulationOverlap();
		extern FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
		Singleton = GetStaticEnum(Z_Construct_UEnum_Foliage_ESimulationOverlap, Z_Construct_UPackage_Foliage(), TEXT("ESimulationOverlap"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESimulationOverlap(ESimulationOverlap_StaticEnum, TEXT("/Script/Foliage"));
class UScriptStruct* FProceduralFoliageInstance::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern FOLIAGE_API class UScriptStruct* Z_Construct_UScriptStruct_FProceduralFoliageInstance();
		extern FOLIAGE_API uint32 Get_Z_Construct_UScriptStruct_FProceduralFoliageInstance_CRC();
		extern FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FProceduralFoliageInstance, Z_Construct_UPackage_Foliage(), TEXT("ProceduralFoliageInstance"), sizeof(FProceduralFoliageInstance), Get_Z_Construct_UScriptStruct_FProceduralFoliageInstance_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FProceduralFoliageInstance(FProceduralFoliageInstance::StaticStruct, TEXT("/Script/Foliage"));
static struct FScriptStruct_Foliage_StaticRegisterNativesFProceduralFoliageInstance
{
	FScriptStruct_Foliage_StaticRegisterNativesFProceduralFoliageInstance()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("ProceduralFoliageInstance")),new UScriptStruct::TCppStructOps<FProceduralFoliageInstance>);
	}
} ScriptStruct_Foliage_StaticRegisterNativesFProceduralFoliageInstance;
	void UProceduralFoliageComponent::StaticRegisterNativesUProceduralFoliageComponent()
	{
	}
	IMPLEMENT_CLASS(UProceduralFoliageComponent, 1908375328);
class UScriptStruct* FFoliageTypeObject::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern FOLIAGE_API class UScriptStruct* Z_Construct_UScriptStruct_FFoliageTypeObject();
		extern FOLIAGE_API uint32 Get_Z_Construct_UScriptStruct_FFoliageTypeObject_CRC();
		extern FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FFoliageTypeObject, Z_Construct_UPackage_Foliage(), TEXT("FoliageTypeObject"), sizeof(FFoliageTypeObject), Get_Z_Construct_UScriptStruct_FFoliageTypeObject_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FFoliageTypeObject(FFoliageTypeObject::StaticStruct, TEXT("/Script/Foliage"));
static struct FScriptStruct_Foliage_StaticRegisterNativesFFoliageTypeObject
{
	FScriptStruct_Foliage_StaticRegisterNativesFFoliageTypeObject()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("FoliageTypeObject")),new UScriptStruct::TCppStructOps<FFoliageTypeObject>);
	}
} ScriptStruct_Foliage_StaticRegisterNativesFFoliageTypeObject;
	void UProceduralFoliageSpawner::StaticRegisterNativesUProceduralFoliageSpawner()
	{
		FNativeFunctionRegistrar::RegisterFunction(UProceduralFoliageSpawner::StaticClass(),"Simulate",(Native)&UProceduralFoliageSpawner::execSimulate);
	}
	IMPLEMENT_CLASS(UProceduralFoliageSpawner, 292567866);
	void UProceduralFoliageTile::StaticRegisterNativesUProceduralFoliageTile()
	{
	}
	IMPLEMENT_CLASS(UProceduralFoliageTile, 3959590636);
	void AProceduralFoliageVolume::StaticRegisterNativesAProceduralFoliageVolume()
	{
	}
	IMPLEMENT_CLASS(AProceduralFoliageVolume, 1769517770);
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDamageType_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_AController_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBox();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMesh_NoRegister();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintFunctionLibrary();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRuntimeFloatCurve();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatInterval();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBodyInstance();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInt32Interval();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EComponentMobility();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBoxSphereBounds();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FGuid();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AStaticMeshActor();
	ENGINE_API class UClass* Z_Construct_UClass_UCapsuleComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent();
	ENGINE_API class UClass* Z_Construct_UClass_AVolume();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FQuat();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	ENGINE_API class UClass* Z_Construct_UClass_AVolume_NoRegister();

	FOLIAGE_API class UFunction* Z_Construct_UDelegateFunction_Foliage_InstanceRadialDamageSignature__DelegateSignature();
	FOLIAGE_API class UFunction* Z_Construct_UDelegateFunction_Foliage_InstancePointDamageSignature__DelegateSignature();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageInstancedStaticMeshComponent_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageInstancedStaticMeshComponent();
	FOLIAGE_API class UFunction* Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingBoxCount();
	FOLIAGE_API class UFunction* Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingSphereCount();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageStatistics_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageStatistics();
	FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_EFoliageScaling();
	FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_FoliageVertexColorMask();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageType_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageType();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageType_InstancedStaticMesh_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UFoliageType_InstancedStaticMesh();
	FOLIAGE_API class UClass* Z_Construct_UClass_AInstancedFoliageActor_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_AInstancedFoliageActor();
	FOLIAGE_API class UFunction* Z_Construct_UFunction_AInteractiveFoliageActor_CapsuleTouched();
	FOLIAGE_API class UClass* Z_Construct_UClass_AInteractiveFoliageActor_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_AInteractiveFoliageActor();
	FOLIAGE_API class UClass* Z_Construct_UClass_UInteractiveFoliageComponent_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UInteractiveFoliageComponent();
	FOLIAGE_API class UClass* Z_Construct_UClass_AProceduralFoliageBlockingVolume_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_AProceduralFoliageBlockingVolume();
	FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_ESimulationQuery();
	FOLIAGE_API class UEnum* Z_Construct_UEnum_Foliage_ESimulationOverlap();
	FOLIAGE_API class UScriptStruct* Z_Construct_UScriptStruct_FProceduralFoliageInstance();
	FOLIAGE_API class UClass* Z_Construct_UClass_UProceduralFoliageComponent_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UProceduralFoliageComponent();
	FOLIAGE_API class UScriptStruct* Z_Construct_UScriptStruct_FFoliageTypeObject();
	FOLIAGE_API class UFunction* Z_Construct_UFunction_UProceduralFoliageSpawner_Simulate();
	FOLIAGE_API class UClass* Z_Construct_UClass_UProceduralFoliageSpawner_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UProceduralFoliageSpawner();
	FOLIAGE_API class UClass* Z_Construct_UClass_UProceduralFoliageTile_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_UProceduralFoliageTile();
	FOLIAGE_API class UClass* Z_Construct_UClass_AProceduralFoliageVolume_NoRegister();
	FOLIAGE_API class UClass* Z_Construct_UClass_AProceduralFoliageVolume();
	FOLIAGE_API class UPackage* Z_Construct_UPackage_Foliage();
	UFunction* Z_Construct_UDelegateFunction_Foliage_InstanceRadialDamageSignature__DelegateSignature()
	{
		struct _Script_Foliage_eventInstanceRadialDamageSignature_Parms
		{
			TArray<int32> Instances;
			TArray<float> Damages;
			AController* InstigatedBy;
			FVector Origin;
			float MaxRadius;
			const UDamageType* DamageType;
			AActor* DamageCauser;
		};
		UObject* Outer=Z_Construct_UPackage_Foliage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InstanceRadialDamageSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Foliage_eventInstanceRadialDamageSignature_Parms));
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_DamageType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageType"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DamageType, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000000000082, Z_Construct_UClass_UDamageType_NoRegister());
			UProperty* NewProp_MaxRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxRadius, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000000000080);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Origin, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InstigatedBy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstigatedBy"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(InstigatedBy, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_Damages = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Damages"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Damages, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000008000182);
			UProperty* NewProp_Damages_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Damages, TEXT("Damages"), RF_Public|RF_Transient|RF_Native) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			UProperty* NewProp_Instances = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Instances"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(Instances, _Script_Foliage_eventInstanceRadialDamageSignature_Parms), 0x0000000008000182);
			UProperty* NewProp_Instances_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Instances, TEXT("Instances"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/FoliageInstancedStaticMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Foliage_InstancePointDamageSignature__DelegateSignature()
	{
		struct _Script_Foliage_eventInstancePointDamageSignature_Parms
		{
			int32 InstanceIndex;
			float Damage;
			AController* InstigatedBy;
			FVector HitLocation;
			FVector ShotFromDirection;
			const UDamageType* DamageType;
			AActor* DamageCauser;
		};
		UObject* Outer=Z_Construct_UPackage_Foliage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InstancePointDamageSignature__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_Foliage_eventInstancePointDamageSignature_Parms));
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_DamageType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageType"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DamageType, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000082, Z_Construct_UClass_UDamageType_NoRegister());
			UProperty* NewProp_ShotFromDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ShotFromDirection"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ShotFromDirection, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_HitLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitLocation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(HitLocation, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InstigatedBy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstigatedBy"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(InstigatedBy, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_Damage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Damage"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Damage, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000080);
			UProperty* NewProp_InstanceIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstanceIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(InstanceIndex, _Script_Foliage_eventInstancePointDamageSignature_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/FoliageInstancedStaticMeshComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UFoliageInstancedStaticMeshComponent_NoRegister()
	{
		return UFoliageInstancedStaticMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UFoliageInstancedStaticMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UHierarchicalInstancedStaticMeshComponent();
			Z_Construct_UPackage_Foliage();
			OuterClass = UFoliageInstancedStaticMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_FoliageHiddenEditorViews = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageHiddenEditorViews"), RF_Public|RF_Transient|RF_Native) UUInt64Property(CPP_PROPERTY_BASE(FoliageHiddenEditorViews, UFoliageInstancedStaticMeshComponent), 0x0000000800002000);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_OnInstanceTakeRadialDamage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInstanceTakeRadialDamage"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInstanceTakeRadialDamage, UFoliageInstancedStaticMeshComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Foliage_InstanceRadialDamageSignature__DelegateSignature());
				UProperty* NewProp_OnInstanceTakePointDamage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInstanceTakePointDamage"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInstanceTakePointDamage, UFoliageInstancedStaticMeshComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_Foliage_InstancePointDamageSignature__DelegateSignature());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Foliage"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("FoliageInstancedStaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/FoliageInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_FoliageHiddenEditorViews, TEXT("ModuleRelativePath"), TEXT("Public/FoliageInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_OnInstanceTakeRadialDamage, TEXT("Category"), TEXT("Game|Damage"));
				MetaData->SetValue(NewProp_OnInstanceTakeRadialDamage, TEXT("ModuleRelativePath"), TEXT("Public/FoliageInstancedStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_OnInstanceTakePointDamage, TEXT("Category"), TEXT("Game|Damage"));
				MetaData->SetValue(NewProp_OnInstanceTakePointDamage, TEXT("ModuleRelativePath"), TEXT("Public/FoliageInstancedStaticMeshComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UFoliageInstancedStaticMeshComponent(Z_Construct_UClass_UFoliageInstancedStaticMeshComponent, TEXT("UFoliageInstancedStaticMeshComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UFoliageInstancedStaticMeshComponent);
	UFunction* Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingBoxCount()
	{
		struct FoliageStatistics_eventFoliageOverlappingBoxCount_Parms
		{
			UObject* WorldContextObject;
			const UStaticMesh* StaticMesh;
			FBox Box;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UFoliageStatistics();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FoliageOverlappingBoxCount"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04822401, 65535, sizeof(FoliageStatistics_eventFoliageOverlappingBoxCount_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, FoliageStatistics_eventFoliageOverlappingBoxCount_Parms), 0x0000000000000580);
			UProperty* NewProp_Box = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Box"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Box, FoliageStatistics_eventFoliageOverlappingBoxCount_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FBox());
			UProperty* NewProp_StaticMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StaticMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(StaticMesh, FoliageStatistics_eventFoliageOverlappingBoxCount_Parms), 0x0000000000000082, Z_Construct_UClass_UStaticMesh_NoRegister());
			UProperty* NewProp_WorldContextObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContextObject"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContextObject, FoliageStatistics_eventFoliageOverlappingBoxCount_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Foliage"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/FoliageStatistics.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the number of instances overlapping a provided box\n@param StaticMesh Mesh to count\n@param Box Box to overlap"));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContextObject"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingSphereCount()
	{
		struct FoliageStatistics_eventFoliageOverlappingSphereCount_Parms
		{
			UObject* WorldContextObject;
			const UStaticMesh* StaticMesh;
			FVector CenterPosition;
			float Radius;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UFoliageStatistics();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FoliageOverlappingSphereCount"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04822401, 65535, sizeof(FoliageStatistics_eventFoliageOverlappingSphereCount_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, FoliageStatistics_eventFoliageOverlappingSphereCount_Parms), 0x0000000000000580);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, FoliageStatistics_eventFoliageOverlappingSphereCount_Parms), 0x0000000000000080);
			UProperty* NewProp_CenterPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CenterPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CenterPosition, FoliageStatistics_eventFoliageOverlappingSphereCount_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_StaticMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StaticMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(StaticMesh, FoliageStatistics_eventFoliageOverlappingSphereCount_Parms), 0x0000000000000082, Z_Construct_UClass_UStaticMesh_NoRegister());
			UProperty* NewProp_WorldContextObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContextObject"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(WorldContextObject, FoliageStatistics_eventFoliageOverlappingSphereCount_Parms), 0x0000000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Foliage"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/FoliageStatistics.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Counts how many foliage instances overlap a given sphere\n\n@param        Mesh                    The static mesh we are interested in counting\n@param        CenterPosition  The center position of the sphere\n@param        Radius                  The radius of the sphere.\n\nreturn number of foliage instances with their mesh set to Mesh that overlap the sphere"));
			MetaData->SetValue(ReturnFunction, TEXT("UnsafeDuringActorConstruction"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContextObject"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UFoliageStatistics_NoRegister()
	{
		return UFoliageStatistics::StaticClass();
	}
	UClass* Z_Construct_UClass_UFoliageStatistics()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UBlueprintFunctionLibrary();
			Z_Construct_UPackage_Foliage();
			OuterClass = UFoliageStatistics::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingBoxCount());
				OuterClass->LinkChild(Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingSphereCount());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingBoxCount()); // 772911483
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UFoliageStatistics_FoliageOverlappingSphereCount()); // 3883998639
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("FoliageStatistics.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/FoliageStatistics.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UFoliageStatistics(Z_Construct_UClass_UFoliageStatistics, TEXT("UFoliageStatistics"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UFoliageStatistics);
	UEnum* Z_Construct_UEnum_Foliage_EFoliageScaling()
	{
		UPackage* Outer=Z_Construct_UPackage_Foliage();
		extern uint32 Get_Z_Construct_UEnum_Foliage_EFoliageScaling_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("EFoliageScaling"), 0, Get_Z_Construct_UEnum_Foliage_EFoliageScaling_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EFoliageScaling"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFoliageScaling::Uniform")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFoliageScaling::Free")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFoliageScaling::LockXY")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFoliageScaling::LockXZ")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFoliageScaling::LockYZ")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFoliageScaling::EFoliageScaling_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("Free.ToolTip"), TEXT("Foliage instances will have random X,Y and Z scales."));
			MetaData->SetValue(ReturnEnum, TEXT("LockXY.ToolTip"), TEXT("Locks the X and Y axis scale."));
			MetaData->SetValue(ReturnEnum, TEXT("LockXZ.ToolTip"), TEXT("Locks the X and Z axis scale."));
			MetaData->SetValue(ReturnEnum, TEXT("LockYZ.ToolTip"), TEXT("Locks the Y and Z axis scale."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Uniform.ToolTip"), TEXT("Foliage instances will have uniform X,Y and Z scales."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Foliage_EFoliageScaling_CRC() { return 2382163602U; }
	UEnum* Z_Construct_UEnum_Foliage_FoliageVertexColorMask()
	{
		UPackage* Outer=Z_Construct_UPackage_Foliage();
		extern uint32 Get_Z_Construct_UEnum_Foliage_FoliageVertexColorMask_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("FoliageVertexColorMask"), 0, Get_Z_Construct_UEnum_Foliage_FoliageVertexColorMask_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FoliageVertexColorMask"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FOLIAGEVERTEXCOLORMASK_Disabled")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FOLIAGEVERTEXCOLORMASK_Red")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FOLIAGEVERTEXCOLORMASK_Green")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FOLIAGEVERTEXCOLORMASK_Blue")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FOLIAGEVERTEXCOLORMASK_Alpha")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FOLIAGEVERTEXCOLORMASK_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("FOLIAGEVERTEXCOLORMASK_Alpha.DisplayName"), TEXT("Alpha"));
			MetaData->SetValue(ReturnEnum, TEXT("FOLIAGEVERTEXCOLORMASK_Blue.DisplayName"), TEXT("Blue"));
			MetaData->SetValue(ReturnEnum, TEXT("FOLIAGEVERTEXCOLORMASK_Disabled.DisplayName"), TEXT("Disabled"));
			MetaData->SetValue(ReturnEnum, TEXT("FOLIAGEVERTEXCOLORMASK_Green.DisplayName"), TEXT("Green"));
			MetaData->SetValue(ReturnEnum, TEXT("FOLIAGEVERTEXCOLORMASK_Red.DisplayName"), TEXT("Red"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Foliage_FoliageVertexColorMask_CRC() { return 338792085U; }
	UClass* Z_Construct_UClass_UFoliageType_NoRegister()
	{
		return UFoliageType::StaticClass();
	}
	UClass* Z_Construct_UClass_UFoliageType()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Foliage();
			OuterClass = UFoliageType::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20081080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
#if WITH_EDITORONLY_DATA
				UProperty* NewProp_MaxScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxScale_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_MinScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinScale_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_MinGroundSlope = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinGroundSlope"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinGroundSlope_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_GroundSlope = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroundSlope"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GroundSlope_DEPRECATED, UFoliageType), 0x0000000820000000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(LockScaleZ_DEPRECATED, UFoliageType, uint8);
				UProperty* NewProp_LockScaleZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LockScaleZ"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(LockScaleZ_DEPRECATED, UFoliageType), 0x0000000820000000, CPP_BOOL_PROPERTY_BITMASK(LockScaleZ_DEPRECATED, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(LockScaleY_DEPRECATED, UFoliageType, uint8);
				UProperty* NewProp_LockScaleY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LockScaleY"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(LockScaleY_DEPRECATED, UFoliageType), 0x0000000820000000, CPP_BOOL_PROPERTY_BITMASK(LockScaleY_DEPRECATED, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(LockScaleX_DEPRECATED, UFoliageType, uint8);
				UProperty* NewProp_LockScaleX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LockScaleX"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(LockScaleX_DEPRECATED, UFoliageType), 0x0000000820000000, CPP_BOOL_PROPERTY_BITMASK(LockScaleX_DEPRECATED, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(UniformScale_DEPRECATED, UFoliageType, uint8);
				UProperty* NewProp_UniformScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UniformScale"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UniformScale_DEPRECATED, UFoliageType), 0x0000000820000000, CPP_BOOL_PROPERTY_BITMASK(UniformScale_DEPRECATED, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_EndCullDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EndCullDistance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(EndCullDistance_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_StartCullDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StartCullDistance"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(StartCullDistance_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ZOffsetMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ZOffsetMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ZOffsetMax_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ZOffsetMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ZOffsetMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ZOffsetMin_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_HeightMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HeightMax"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HeightMax_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_HeightMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HeightMin"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(HeightMin_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ScaleMaxZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMaxZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMaxZ_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ScaleMaxY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMaxY"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMaxY_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ScaleMaxX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMaxX"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMaxX_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ScaleMinZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMinZ"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMinZ_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ScaleMinY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMinY"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMinY_DEPRECATED, UFoliageType), 0x0000000820000000);
				UProperty* NewProp_ScaleMinX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMinX"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleMinX_DEPRECATED, UFoliageType), 0x0000000820000000);
#endif // WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyVertexColorMask, UFoliageType, uint8);
				UProperty* NewProp_ReapplyVertexColorMask = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyVertexColorMask"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyVertexColorMask, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyVertexColorMask, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyCollisionWithWorld, UFoliageType, uint8);
				UProperty* NewProp_ReapplyCollisionWithWorld = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyCollisionWithWorld"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyCollisionWithWorld, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyCollisionWithWorld, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyZOffset, UFoliageType, uint8);
				UProperty* NewProp_ReapplyZOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyZOffset"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyZOffset, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyZOffset, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyLandscapeLayers, UFoliageType, uint8);
				UProperty* NewProp_ReapplyLandscapeLayers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyLandscapeLayers"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyLandscapeLayers, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyLandscapeLayers, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyHeight, UFoliageType, uint8);
				UProperty* NewProp_ReapplyHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyHeight"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyHeight, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyHeight, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyGroundSlope, UFoliageType, uint8);
				UProperty* NewProp_ReapplyGroundSlope = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyGroundSlope"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyGroundSlope, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyGroundSlope, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyRandomPitchAngle, UFoliageType, uint8);
				UProperty* NewProp_ReapplyRandomPitchAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyRandomPitchAngle"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyRandomPitchAngle, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyRandomPitchAngle, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyScaleZ, UFoliageType, uint8);
				UProperty* NewProp_ReapplyScaleZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyScaleZ"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyScaleZ, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyScaleZ, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyScaleY, UFoliageType, uint8);
				UProperty* NewProp_ReapplyScaleY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyScaleY"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyScaleY, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyScaleY, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyScaleX, UFoliageType, uint8);
				UProperty* NewProp_ReapplyScaleX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyScaleX"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyScaleX, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyScaleX, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyScaling, UFoliageType, uint8);
				UProperty* NewProp_ReapplyScaling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyScaling"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyScaling, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyScaling, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyRandomYaw, UFoliageType, uint8);
				UProperty* NewProp_ReapplyRandomYaw = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyRandomYaw"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyRandomYaw, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyRandomYaw, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyAlignToNormal, UFoliageType, uint8);
				UProperty* NewProp_ReapplyAlignToNormal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyAlignToNormal"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyAlignToNormal, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyAlignToNormal, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyRadius, UFoliageType, uint8);
				UProperty* NewProp_ReapplyRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyRadius"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyRadius, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyRadius, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReapplyDensity, UFoliageType, uint8);
				UProperty* NewProp_ReapplyDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReapplyDensity"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReapplyDensity, UFoliageType), 0x0000000000010001, CPP_BOOL_PROPERTY_BITMASK(ReapplyDensity, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_ChangeCount = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChangeCount"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ChangeCount, UFoliageType), 0x0000000000000000);
				UProperty* NewProp_ScaleCurve = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleCurve"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ScaleCurve, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FRuntimeFloatCurve());
				UProperty* NewProp_ProceduralScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProceduralScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ProceduralScale, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				UProperty* NewProp_OverlapPriority = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OverlapPriority"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OverlapPriority, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_MaxAge = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxAge"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxAge, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_MaxInitialAge = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxInitialAge"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxInitialAge, UFoliageType), 0x0000000000000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSpawnsInShade, UFoliageType, bool);
				UProperty* NewProp_bSpawnsInShade = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSpawnsInShade"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSpawnsInShade, UFoliageType), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bSpawnsInShade, UFoliageType), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanGrowInShade, UFoliageType, bool);
				UProperty* NewProp_bCanGrowInShade = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanGrowInShade"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanGrowInShade, UFoliageType), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(bCanGrowInShade, UFoliageType), sizeof(bool), true);
				UProperty* NewProp_MaxInitialSeedOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxInitialSeedOffset"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxInitialSeedOffset, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_DistributionSeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistributionSeed"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(DistributionSeed, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_SeedsPerStep = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SeedsPerStep"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SeedsPerStep, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_SpreadVariance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpreadVariance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(SpreadVariance, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_AverageSpreadDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AverageSpreadDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AverageSpreadDistance, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_InitialSeedDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InitialSeedDensity"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(InitialSeedDensity, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_NumSteps = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NumSteps"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NumSteps, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_ShadeRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShadeRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ShadeRadius, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_CollisionRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionRadius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(CollisionRadius, UFoliageType), 0x0000000000000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsSelected, UFoliageType, uint8);
				UProperty* NewProp_IsSelected = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsSelected"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsSelected, UFoliageType), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(IsSelected, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_HiddenEditorViews = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HiddenEditorViews"), RF_Public|RF_Transient|RF_Native) UUInt64Property(CPP_PROPERTY_BASE(HiddenEditorViews, UFoliageType), 0x0000000000002000);
				UProperty* NewProp_CustomNavigableGeometry = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomNavigableGeometry"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(CustomNavigableGeometry, UFoliageType), 0x0000000000000001, Z_Construct_UEnum_Engine_EHasCustomNavigableGeometry());
				UProperty* NewProp_BodyInstance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BodyInstance"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(BodyInstance, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FBodyInstance());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseAsOccluder, UFoliageType, uint8);
				UProperty* NewProp_bUseAsOccluder = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseAsOccluder"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseAsOccluder, UFoliageType), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bUseAsOccluder, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_OverriddenLightMapRes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OverriddenLightMapRes"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OverriddenLightMapRes, UFoliageType), 0x0000000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideLightMapRes, UFoliageType, uint8);
				UProperty* NewProp_bOverrideLightMapRes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideLightMapRes"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideLightMapRes, UFoliageType), 0x0000000000000014, CPP_BOOL_PROPERTY_BITMASK(bOverrideLightMapRes, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bReceivesDecals, UFoliageType, uint8);
				UProperty* NewProp_bReceivesDecals = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bReceivesDecals"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bReceivesDecals, UFoliageType), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bReceivesDecals, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastShadowAsTwoSided, UFoliageType, uint8);
				UProperty* NewProp_bCastShadowAsTwoSided = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastShadowAsTwoSided"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastShadowAsTwoSided, UFoliageType), 0x0000040000000015, CPP_BOOL_PROPERTY_BITMASK(bCastShadowAsTwoSided, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastStaticShadow, UFoliageType, uint8);
				UProperty* NewProp_bCastStaticShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastStaticShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastStaticShadow, UFoliageType), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bCastStaticShadow, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCastDynamicShadow, UFoliageType, uint8);
				UProperty* NewProp_bCastDynamicShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCastDynamicShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCastDynamicShadow, UFoliageType), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bCastDynamicShadow, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAffectDistanceFieldLighting, UFoliageType, uint8);
				UProperty* NewProp_bAffectDistanceFieldLighting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAffectDistanceFieldLighting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAffectDistanceFieldLighting, UFoliageType), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAffectDistanceFieldLighting, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAffectDynamicIndirectLighting, UFoliageType, uint8);
				UProperty* NewProp_bAffectDynamicIndirectLighting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAffectDynamicIndirectLighting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAffectDynamicIndirectLighting, UFoliageType), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(bAffectDynamicIndirectLighting, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(CastShadow, UFoliageType, uint8);
				UProperty* NewProp_CastShadow = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CastShadow"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(CastShadow, UFoliageType), 0x0000000000000015, CPP_BOOL_PROPERTY_BITMASK(CastShadow, UFoliageType), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableStaticLighting_DEPRECATED, UFoliageType, uint8);
				UProperty* NewProp_bEnableStaticLighting = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableStaticLighting"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableStaticLighting_DEPRECATED, UFoliageType), 0x0000000020000000, CPP_BOOL_PROPERTY_BITMASK(bEnableStaticLighting_DEPRECATED, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_CullDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CullDistance"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CullDistance, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FInt32Interval());
				UProperty* NewProp_Mobility = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mobility"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Mobility, UFoliageType), 0x0000000000000015, Z_Construct_UEnum_Engine_EComponentMobility());
				UProperty* NewProp_LowBoundOriginRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LowBoundOriginRadius"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(LowBoundOriginRadius, UFoliageType), 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_MeshBounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshBounds"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(MeshBounds, UFoliageType), 0x0000000000000000, Z_Construct_UScriptStruct_FBoxSphereBounds());
				UProperty* NewProp_MinimumLayerWeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinimumLayerWeight"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MinimumLayerWeight, UFoliageType), 0x0000040000000001);
				UProperty* NewProp_CollisionScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionScale"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(CollisionScale, UFoliageType), 0x0000040000000001, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(CollisionWithWorld, UFoliageType, uint8);
				UProperty* NewProp_CollisionWithWorld = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionWithWorld"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(CollisionWithWorld, UFoliageType), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(CollisionWithWorld, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_LandscapeLayer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LandscapeLayer"), RF_Public|RF_Transient|RF_Native) UNameProperty(CPP_PROPERTY_BASE(LandscapeLayer_DEPRECATED, UFoliageType), 0x0000000020000000);
				UProperty* NewProp_LandscapeLayers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LandscapeLayers"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(LandscapeLayers, UFoliageType), 0x0000040000000001);
				UProperty* NewProp_LandscapeLayers_Inner = new(EC_InternalUseOnlyConstructor, NewProp_LandscapeLayers, TEXT("LandscapeLayers"), RF_Public|RF_Transient|RF_Native) UNameProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_Height = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Height"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Height, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				UProperty* NewProp_GroundSlopeAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GroundSlopeAngle"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GroundSlopeAngle, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				UProperty* NewProp_RandomPitchAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RandomPitchAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(RandomPitchAngle, UFoliageType), 0x0000000000000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(RandomYaw, UFoliageType, uint8);
				UProperty* NewProp_RandomYaw = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RandomYaw"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(RandomYaw, UFoliageType), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(RandomYaw, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_AlignMaxAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AlignMaxAngle"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(AlignMaxAngle, UFoliageType), 0x0000000000000001);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(AlignToNormal, UFoliageType, uint8);
				UProperty* NewProp_AlignToNormal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AlignToNormal"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AlignToNormal, UFoliageType), 0x0000000000000001, CPP_BOOL_PROPERTY_BITMASK(AlignToNormal, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_ZOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ZOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ZOffset, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(VertexColorMaskInvert, UFoliageType, uint8);
				UProperty* NewProp_VertexColorMaskInvert = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VertexColorMaskInvert"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(VertexColorMaskInvert, UFoliageType), 0x0000040000000001, CPP_BOOL_PROPERTY_BITMASK(VertexColorMaskInvert, UFoliageType), sizeof(uint8), false);
				UProperty* NewProp_VertexColorMaskThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VertexColorMaskThreshold"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(VertexColorMaskThreshold, UFoliageType), 0x0000040000000001);
				UProperty* NewProp_VertexColorMask = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VertexColorMask"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(VertexColorMask, UFoliageType), 0x0000040000000001, Z_Construct_UEnum_Foliage_FoliageVertexColorMask());
				UProperty* NewProp_ScaleZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleZ"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ScaleZ, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				UProperty* NewProp_ScaleY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleY"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ScaleY, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				UProperty* NewProp_ScaleX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleX"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ScaleX, UFoliageType), 0x0000000000000001, Z_Construct_UScriptStruct_FFloatInterval());
				UProperty* NewProp_Scaling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Scaling"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(Scaling, UFoliageType), 0x0000000000000001, Z_Construct_UEnum_Foliage_EFoliageScaling());
				UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Radius"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Radius, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_DensityAdjustmentFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DensityAdjustmentFactor"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DensityAdjustmentFactor, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_Density = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Density"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Density, UFoliageType), 0x0000000000000001);
				UProperty* NewProp_UpdateGuid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateGuid"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(UpdateGuid, UFoliageType), 0x0000000000000000, Z_Construct_UScriptStruct_FGuid());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("FoliageType.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MaxScale, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MinScale, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MinGroundSlope, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_GroundSlope, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_LockScaleZ, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_LockScaleY, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_LockScaleX, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_UniformScale, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_EndCullDistance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_StartCullDistance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ZOffsetMax, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ZOffsetMin, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_HeightMax, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_HeightMin, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMaxZ, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMaxY, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMaxX, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMinZ, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMinY, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMinX, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleMinX, TEXT("ToolTip"), TEXT("Deprecated since FFoliageCustomVersion::FoliageTypeCustomization"));
				MetaData->SetValue(NewProp_ReapplyVertexColorMask, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyVertexColorMask, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyVertexColorMask, TEXT("ToolTip"), TEXT("If checked, foliage instances no longer matching the vertex color constraint will be removed by the Reapply too"));
				MetaData->SetValue(NewProp_ReapplyCollisionWithWorld, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyCollisionWithWorld, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyCollisionWithWorld, TEXT("ToolTip"), TEXT("If checked, foliage instances will have an overlap test with the world reapplied, and overlapping instances will be removed by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyZOffset, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyZOffset, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyZOffset, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their Z offset adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyLandscapeLayers, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyLandscapeLayers, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyLandscapeLayers, TEXT("ToolTip"), TEXT("If checked, foliage instances painted on areas that do not have the appropriate landscape layer painted will be removed by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyHeight, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyHeight, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyHeight, TEXT("ToolTip"), TEXT("If checked, foliage instances not meeting the valid Z height condition will be removed by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyGroundSlope, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyGroundSlope, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyGroundSlope, TEXT("ToolTip"), TEXT("If checked, foliage instances not meeting the ground slope condition will be removed by the Reapply too"));
				MetaData->SetValue(NewProp_ReapplyRandomPitchAngle, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyRandomPitchAngle, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyRandomPitchAngle, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their pitch adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyScaleZ, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyScaleZ, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyScaleZ, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their Z scale adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyScaleY, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyScaleY, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyScaleY, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their Y scale adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyScaleX, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyScaleX, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyScaleX, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their X scale adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyScaling, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyScaling, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyScaling, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their scale adjusted to fit the specified scaling behavior by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyRandomYaw, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyRandomYaw, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyRandomYaw, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their yaw adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyAlignToNormal, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyAlignToNormal, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyAlignToNormal, TEXT("ToolTip"), TEXT("If checked, foliage instances will have their normal alignment adjusted by the Reapply tool"));
				MetaData->SetValue(NewProp_ReapplyRadius, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyRadius, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyRadius, TEXT("ToolTip"), TEXT("If checked, foliage instances not meeting the new Radius constraint will be removed"));
				MetaData->SetValue(NewProp_ReapplyDensity, TEXT("Category"), TEXT("Reapply"));
				MetaData->SetValue(NewProp_ReapplyDensity, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ReapplyDensity, TEXT("ToolTip"), TEXT("If checked, the density of foliage instances already placed will be adjusted by the density adjustment factor."));
				MetaData->SetValue(NewProp_ChangeCount, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleCurve, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_ScaleCurve, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleCurve, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_ScaleCurve, TEXT("ToolTip"), TEXT("Instance scale factor as a function of normalized age (i.e. Current Age / Max Age).\nX = 0 corresponds to Age = 0, X = 1 corresponds to Age = Max Age.\nY = 0 corresponds to Min Scale, Y = 1 corresponds to Max Scale."));
				MetaData->SetValue(NewProp_ScaleCurve, TEXT("XAxisName"), TEXT("Normalized Age"));
				MetaData->SetValue(NewProp_ScaleCurve, TEXT("YAxisName"), TEXT("Scale Factor"));
				MetaData->SetValue(NewProp_ProceduralScale, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_ProceduralScale, TEXT("ClampMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_ProceduralScale, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ProceduralScale, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_ProceduralScale, TEXT("ToolTip"), TEXT("The scale range of this type when being procedurally generated. Configured with the Scale Curve."));
				MetaData->SetValue(NewProp_ProceduralScale, TEXT("UIMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_OverlapPriority, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_OverlapPriority, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_OverlapPriority, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_OverlapPriority, TEXT("ToolTip"), TEXT("When two instances overlap we must determine which instance to remove.\nThe instance with a lower OverlapPriority will be removed.\nIn the case where OverlapPriority is the same regular simulation rules apply."));
				MetaData->SetValue(NewProp_MaxAge, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_MaxAge, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_MaxAge, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MaxAge, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_MaxAge, TEXT("ToolTip"), TEXT("Specifies the oldest a seed can be. After reaching this age the instance will still spread seeds, but will not get any older"));
				MetaData->SetValue(NewProp_MaxAge, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_MaxInitialAge, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_MaxInitialAge, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_MaxInitialAge, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MaxInitialAge, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_MaxInitialAge, TEXT("ToolTip"), TEXT("Allows a new seed to be older than 0 when created. New seeds will be randomly assigned an age in the range [0,MaxInitialAge]"));
				MetaData->SetValue(NewProp_MaxInitialAge, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_bSpawnsInShade, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_bSpawnsInShade, TEXT("EditCondition"), TEXT("bCanGrowInShade"));
				MetaData->SetValue(NewProp_bSpawnsInShade, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bSpawnsInShade, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_bSpawnsInShade, TEXT("ToolTip"), TEXT("Whether new seeds are spawned exclusively in shade. Occurs in a second pass after all types that do not spawn in shade have been simulated.\nOnly valid when CanGrowInShade is true."));
				MetaData->SetValue(NewProp_bCanGrowInShade, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_bCanGrowInShade, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bCanGrowInShade, TEXT("Subcategory"), TEXT("Growth"));
				MetaData->SetValue(NewProp_bCanGrowInShade, TEXT("ToolTip"), TEXT("If true, seeds of this type will ignore shade radius during overlap tests with other types."));
				MetaData->SetValue(NewProp_MaxInitialSeedOffset, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_MaxInitialSeedOffset, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MaxInitialSeedOffset, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_MaxInitialSeedOffset, TEXT("ToolTip"), TEXT("The seed that determines placement of initial seeds."));
				MetaData->SetValue(NewProp_DistributionSeed, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_DistributionSeed, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_DistributionSeed, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_DistributionSeed, TEXT("ToolTip"), TEXT("The seed that determines placement of initial seeds."));
				MetaData->SetValue(NewProp_SeedsPerStep, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_SeedsPerStep, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_SeedsPerStep, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_SeedsPerStep, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_SeedsPerStep, TEXT("ToolTip"), TEXT("The number of seeds an instance will spread in a single step of the simulation."));
				MetaData->SetValue(NewProp_SeedsPerStep, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_SpreadVariance, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_SpreadVariance, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_SpreadVariance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_SpreadVariance, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_SpreadVariance, TEXT("ToolTip"), TEXT("Specifies how much seed distance varies from the average. For example, a tree with an AverageSpreadDistance 10 and a SpreadVariance 1 will produce seeds with an average distance of 10cm plus or minus 1cm"));
				MetaData->SetValue(NewProp_SpreadVariance, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_AverageSpreadDistance, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_AverageSpreadDistance, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_AverageSpreadDistance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_AverageSpreadDistance, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_AverageSpreadDistance, TEXT("ToolTip"), TEXT("The average distance between the spreading instance and its seeds. For example, a tree with an AverageSpreadDistance 10 will ensure the average distance between the tree and its seeds is 10cm"));
				MetaData->SetValue(NewProp_AverageSpreadDistance, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_InitialSeedDensity, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_InitialSeedDensity, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_InitialSeedDensity, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_InitialSeedDensity, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_InitialSeedDensity, TEXT("ToolTip"), TEXT("Specifies the number of seeds to populate along 10 meters. The number is implicitly squared to cover a 10m x 10m area"));
				MetaData->SetValue(NewProp_InitialSeedDensity, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_NumSteps, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_NumSteps, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_NumSteps, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_NumSteps, TEXT("Subcategory"), TEXT("Clustering"));
				MetaData->SetValue(NewProp_NumSteps, TEXT("ToolTip"), TEXT("The number of times we age the species and spread its seeds."));
				MetaData->SetValue(NewProp_NumSteps, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_ShadeRadius, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_ShadeRadius, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_ShadeRadius, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ShadeRadius, TEXT("Subcategory"), TEXT("Collision"));
				MetaData->SetValue(NewProp_ShadeRadius, TEXT("ToolTip"), TEXT("The ShadeRadius determines when two instances overlap. If an instance can grow in the shade this radius is ignored."));
				MetaData->SetValue(NewProp_ShadeRadius, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CollisionRadius, TEXT("Category"), TEXT("Procedural"));
				MetaData->SetValue(NewProp_CollisionRadius, TEXT("ClampMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_CollisionRadius, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_CollisionRadius, TEXT("Subcategory"), TEXT("Collision"));
				MetaData->SetValue(NewProp_CollisionRadius, TEXT("ToolTip"), TEXT("The CollisionRadius determines when two instances overlap. When two instances overlap a winner will be picked based on rules and priority."));
				MetaData->SetValue(NewProp_CollisionRadius, TEXT("UIMin"), TEXT("0.0"));
				MetaData->SetValue(NewProp_IsSelected, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_HiddenEditorViews, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_HiddenEditorViews, TEXT("ToolTip"), TEXT("Bitflag to represent in which editor views this foliage mesh is hidden."));
				MetaData->SetValue(NewProp_CustomNavigableGeometry, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_CustomNavigableGeometry, TEXT("HideObjectType"), TEXT("TRUE"));
				MetaData->SetValue(NewProp_CustomNavigableGeometry, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_CustomNavigableGeometry, TEXT("ToolTip"), TEXT("Force navmesh"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("HideObjectType"), TEXT("TRUE"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_BodyInstance, TEXT("ToolTip"), TEXT("Custom collision for foliage"));
				MetaData->SetValue(NewProp_bUseAsOccluder, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bUseAsOccluder, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bUseAsOccluder, TEXT("ToolTip"), TEXT("If enabled, foliage will render a pre-pass which allows it to occlude other primitives, and also allows\nit to correctly receive DBuffer decals. Enabling this setting may have a negative performance impact."));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("DisplayName"), TEXT("Light Map Resolution"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("EditCondition"), TEXT("bOverrideLightMapRes"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_OverriddenLightMapRes, TEXT("ToolTip"), TEXT("Overrides the lightmap resolution defined in the static mesh"));
				MetaData->SetValue(NewProp_bOverrideLightMapRes, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bOverrideLightMapRes, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bOverrideLightMapRes, TEXT("ToolTip"), TEXT("Whether to override the lightmap resolution defined in the static mesh."));
				MetaData->SetValue(NewProp_bReceivesDecals, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bReceivesDecals, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bReceivesDecals, TEXT("ToolTip"), TEXT("Whether the foliage receives decals."));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("EditCondition"), TEXT("bCastDynamicShadow"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bCastShadowAsTwoSided, TEXT("ToolTip"), TEXT("Whether this foliage should cast dynamic shadows as if it were a two sided material."));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bCastStaticShadow, TEXT("ToolTip"), TEXT("Whether the foliage should cast a static shadow from shadow casting lights.  This flag is only used if CastShadow is true."));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bCastDynamicShadow, TEXT("ToolTip"), TEXT("Controls whether the foliage should cast shadows in the case of non precomputed shadowing.  This flag is only used if CastShadow is true."));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bAffectDistanceFieldLighting, TEXT("ToolTip"), TEXT("Controls whether the primitive should affect dynamic distance field lighting methods.  This flag is only used if CastShadow is true."));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("EditCondition"), TEXT("CastShadow"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bAffectDynamicIndirectLighting, TEXT("ToolTip"), TEXT("Controls whether the foliage should inject light into the Light Propagation Volume.  This flag is only used if CastShadow is true."));
				MetaData->SetValue(NewProp_CastShadow, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_CastShadow, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_CastShadow, TEXT("ToolTip"), TEXT("Controls whether the foliage should cast a shadow or not."));
				MetaData->SetValue(NewProp_bEnableStaticLighting, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_bEnableStaticLighting, TEXT("ToolTip"), TEXT("Deprecated. Now use the Mobility setting to control static/dynamic lighting"));
				MetaData->SetValue(NewProp_CullDistance, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_CullDistance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_CullDistance, TEXT("ToolTip"), TEXT("The distance where instances will begin to fade out if using a PerInstanceFadeAmount material node. 0 disables.\nWhen the entire cluster is beyond this distance, the cluster is completely culled and not rendered at all."));
				MetaData->SetValue(NewProp_CullDistance, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Mobility, TEXT("Category"), TEXT("InstanceSettings"));
				MetaData->SetValue(NewProp_Mobility, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_Mobility, TEXT("ToolTip"), TEXT("Mobility property to apply to foliage components"));
				MetaData->SetValue(NewProp_LowBoundOriginRadius, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_LowBoundOriginRadius, TEXT("ToolTip"), TEXT("X, Y is origin position and Z is radius..."));
				MetaData->SetValue(NewProp_MeshBounds, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MinimumLayerWeight, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_MinimumLayerWeight, TEXT("HideBehind"), TEXT("LandscapeLayers"));
				MetaData->SetValue(NewProp_MinimumLayerWeight, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_MinimumLayerWeight, TEXT("ToolTip"), TEXT("Specifies the minimum value above which the landscape layer weight value must be, in order for foliage instances to be placed in a specific area"));
				MetaData->SetValue(NewProp_CollisionScale, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_CollisionScale, TEXT("HideBehind"), TEXT("CollisionWithWorld"));
				MetaData->SetValue(NewProp_CollisionScale, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_CollisionScale, TEXT("ToolTip"), TEXT("The foliage instance's collision bounding box will be scaled by the specified amount before performing the overlap check"));
				MetaData->SetValue(NewProp_CollisionWithWorld, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_CollisionWithWorld, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_CollisionWithWorld, TEXT("ReapplyCondition"), TEXT("ReapplyCollisionWithWorld"));
				MetaData->SetValue(NewProp_CollisionWithWorld, TEXT("ToolTip"), TEXT("If checked, an overlap test with existing world geometry is performed before each instance is placed"));
				MetaData->SetValue(NewProp_LandscapeLayer, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_LandscapeLayers, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_LandscapeLayers, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_LandscapeLayers, TEXT("ReapplyCondition"), TEXT("ReapplyLandscapeLayers"));
				MetaData->SetValue(NewProp_LandscapeLayers, TEXT("ToolTip"), TEXT("If a layer name is specified, painting on landscape will limit the foliage to areas of landscape with the specified layer painted"));
				MetaData->SetValue(NewProp_Height, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_Height, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_Height, TEXT("ReapplyCondition"), TEXT("ReapplyHeight"));
				MetaData->SetValue(NewProp_Height, TEXT("ToolTip"), TEXT("The valid altitude range where foliage instances will be placed, specified using minimum and maximum world coordinate Z values"));
				MetaData->SetValue(NewProp_GroundSlopeAngle, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_GroundSlopeAngle, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_GroundSlopeAngle, TEXT("ReapplyCondition"), TEXT("ReapplyGroundSlope"));
				MetaData->SetValue(NewProp_GroundSlopeAngle, TEXT("ToolTip"), TEXT("Foliage instances will only be placed on surfaces sloping in the specified angle range from the horizontal"));
				MetaData->SetValue(NewProp_GroundSlopeAngle, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_RandomPitchAngle, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_RandomPitchAngle, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_RandomPitchAngle, TEXT("ReapplyCondition"), TEXT("ReapplyRandomPitchAngle"));
				MetaData->SetValue(NewProp_RandomPitchAngle, TEXT("ToolTip"), TEXT("A random pitch adjustment can be applied to each instance, up to the specified angle in degrees, from the original vertical"));
				MetaData->SetValue(NewProp_RandomYaw, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_RandomYaw, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_RandomYaw, TEXT("ReapplyCondition"), TEXT("ReapplyRandomYaw"));
				MetaData->SetValue(NewProp_RandomYaw, TEXT("ToolTip"), TEXT("If selected, foliage instances will have a random yaw rotation around their vertical axis applied"));
				MetaData->SetValue(NewProp_AlignMaxAngle, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_AlignMaxAngle, TEXT("HideBehind"), TEXT("AlignToNormal"));
				MetaData->SetValue(NewProp_AlignMaxAngle, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_AlignMaxAngle, TEXT("ToolTip"), TEXT("The maximum angle in degrees that foliage instances will be adjusted away from the vertical"));
				MetaData->SetValue(NewProp_AlignToNormal, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_AlignToNormal, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_AlignToNormal, TEXT("ReapplyCondition"), TEXT("ReapplyAlignToNormal"));
				MetaData->SetValue(NewProp_AlignToNormal, TEXT("ToolTip"), TEXT("Whether foliage instances should have their angle adjusted away from vertical to match the normal of the surface they're painted on"));
				MetaData->SetValue(NewProp_ZOffset, TEXT("Category"), TEXT("Placement"));
				MetaData->SetValue(NewProp_ZOffset, TEXT("DisplayName"), TEXT("Z Offset"));
				MetaData->SetValue(NewProp_ZOffset, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ZOffset, TEXT("ReapplyCondition"), TEXT("ReapplyZOffset"));
				MetaData->SetValue(NewProp_ZOffset, TEXT("ToolTip"), TEXT("Specifies a range from minimum to maximum of the offset to apply to a foliage instance's Z location"));
				MetaData->SetValue(NewProp_VertexColorMaskInvert, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_VertexColorMaskInvert, TEXT("HideBehind"), TEXT("VertexColorMask"));
				MetaData->SetValue(NewProp_VertexColorMaskInvert, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_VertexColorMaskInvert, TEXT("ToolTip"), TEXT("When unchecked, foliage instances will be placed only when the vertex color in the specified channel(s) is above the threshold amount.\nWhen checked, the vertex color must be less than the threshold amount"));
				MetaData->SetValue(NewProp_VertexColorMaskThreshold, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_VertexColorMaskThreshold, TEXT("HideBehind"), TEXT("VertexColorMask"));
				MetaData->SetValue(NewProp_VertexColorMaskThreshold, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_VertexColorMaskThreshold, TEXT("ToolTip"), TEXT("Specifies the threshold value above which the static mesh vertex color value must be, in order for foliage instances to be placed in a specific area"));
				MetaData->SetValue(NewProp_VertexColorMask, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_VertexColorMask, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_VertexColorMask, TEXT("ReapplyCondition"), TEXT("ReapplyVertexColorMask"));
				MetaData->SetValue(NewProp_VertexColorMask, TEXT("ToolTip"), TEXT("When painting on static meshes, foliage instance placement can be limited to areas where the static mesh has values in the selected vertex color channel(s).\nThis allows a static mesh to mask out certain areas to prevent foliage from being placed there"));
				MetaData->SetValue(NewProp_ScaleZ, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_ScaleZ, TEXT("ClampMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_ScaleZ, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleZ, TEXT("ReapplyCondition"), TEXT("ReapplyScaleZ"));
				MetaData->SetValue(NewProp_ScaleZ, TEXT("ToolTip"), TEXT("Specifies the range of scale, from minimum to maximum, to apply to a foliage instance's Z Scale property"));
				MetaData->SetValue(NewProp_ScaleZ, TEXT("UIMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_ScaleY, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_ScaleY, TEXT("ClampMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_ScaleY, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleY, TEXT("ReapplyCondition"), TEXT("ReapplyScaleY"));
				MetaData->SetValue(NewProp_ScaleY, TEXT("ToolTip"), TEXT("Specifies the range of scale, from minimum to maximum, to apply to a foliage instance's Y Scale property"));
				MetaData->SetValue(NewProp_ScaleY, TEXT("UIMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_ScaleX, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_ScaleX, TEXT("ClampMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_ScaleX, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_ScaleX, TEXT("ReapplyCondition"), TEXT("ReapplyScaleX"));
				MetaData->SetValue(NewProp_ScaleX, TEXT("ToolTip"), TEXT("Specifies the range of scale, from minimum to maximum, to apply to a foliage instance's X Scale property"));
				MetaData->SetValue(NewProp_ScaleX, TEXT("UIMin"), TEXT("0.001"));
				MetaData->SetValue(NewProp_Scaling, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_Scaling, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_Scaling, TEXT("ReapplyCondition"), TEXT("ReapplyScaling"));
				MetaData->SetValue(NewProp_Scaling, TEXT("ToolTip"), TEXT("Specifies foliage instance scaling behavior when painting."));
				MetaData->SetValue(NewProp_Radius, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_Radius, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Radius, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_Radius, TEXT("ReapplyCondition"), TEXT("ReapplyRadius"));
				MetaData->SetValue(NewProp_Radius, TEXT("ToolTip"), TEXT("The minimum distance between foliage instances"));
				MetaData->SetValue(NewProp_Radius, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_DensityAdjustmentFactor, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_DensityAdjustmentFactor, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_DensityAdjustmentFactor, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_DensityAdjustmentFactor, TEXT("ReapplyCondition"), TEXT("ReapplyDensity"));
				MetaData->SetValue(NewProp_DensityAdjustmentFactor, TEXT("ToolTip"), TEXT("The factor by which to adjust the density of instances. Values >1 will increase density while values <1 will decrease it."));
				MetaData->SetValue(NewProp_DensityAdjustmentFactor, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Density, TEXT("Category"), TEXT("Painting"));
				MetaData->SetValue(NewProp_Density, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_Density, TEXT("DisplayName"), TEXT("Density / 1Kuu"));
				MetaData->SetValue(NewProp_Density, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_Density, TEXT("ToolTip"), TEXT("Foliage instances will be placed at this density, specified in instances per 1000x1000 unit area"));
				MetaData->SetValue(NewProp_Density, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_UpdateGuid, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType.h"));
				MetaData->SetValue(NewProp_UpdateGuid, TEXT("ToolTip"), TEXT("A GUID that is updated every time the foliage type is modified,\n         so foliage placed in the level can detect the FoliageType has changed."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UFoliageType(Z_Construct_UClass_UFoliageType, TEXT("UFoliageType"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UFoliageType);
	UClass* Z_Construct_UClass_UFoliageType_InstancedStaticMesh_NoRegister()
	{
		return UFoliageType_InstancedStaticMesh::StaticClass();
	}
	UClass* Z_Construct_UClass_UFoliageType_InstancedStaticMesh()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UFoliageType();
			Z_Construct_UPackage_Foliage();
			OuterClass = UFoliageType_InstancedStaticMesh::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20081080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ComponentClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ComponentClass"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(ComponentClass, UFoliageType_InstancedStaticMesh), 0x0004000000000001, Z_Construct_UClass_UFoliageInstancedStaticMeshComponent_NoRegister());
				UProperty* NewProp_OverrideMaterials = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OverrideMaterials"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OverrideMaterials, UFoliageType_InstancedStaticMesh), 0x0000040000000001);
				UProperty* NewProp_OverrideMaterials_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OverrideMaterials, TEXT("OverrideMaterials"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UMaterialInterface_NoRegister());
				UProperty* NewProp_Mesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Mesh, UFoliageType_InstancedStaticMesh), 0x0000000000000001, Z_Construct_UClass_UStaticMesh_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("FoliageType_InstancedStaticMesh.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType_InstancedStaticMesh.h"));
				MetaData->SetValue(NewProp_ComponentClass, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_ComponentClass, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType_InstancedStaticMesh.h"));
				MetaData->SetValue(NewProp_ComponentClass, TEXT("ToolTip"), TEXT("The component class to use for foliage instances.\nYou can make a Blueprint subclass of FoliageInstancedStaticMeshComponent to implement custom behavior and assign that class here."));
				MetaData->SetValue(NewProp_OverrideMaterials, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_OverrideMaterials, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType_InstancedStaticMesh.h"));
				MetaData->SetValue(NewProp_OverrideMaterials, TEXT("ToolTip"), TEXT("Material overrides for foliage instances."));
				MetaData->SetValue(NewProp_Mesh, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_Mesh, TEXT("DisplayThumbnail"), TEXT("true"));
				MetaData->SetValue(NewProp_Mesh, TEXT("ModuleRelativePath"), TEXT("Public/FoliageType_InstancedStaticMesh.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UFoliageType_InstancedStaticMesh(Z_Construct_UClass_UFoliageType_InstancedStaticMesh, TEXT("UFoliageType_InstancedStaticMesh"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UFoliageType_InstancedStaticMesh);
	UClass* Z_Construct_UClass_AInstancedFoliageActor_NoRegister()
	{
		return AInstancedFoliageActor::StaticClass();
	}
	UClass* Z_Construct_UClass_AInstancedFoliageActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Foliage();
			OuterClass = AInstancedFoliageActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880280;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("InstancedFoliageActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("false"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/InstancedFoliageActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AInstancedFoliageActor(Z_Construct_UClass_AInstancedFoliageActor, TEXT("AInstancedFoliageActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AInstancedFoliageActor);
	UFunction* Z_Construct_UFunction_AInteractiveFoliageActor_CapsuleTouched()
	{
		struct InteractiveFoliageActor_eventCapsuleTouched_Parms
		{
			AActor* Other;
			UPrimitiveComponent* OtherComp;
			int32 OtherBodyIndex;
			bool bFromSweep;
			FHitResult OverlapInfo;
		};
		UObject* Outer=Z_Construct_UClass_AInteractiveFoliageActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CapsuleTouched"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00480401, 65535, sizeof(InteractiveFoliageActor_eventCapsuleTouched_Parms));
			UProperty* NewProp_OverlapInfo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverlapInfo"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OverlapInfo, InteractiveFoliageActor_eventCapsuleTouched_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFromSweep, InteractiveFoliageActor_eventCapsuleTouched_Parms, bool);
			UProperty* NewProp_bFromSweep = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFromSweep"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFromSweep, InteractiveFoliageActor_eventCapsuleTouched_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(bFromSweep, InteractiveFoliageActor_eventCapsuleTouched_Parms), sizeof(bool), true);
			UProperty* NewProp_OtherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherBodyIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OtherBodyIndex, InteractiveFoliageActor_eventCapsuleTouched_Parms), 0x0000000000000080);
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, InteractiveFoliageActor_eventCapsuleTouched_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Other, InteractiveFoliageActor_eventCapsuleTouched_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when capsule is touched"));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AInteractiveFoliageActor_NoRegister()
	{
		return AInteractiveFoliageActor::StaticClass();
	}
	UClass* Z_Construct_UClass_AInteractiveFoliageActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AStaticMeshActor();
			Z_Construct_UPackage_Foliage();
			OuterClass = AInteractiveFoliageActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;

				OuterClass->LinkChild(Z_Construct_UFunction_AInteractiveFoliageActor_CapsuleTouched());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Mass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mass"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Mass, AInteractiveFoliageActor), 0x0000000000000000);
				UProperty* NewProp_MaxForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxForce"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxForce, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_MaxTouchImpulse = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxTouchImpulse"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxTouchImpulse, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_MaxDamageImpulse = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxDamageImpulse"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MaxDamageImpulse, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_FoliageDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageDamping"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FoliageDamping, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_FoliageStiffnessQuadratic = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageStiffnessQuadratic"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FoliageStiffnessQuadratic, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_FoliageStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageStiffness"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FoliageStiffness, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_FoliageTouchImpulseScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageTouchImpulseScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FoliageTouchImpulseScale, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_FoliageDamageImpulseScale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageDamageImpulseScale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FoliageDamageImpulseScale, AInteractiveFoliageActor), 0x0000000000000005);
				UProperty* NewProp_FoliagePosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliagePosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FoliagePosition, AInteractiveFoliageActor), 0x0000000000002000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FoliageForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageForce"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FoliageForce, AInteractiveFoliageActor), 0x0000000000002000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FoliageVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageVelocity"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(FoliageVelocity, AInteractiveFoliageActor), 0x0000000000002000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TouchingActorEntryPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TouchingActorEntryPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(TouchingActorEntryPosition, AInteractiveFoliageActor), 0x0000000000002000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_CapsuleComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CapsuleComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CapsuleComponent, AInteractiveFoliageActor), 0x0000000000080008, Z_Construct_UClass_UCapsuleComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AInteractiveFoliageActor_CapsuleTouched()); // 2901929204
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Input"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("InteractiveFoliageActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(NewProp_Mass, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_Mass, TEXT("ToolTip"), TEXT("@todo - hook this up     @todo document"));
				MetaData->SetValue(NewProp_MaxForce, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_MaxForce, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_MaxForce, TEXT("ToolTip"), TEXT("Clamps the magnitude of combined forces applied each update."));
				MetaData->SetValue(NewProp_MaxTouchImpulse, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_MaxTouchImpulse, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_MaxTouchImpulse, TEXT("ToolTip"), TEXT("Clamps the magnitude of each touch force applied."));
				MetaData->SetValue(NewProp_MaxDamageImpulse, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_MaxDamageImpulse, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_MaxDamageImpulse, TEXT("ToolTip"), TEXT("Clamps the magnitude of each damage force applied."));
				MetaData->SetValue(NewProp_FoliageDamping, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_FoliageDamping, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageDamping, TEXT("ToolTip"), TEXT("Determines the amount of energy lost by the spring as it oscillates.\nThis force is similar to air friction."));
				MetaData->SetValue(NewProp_FoliageStiffnessQuadratic, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_FoliageStiffnessQuadratic, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageStiffnessQuadratic, TEXT("ToolTip"), TEXT("Same as FoliageStiffness, but the strength of this force increases with the square of the distance to the spring's center.\nThis force is used to prevent the spring from extending past a certain point due to touch and damage forces."));
				MetaData->SetValue(NewProp_FoliageStiffness, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_FoliageStiffness, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageStiffness, TEXT("ToolTip"), TEXT("Determines how strong the force that pushes toward the spring's center will be."));
				MetaData->SetValue(NewProp_FoliageTouchImpulseScale, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_FoliageTouchImpulseScale, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageTouchImpulseScale, TEXT("ToolTip"), TEXT("Scales forces applied from touch events."));
				MetaData->SetValue(NewProp_FoliageDamageImpulseScale, TEXT("Category"), TEXT("FoliagePhysics"));
				MetaData->SetValue(NewProp_FoliageDamageImpulseScale, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageDamageImpulseScale, TEXT("ToolTip"), TEXT("Scales forces applied from damage events."));
				MetaData->SetValue(NewProp_FoliagePosition, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliagePosition, TEXT("ToolTip"), TEXT("@todo document"));
				MetaData->SetValue(NewProp_FoliageForce, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageForce, TEXT("ToolTip"), TEXT("@todo document"));
				MetaData->SetValue(NewProp_FoliageVelocity, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_FoliageVelocity, TEXT("ToolTip"), TEXT("Simulated physics state"));
				MetaData->SetValue(NewProp_TouchingActorEntryPosition, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_TouchingActorEntryPosition, TEXT("ToolTip"), TEXT("Position of the last actor to enter the collision cylinder.\nThis currently does not handle multiple actors affecting the foliage simultaneously."));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("ModuleRelativePath"), TEXT("Public/InteractiveFoliageActor.h"));
				MetaData->SetValue(NewProp_CapsuleComponent, TEXT("ToolTip"), TEXT("Collision cylinder"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AInteractiveFoliageActor(Z_Construct_UClass_AInteractiveFoliageActor, TEXT("AInteractiveFoliageActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AInteractiveFoliageActor);
	UClass* Z_Construct_UClass_UInteractiveFoliageComponent_NoRegister()
	{
		return UInteractiveFoliageComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UInteractiveFoliageComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UStaticMeshComponent();
			Z_Construct_UPackage_Foliage();
			OuterClass = UInteractiveFoliageComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A01080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object Activation Components|Activation Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("InteractiveFoliageComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Private/InteractiveFoliageComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UInteractiveFoliageComponent(Z_Construct_UClass_UInteractiveFoliageComponent, TEXT("UInteractiveFoliageComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UInteractiveFoliageComponent);
	UClass* Z_Construct_UClass_AProceduralFoliageBlockingVolume_NoRegister()
	{
		return AProceduralFoliageBlockingVolume::StaticClass();
	}
	UClass* Z_Construct_UClass_AProceduralFoliageBlockingVolume()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AVolume();
			Z_Construct_UPackage_Foliage();
			OuterClass = AProceduralFoliageBlockingVolume::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20880080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ProceduralFoliageVolume = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProceduralFoliageVolume"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ProceduralFoliageVolume, AProceduralFoliageBlockingVolume), 0x0000000000000001, Z_Construct_UClass_AProceduralFoliageVolume_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Brush Physics Object Display Rendering Physics Input Blueprint"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ProceduralFoliageBlockingVolume.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageBlockingVolume.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("An invisible volume used to block ProceduralFoliage instances from being spawned."));
				MetaData->SetValue(NewProp_ProceduralFoliageVolume, TEXT("Category"), TEXT("ProceduralFoliage"));
				MetaData->SetValue(NewProp_ProceduralFoliageVolume, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageBlockingVolume.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AProceduralFoliageBlockingVolume(Z_Construct_UClass_AProceduralFoliageBlockingVolume, TEXT("AProceduralFoliageBlockingVolume"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AProceduralFoliageBlockingVolume);
	UEnum* Z_Construct_UEnum_Foliage_ESimulationQuery()
	{
		UPackage* Outer=Z_Construct_UPackage_Foliage();
		extern uint32 Get_Z_Construct_UEnum_Foliage_ESimulationQuery_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESimulationQuery"), 0, Get_Z_Construct_UEnum_Foliage_ESimulationQuery_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESimulationQuery"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationQuery::CollisionOverlap")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationQuery::ShadeOverlap")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationQuery::AnyOverlap")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationQuery::ESimulationQuery_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AnyOverlap.ToolTip"), TEXT("any overlap"));
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("CollisionOverlap.ToolTip"), TEXT("Instances overlap with collision"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ShadeOverlap.ToolTip"), TEXT("Instances overlap with shade"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Foliage_ESimulationQuery_CRC() { return 3310138528U; }
	UEnum* Z_Construct_UEnum_Foliage_ESimulationOverlap()
	{
		UPackage* Outer=Z_Construct_UPackage_Foliage();
		extern uint32 Get_Z_Construct_UEnum_Foliage_ESimulationOverlap_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReload(Outer, TEXT("ESimulationOverlap"), 0, Get_Z_Construct_UEnum_Foliage_ESimulationOverlap_CRC());
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESimulationOverlap"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationOverlap::CollisionOverlap")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationOverlap::ShadeOverlap")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationOverlap::None")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ESimulationOverlap::ESimulationOverlap_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("CollisionOverlap.ToolTip"), TEXT("Instances overlap with collision"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(ReturnEnum, TEXT("None.ToolTip"), TEXT("No overlap"));
			MetaData->SetValue(ReturnEnum, TEXT("ShadeOverlap.ToolTip"), TEXT("Instances overlap with shade"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_Foliage_ESimulationOverlap_CRC() { return 331268282U; }
	UScriptStruct* Z_Construct_UScriptStruct_FProceduralFoliageInstance()
	{
		UPackage* Outer=Z_Construct_UPackage_Foliage();
		extern uint32 Get_Z_Construct_UScriptStruct_FProceduralFoliageInstance_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("ProceduralFoliageInstance"), sizeof(FProceduralFoliageInstance), Get_Z_Construct_UScriptStruct_FProceduralFoliageInstance_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ProceduralFoliageInstance"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FProceduralFoliageInstance>, EStructFlags(0x00000201));
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Type"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Type, FProceduralFoliageInstance), 0x0000000000000000, Z_Construct_UClass_UFoliageType_InstancedStaticMesh_NoRegister());
			UProperty* NewProp_Scale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Scale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scale, FProceduralFoliageInstance), 0x0000000000000000);
			UProperty* NewProp_Age = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Age"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Age, FProceduralFoliageInstance), 0x0000000000000005);
			UProperty* NewProp_Normal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Normal"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Normal, FProceduralFoliageInstance), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Rotation, FProceduralFoliageInstance), 0x0000000000000000, Z_Construct_UScriptStruct_FQuat());
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Location"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Location, FProceduralFoliageInstance), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(NewProp_Scale, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(NewProp_Age, TEXT("Category"), TEXT("ProceduralFoliageInstance"));
			MetaData->SetValue(NewProp_Age, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(NewProp_Normal, TEXT("Category"), TEXT("ProceduralFoliageInstance"));
			MetaData->SetValue(NewProp_Normal, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
			MetaData->SetValue(NewProp_Location, TEXT("Category"), TEXT("ProceduralFoliageInstance"));
			MetaData->SetValue(NewProp_Location, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageInstance.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FProceduralFoliageInstance_CRC() { return 2674150340U; }
	UClass* Z_Construct_UClass_UProceduralFoliageComponent_NoRegister()
	{
		return UProceduralFoliageComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UProceduralFoliageComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_Foliage();
			OuterClass = UProceduralFoliageComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ProceduralGuid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProceduralGuid"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ProceduralGuid, UProceduralFoliageComponent), 0x0000000000000000, Z_Construct_UScriptStruct_FGuid());
				UProperty* NewProp_SpawningVolume = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpawningVolume"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(SpawningVolume, UProceduralFoliageComponent), 0x0000000000000000, Z_Construct_UClass_AVolume_NoRegister());
#if WITH_EDITORONLY_DATA
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowDebugTiles, UProceduralFoliageComponent, bool);
				UProperty* NewProp_bShowDebugTiles = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowDebugTiles"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowDebugTiles, UProceduralFoliageComponent), 0x0000000800000005, CPP_BOOL_PROPERTY_BITMASK(bShowDebugTiles, UProceduralFoliageComponent), sizeof(bool), true);
#endif // WITH_EDITORONLY_DATA
				UProperty* NewProp_TileOverlap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TileOverlap"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TileOverlap, UProceduralFoliageComponent), 0x0000000000000005);
				UProperty* NewProp_FoliageSpawner = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageSpawner"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FoliageSpawner, UProceduralFoliageComponent), 0x0000000000000005, Z_Construct_UClass_UProceduralFoliageSpawner_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ProceduralFoliageComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageComponent.h"));
				MetaData->SetValue(NewProp_ProceduralGuid, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageComponent.h"));
				MetaData->SetValue(NewProp_SpawningVolume, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageComponent.h"));
				MetaData->SetValue(NewProp_bShowDebugTiles, TEXT("Category"), TEXT("ProceduralFoliage"));
				MetaData->SetValue(NewProp_bShowDebugTiles, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageComponent.h"));
				MetaData->SetValue(NewProp_bShowDebugTiles, TEXT("ToolTip"), TEXT("Whether to visualize the tiles used for the foliage spawner simulation"));
				MetaData->SetValue(NewProp_TileOverlap, TEXT("Category"), TEXT("ProceduralFoliage"));
				MetaData->SetValue(NewProp_TileOverlap, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageComponent.h"));
				MetaData->SetValue(NewProp_TileOverlap, TEXT("ToolTip"), TEXT("The amount of overlap between simulation tiles (in cm)."));
				MetaData->SetValue(NewProp_FoliageSpawner, TEXT("Category"), TEXT("ProceduralFoliage"));
				MetaData->SetValue(NewProp_FoliageSpawner, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageComponent.h"));
				MetaData->SetValue(NewProp_FoliageSpawner, TEXT("ToolTip"), TEXT("The procedural foliage spawner used to generate foliage instances within this volume."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UProceduralFoliageComponent(Z_Construct_UClass_UProceduralFoliageComponent, TEXT("UProceduralFoliageComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UProceduralFoliageComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FFoliageTypeObject()
	{
		UPackage* Outer=Z_Construct_UPackage_Foliage();
		extern uint32 Get_Z_Construct_UScriptStruct_FFoliageTypeObject_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReload(Outer, TEXT("FoliageTypeObject"), sizeof(FFoliageTypeObject), Get_Z_Construct_UScriptStruct_FFoliageTypeObject_CRC());
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FoliageTypeObject"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FFoliageTypeObject>, EStructFlags(0x00000201));
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Type"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(Type_DEPRECATED, FFoliageTypeObject), 0x0004000020000000, Z_Construct_UClass_UFoliageType_InstancedStaticMesh_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsAsset, FFoliageTypeObject, bool);
			UProperty* NewProp_bIsAsset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsAsset"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsAsset, FFoliageTypeObject), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bIsAsset, FFoliageTypeObject), sizeof(bool), true);
			UProperty* NewProp_TypeInstance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TypeInstance"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(TypeInstance, FFoliageTypeObject), 0x0000000000002000, Z_Construct_UClass_UFoliageType_InstancedStaticMesh_NoRegister());
			UProperty* NewProp_FoliageTypeObject = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FoliageTypeObject"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FoliageTypeObject, FFoliageTypeObject), 0x0000000000000001, Z_Construct_UClass_UObject_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/FoliageTypeObject.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A wrapper struct used to allow the use of either FoliageType assets or FoliageType blueprint classes"));
			MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/FoliageTypeObject.h"));
			MetaData->SetValue(NewProp_bIsAsset, TEXT("ModuleRelativePath"), TEXT("Public/FoliageTypeObject.h"));
			MetaData->SetValue(NewProp_bIsAsset, TEXT("ToolTip"), TEXT("Whether this contains an asset object (as opposed to a BP class)"));
			MetaData->SetValue(NewProp_TypeInstance, TEXT("ModuleRelativePath"), TEXT("Public/FoliageTypeObject.h"));
			MetaData->SetValue(NewProp_TypeInstance, TEXT("ToolTip"), TEXT("The actual instance of the foliage type that is used for spawning"));
			MetaData->SetValue(NewProp_FoliageTypeObject, TEXT("AllowedClasses"), TEXT("FoliageType_InstancedStaticMesh,Blueprint"));
			MetaData->SetValue(NewProp_FoliageTypeObject, TEXT("Category"), TEXT("ProceduralFoliageSimulation"));
			MetaData->SetValue(NewProp_FoliageTypeObject, TEXT("DisplayThumbnail"), TEXT("true"));
			MetaData->SetValue(NewProp_FoliageTypeObject, TEXT("ModuleRelativePath"), TEXT("Public/FoliageTypeObject.h"));
			MetaData->SetValue(NewProp_FoliageTypeObject, TEXT("ThumbnailSize"), TEXT("X=40 Y=40"));
			MetaData->SetValue(NewProp_FoliageTypeObject, TEXT("ToolTip"), TEXT("The foliage type that will be spawned by the procedural foliage simulation"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFoliageTypeObject_CRC() { return 402850965U; }
	UFunction* Z_Construct_UFunction_UProceduralFoliageSpawner_Simulate()
	{
		struct ProceduralFoliageSpawner_eventSimulate_Parms
		{
			int32 NumSteps;
		};
		UObject* Outer=Z_Construct_UClass_UProceduralFoliageSpawner();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Simulate"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(ProceduralFoliageSpawner_eventSimulate_Parms));
			UProperty* NewProp_NumSteps = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NumSteps"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NumSteps, ProceduralFoliageSpawner_eventSimulate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("ProceduralFoliageSimulation"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_NumSteps"), TEXT("-1"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UProceduralFoliageSpawner_NoRegister()
	{
		return UProceduralFoliageSpawner::StaticClass();
	}
	UClass* Z_Construct_UClass_UProceduralFoliageSpawner()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Foliage();
			OuterClass = UProceduralFoliageSpawner::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_UProceduralFoliageSpawner_Simulate());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNeedsSimulation, UProceduralFoliageSpawner, bool);
				UProperty* NewProp_bNeedsSimulation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNeedsSimulation"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNeedsSimulation, UProceduralFoliageSpawner), 0x0000000000000000, CPP_BOOL_PROPERTY_BITMASK(bNeedsSimulation, UProceduralFoliageSpawner), sizeof(bool), true);
				UProperty* NewProp_FoliageTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageTypes"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(FoliageTypes, UProceduralFoliageSpawner), 0x0000000000000001);
				UProperty* NewProp_FoliageTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_FoliageTypes, TEXT("FoliageTypes"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FFoliageTypeObject());
				UProperty* NewProp_NumUniqueTiles = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NumUniqueTiles"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(NumUniqueTiles, UProceduralFoliageSpawner), 0x0000000000000015);
				UProperty* NewProp_TileSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TileSize"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(TileSize, UProceduralFoliageSpawner), 0x0000000000000015);
				UProperty* NewProp_RandomSeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RandomSeed"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(RandomSeed, UProceduralFoliageSpawner), 0x0000000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UProceduralFoliageSpawner_Simulate()); // 1014633497
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ProceduralFoliageSpawner.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
				MetaData->SetValue(NewProp_bNeedsSimulation, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
				MetaData->SetValue(NewProp_FoliageTypes, TEXT("Category"), TEXT("ProceduralFoliageSimulation"));
				MetaData->SetValue(NewProp_FoliageTypes, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
				MetaData->SetValue(NewProp_FoliageTypes, TEXT("ToolTip"), TEXT("The types of foliage to procedurally spawn."));
				MetaData->SetValue(NewProp_NumUniqueTiles, TEXT("Category"), TEXT("ProceduralFoliageSimulation"));
				MetaData->SetValue(NewProp_NumUniqueTiles, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
				MetaData->SetValue(NewProp_NumUniqueTiles, TEXT("ToolTip"), TEXT("The number of unique tiles to generate. The final simulation is a procedurally determined combination of the various unique tiles."));
				MetaData->SetValue(NewProp_TileSize, TEXT("Category"), TEXT("ProceduralFoliageSimulation"));
				MetaData->SetValue(NewProp_TileSize, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
				MetaData->SetValue(NewProp_TileSize, TEXT("ToolTip"), TEXT("Length of the tile (in cm) along one axis. The total area of the tile will be TileSize*TileSize."));
				MetaData->SetValue(NewProp_RandomSeed, TEXT("Category"), TEXT("ProceduralFoliageSimulation"));
				MetaData->SetValue(NewProp_RandomSeed, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageSpawner.h"));
				MetaData->SetValue(NewProp_RandomSeed, TEXT("ToolTip"), TEXT("The seed used for generating the randomness of the simulation."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UProceduralFoliageSpawner(Z_Construct_UClass_UProceduralFoliageSpawner, TEXT("UProceduralFoliageSpawner"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UProceduralFoliageSpawner);
	UClass* Z_Construct_UClass_UProceduralFoliageTile_NoRegister()
	{
		return UProceduralFoliageTile::StaticClass();
	}
	UClass* Z_Construct_UClass_UProceduralFoliageTile()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_Foliage();
			OuterClass = UProceduralFoliageTile::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_InstancesArray = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstancesArray"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(InstancesArray, UProceduralFoliageTile), 0x0000000000000000);
				UProperty* NewProp_InstancesArray_Inner = new(EC_InternalUseOnlyConstructor, NewProp_InstancesArray, TEXT("InstancesArray"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FProceduralFoliageInstance());
				UProperty* NewProp_FoliageSpawner = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FoliageSpawner"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FoliageSpawner, UProceduralFoliageTile), 0x0000000000000000, Z_Construct_UClass_UProceduralFoliageSpawner_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ProceduralFoliageTile.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageTile.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Procedurally determines where to spawn foliage meshes within a discrete area.\nGenerally, a procedural foliage simulation as a whole is composed of multiple tiles.\nTiles are able to overlap one another as well to create a seamless appearance.\n\nNote that the tile is not responsible for actually spawning any instances, it only determines where they should be placed.\nFollowing a simulation, call ExtractDesiredInstances for information about where each instance should spawn.\n\nNote also that, barring any core changes to the ordering of TSet, foliage generation is deterministic\n(i.e. given the same inputs, the result of the simulation will always be the same)."));
				MetaData->SetValue(NewProp_InstancesArray, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageTile.h"));
				MetaData->SetValue(NewProp_FoliageSpawner, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageTile.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UProceduralFoliageTile(Z_Construct_UClass_UProceduralFoliageTile, TEXT("UProceduralFoliageTile"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UProceduralFoliageTile);
	UClass* Z_Construct_UClass_AProceduralFoliageVolume_NoRegister()
	{
		return AProceduralFoliageVolume::StaticClass();
	}
	UClass* Z_Construct_UClass_AProceduralFoliageVolume()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AVolume();
			Z_Construct_UPackage_Foliage();
			OuterClass = AProceduralFoliageVolume::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ProceduralComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProceduralComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ProceduralComponent, AProceduralFoliageVolume), 0x00000000000a001d, Z_Construct_UClass_UProceduralFoliageComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Brush Physics Object Display Rendering Physics Input Blueprint"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ProceduralFoliageVolume.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageVolume.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(NewProp_ProceduralComponent, TEXT("Category"), TEXT("ProceduralFoliage"));
				MetaData->SetValue(NewProp_ProceduralComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ProceduralComponent, TEXT("ModuleRelativePath"), TEXT("Public/ProceduralFoliageVolume.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AProceduralFoliageVolume(Z_Construct_UClass_AProceduralFoliageVolume, TEXT("AProceduralFoliageVolume"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AProceduralFoliageVolume);
	UPackage* Z_Construct_UPackage_Foliage()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/Foliage")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x91C29A5A;
			Guid.B = 0x6CC043B9;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

			Z_Construct_UDelegateFunction_Foliage_InstancePointDamageSignature__DelegateSignature();
			Z_Construct_UDelegateFunction_Foliage_InstanceRadialDamageSignature__DelegateSignature();
		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
